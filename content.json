{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2010-02-27T14:43:29.000Z","updated":"2018-10-02T15:06:31.378Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"@Alibaba Inc @Southeast University E-mail: happyhls#happyhls.me web: http://happyhls.me"},{"title":"好友","date":"2014-11-24T08:15:38.000Z","updated":"2018-10-03T16:12:52.729Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":"扫一扫二维码，随手关注“问题青年”。一句话介绍：我的好朋友小森开的微信公众号，致力于发现好的产品，艺术，设计。你应该拥有的高品质生活指南。微信号是：teenasker"},{"title":"留言板","date":"2010-02-15T14:36:29.000Z","updated":"2018-10-02T15:06:31.378Z","comments":true,"path":"message-box/index.html","permalink":"http://yoursite.com/message-box/index.html","excerpt":"","text":""},{"title":"","date":"2018-10-03T16:06:15.666Z","updated":"2013-02-28T07:36:14.000Z","comments":true,"path":"images/wordpress/montezuma/javascript.js","permalink":"http://yoursite.com/images/wordpress/montezuma/javascript.js","excerpt":"","text":"var ua = jQuery.browser; /******************************* * Equal Height Columns Function ******************************/ function bfa_equal_columns() { jQuery('.ehc').each( function() { var row = jQuery(this); if ( ua.msie && parseInt( ua.version, 10 ) < 8 ) { var height = row.outerHeight(); // outerheight for IE < 8 } else { // var height = row.height(); var height = row.outerHeight(); } row.find('> div').each( function() { jQuery(this).height( height ); }); }); } function bfa_video_resize() { jQuery('.row > div, .row5 > div, .lw').each( function() { var col = jQuery(this), p = col.find('.post').first(), bc = p.find('.post-bodycopy'), maxWidth = col.width() - ( p.outerWidth() - p.width() ) - ( bc.outerWidth() - bc.width() ); col.find('embed, iframe').each( function() { var video = jQuery(this), videoWidth = video.attr('width'); if( videoWidth > maxWidth ) { videoHeight = video.attr('height'), videoMaxHeight = ( maxWidth / videoWidth * videoHeight ); video.attr({ width: maxWidth, height: videoMaxHeight }); } }); }); } function bfa_img_grayscale() { jQuery('.post-thumb img').each(function(){ var el = jQuery(this); el.css({'position':'absolute'}) .wrap(\"\") .clone().addClass('img_grayscale') .css({'position':'absolute','z-index':'998','opacity':'1.0'}) .insertBefore(el) .queue(function(){ var el = jQuery(this); el.parent().css({'width':this.offsetWidth,'height':this.offsetHeight }); el.dequeue(); }); }); } /******************************* * Grayscale post thumbs ******************************/ jQuery(window).load(function() { if( jQuery(window).width() > 959 ) { bfa_img_grayscale(); } }); /******************************* * Run on resize ******************************/ jQuery(window).resize(function() { bfa_video_resize(); bfa_equal_columns(); }); WebFontConfig = { // google: { families: [ 'Yanone Kaffeesatz:400,300,200,700', 'Gruppo', 'Droid Sans:normal,bold' ] }, google: { families: [\"Yanone+Kaffeesatz:400,200\"] }, fontactive: function(fontFamily, fontDescription) { // Avoids 'FOUC' - Flash of unstyled content in Firefox, Set 'body { opacity: 0 }' in CSS stylesheet jQuery('body').css('opacity', 1); bfa_equal_columns(); } }; (function() { var wf = document.createElement('script'); wf.src = ('https:' == document.location.protocol ? 'https' : 'http') + '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js'; wf.type = 'text/javascript'; wf.async = 'true'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(wf, s); })(); jQuery(document).ready(function($) { if( $('body').css('opacity') == 0 ) { $('body').css('opacity', 1); } // A class for zebra-striped table rows $('.hentry table tr:nth-child(even), .comment-text table tr:nth-child(even)').addClass('alternate'); if( jQuery().colorbox ) { $('.gallery figure a span').colorbox({rel: 'gal', slideshow: true, slideshowSpeed: 3500, opacity: 0.7, href: function(){ var src = $(this).prev('img').attr('src').replace( /-\\d+x\\d+./, '.' ); // full src = remove '-150x150' from thumb src return src; }}); } bfa_video_resize(); // Fade image if( $(window).width() > 959 ) { $('.hentry').hover( function(){ $(this).find('.img_grayscale').stop().animate({opacity:0}, 1000).next().stop().animate({opacity:1}, 700); }, function(){ $(this).find('.img_grayscale').stop().animate({opacity:1}, 1000).next().stop().animate({opacity:0}, 700); } ); } else { $('.hentry .post-thumb img').css('opacity', 1); } /** * jQuery Mobile Menu * Turn unordered list menu into dropdown select menu * version 1.0(31-OCT-2011) * * Built on top of the jQuery library * http://jquery.com * * Documentation * http://github.com/mambows/mobilemenu */ (function($){ $.fn.mobileMenu = function(options) { var defaults = { defaultText: 'Navigate to...', className: 'select-menu', subMenuClass: 'sub-menu', subMenuDash: '&ndash;' }, settings = $.extend( defaults, options ), el = $(this); this.each(function(){ // ad class to submenu list el.find('ul').addClass(settings.subMenuClass); // Create base menu $('',{ 'class' : settings.className }).insertAfter( el ); // Create default option $('', { 'value' : '#', 'text' : settings.defaultText }).appendTo( '.' + settings.className ); // Create select option from menu el.find('a').each(function(){ var $this = $(this), optText = '&nbsp;' + $this.text(), optSub = $this.parents( '.' + settings.subMenuClass ), len = optSub.length, dash; // if menu has sub menu if( $this.parents('ul').hasClass( settings.subMenuClass ) ) { dash = Array( len+1 ).join( settings.subMenuDash ); optText = dash + optText; } // Now build menu and append it $('', { 'value' : this.href, 'html' : optText, 'selected' : (this.href == window.location.href) }).appendTo( '.' + settings.className ); }); // End el.find('a').each // Change event on select element $('.' + settings.className).change(function(){ var locations = $(this).val(); if( locations !== '#' ) { window.location.href = $(this).val(); }; }); }); // End this.each return this; }; })(jQuery); $('#menu1').mobileMenu({ defaultText: 'Navigate to...', className: 'menu1-mobile', subMenuDash: '&nbsp; &mdash; &nbsp; ' }); /******************************* * SPLIT TITLES ******************************/ /* Split titles: 2-color titles for site-, post- and widget titles */ $('#sitetitle a, .hentry h2 a[rel=bookmark], .hentry h1 a[rel=bookmark], .image-attachment h1, .widget h3 span').each( function() { var str = $(this).text(); if( str.indexOf(' ') > 0 ) { var space = ' '; } else { var space = ''; } var strArray = str.split(space), fullLength = strArray.length, halfLength = Math.ceil( fullLength / 2 ), restLength = fullLength - halfLength, newstr = ''; for( var i = 0; i < halfLength; i++ ) { newstr += strArray[i] + space; } newstr += '' + space; for( var i = halfLength; i < fullLength; i++ ) { newstr += strArray[i] + space; } $(this).html( newstr ); }); /******************************* * ADD SOME MENU CLASSES ******************************/ // Add class to menu list items with children $('ul.children, ul.sub-menu').parent('li').addClass('has-sub-menu'); // wp_list_categories does not provide 'ancestor' classes like wp_list_pages and wp_nav_menu: $('ul.menu li.active').parents('li:not(.ancestor)').addClass('ancestor'); /******************************* * INSERT for CSS SPRITE ICONS ******************************/ $('.widget ul li, .widget h3, .breadcrumbs ol li, .hentry ul li, .comment-text ul li, li.has-sub-menu a, .menu > li > a, .post-tags, .post-categories').prepend(''); /******************************* * SMOOTH MENU ******************************/ $('#menu1 > li').smoothMenu({ zIndex: 10, duration: 700, easing: 'easeOutExpo', dockId: 'menu1-smooth' }); });"},{"title":"","date":"2018-10-03T16:06:15.667Z","updated":"2013-02-28T07:36:14.000Z","comments":true,"path":"images/wordpress/montezuma/style.css","permalink":"http://yoursite.com/images/wordpress/montezuma/style.css","excerpt":"","text":".row, .row5, .lw { width: 960px; margin: 0 auto; } .row > div, .row5 > div, .row > nav, .row5 > nav { float: left; position: relative; } .col1 {width:80px} .col2 {width:160px} .col3 {width:240px} .col4 {width:320px} .col5 {width:400px} .col6 {width:480px} .col7 {width:560px} .col8 {width:640px} .col9 {width:720px} .col10 {width:800px} .col11 {width:880px} .col12 {width:960px} .push1 {left:80px} .push2 {left:160px} .push3 {left:240px} .push4 {left:320px} .push5 {left:400px} .push6 {left:480px} .push7 {left:560px} .push8 {left:640px} .push9 {left:720px} .push10 {left:800px} .push11 {left:880px} .pull1 {right:80px} .pull2 {right:160px} .pull3 {right:240px} .pull4 {right:320px} .pull5 {right:400px} .pull6 {right:480px} .pull7 {right:560px} .pull8 {right:640px} .pull9 {right:720px} .pull10 {right:800px} .pull11 {right:880px} .row5 > div {width:192px} .row5 .push1 {left:192px} .row5 .push2 {left:384px} .row5 .push3 {left:576px} .row5 .push4 {left:768px} .row5 .pull1 {right:192px} .row5 .pull2 {right:384px} .row5 .pull3 {right:576px} .row5 .pull4 {right:768px} @media only screen and (min-width: 768px) and (max-width: 959px) { .row, .row5, .lw {width:720px;} .col1 {width:60px} .col2 {width:120px} .col3 {width:180px} .col4 {width:240px} .col5 {width:300px} .col6 {width:360px} .col7 {width:420px} .col8 {width:480px} .col9 {width:540px} .col10 {width:600px} .col11 {width:660px} .col12 {width:720px} .push1 {left:60px} .push2 {left:120px} .push3 {left:180px} .push4 {left:240px} .push5 {left:300px} .push6 {left:360px} .push7 {left:420px} .push8 {left:480px} .push9 {left:540px} .push10 {left:600px} .push11 {left:660px} .pull1 {right:60px} .pull2 {right:120px} .pull3 {right:180px} .pull4 {right:240px} .pull5 {right:300px} .pull6 {right:360px} .pull7 {right:420px} .pull8 {right:480px} .pull9 {right:540px} .pull10 {right:600px} .pull11 {right:660px} .row5 > div {width:144px} .row5 .push1 {left:144px} .row5 .push2 {left:288px} .row5 .push3 {left:432px} .row5 .push4 {left:576px} .row5 .pull1 {right:144px} .row5 .pull2 {right:288px} .row5 .pull3 {right:432px} .row5 .pull4 {right:576px} } @media only screen and (max-width: 767px) { body { width: 100%; min-width: 0; margin-left: 0; margin-right: 0; padding-left: 0; padding-right: 0; } .row, .row5, .lw { width: 100%; min-width: 0; margin-left: 0; margin-right: 0; } .row > div, .row5 > div { margin: 0 !important; float: none !important } .col1, .col2, .col3, .col4, .col5, .col6, .col7, .col8, .col9, .col10, .col11, .col12, .row5 > div { width:100% !important; } .push1, .push2, .push3, .push4, .push5, .push6, .push7, .push8, .push9, .push10, .push11, .push12 { left:auto !important; } .pull1, .pull2, .pull3, .pull4, .pull5, .pull6, .pull7, .pull8, .pull9, .pull10, .pull11, .pull12 { right:auto !important; } } * { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; o-box-sizing: border-box; } .row, .lw { -moz-box-sizing: content-box; -webkit-box-sizing: content-box; box-sizing: content-box; o-box-sizing: content-box; } body { margin: 0; padding: 0; font-family: \"Segoe UI\", \"Lucida Grande\", \"Helvetica Neue\", sans-serif; font-size: 15px; opacity: 0; } article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } a { color: #0090d3; text-decoration: none; } a:hover { text-decoration: underline; } a:active { } a:visited { } .post-bodycopy a, .widget a, .singlenav a, .commentlist a, .logged-in-as a { border-bottom: dotted 2px transparent; } .post-bodycopy a:hover, .widget a:hover, .singlenav a:hover, .commentlist a:hover, .logged-in-as a:hover { border-bottom-color: #0090d3; text-decoration: none; color: #0090d3; } a, .widget > h3, .widget > h3 i, .ed_button, #submit, .thumb-shadow, .firstpart, #menu1 i, .commentlist li > div, .commentlist .avatar { transition: all 0.5s ease-out; -webkit-transition: all 0.5s ease-out; -moz-transition: all 0.5s ease-out; -o-transition: all 0.5s ease-out; } h1, h2, h3, h4, h5, h6 { font-family: 'Yanone Kaffeesatz', sans-serif; font-weight: normal; margin: 20px 0 10px 0; } h1 { font-size: 40px; line-height: 44px; } h2 { font-size: 36px; line-height: 40px; } h3 { font-size: 32px; line-height: 35px; } h4 { font-size: 28px; line-height: 33px; } h5 { font-size: 24px; line-height: 27px; } h6 { font-size: 20px; line-height: 22px; } a img { border: none; } .wp-caption { } .wp-caption.alignleft, .wp-caption.alignnone { margin-left: -9px; } .wp-caption.alignright { margin-right: -9px; } .wp-caption img { background: #fff; padding: 10px; border: solid 2px #cccccc; } .wp-caption-text { color: #999999; font-size: 14px; text-align: center; padding: 5px; margin-bottom: 0; } iframe .player-container { border: solid 3px #000000; } .alignleft { float: left; margin: 5px 15px 10px 0; } .alignright { float: right; margin: 5px 0 10px 15px; } .aligncenter { display: block; margin: 0 auto; } .gallery-caption { } body.page .hentry img, body.single .hentry img { padding: 7px; border: solid 1px #dddddd; } .widget, .hentry { word-wrap: break-word; } input, textarea { max-width: 100%; } img { max-width: 100%; height: auto; display: block; width: auto; } img.wp-smiley { display: inline; } .wp-caption { max-width: 100% !important; width: auto; height: auto; } embed { max-width: 100% !important; border: none; height: auto; } .hentry ul, .comment-text ul { list-style: none; margin: 10px 0; padding-left: 25px; } .hentry ul li, .comment-text ul li { padding-left: 0px; margin-bottom: 2px; } .hentry ul li i, .comment-text ul li i { display: inline-block; width: 12px; height: 12px; margin-right: 10px; margin-left: -20px; background: transparent url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/icons.png) -48px -84px no-repeat; } .hentry ul ul li i, .comment-text ul ul li i { background: transparent url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/icons.png) 0px -48px no-repeat; } .hentry ul ul, .comment-text ul ul { margin-top: 2px; margin-bottom: 3px; margin-left: 0px; padding-left: 22px; } .hentry ol, .comment-text ol { margin: 0; padding: 0 0 0 35px; list-style: decimal; } .hentry ol li, .comment-text ol li { margin-bottom: 5px; } .hentry ol ol, .comment-text ol ol { list-style: lower-roman; } .hentry ol ol ol, .comment-text ol ol ol { list-style: lower-alpha; } .hentry dl, .comment-text dl { margin: 20px 0; } .hentry dt, .comment-text dt { font-weight: bold; margin: 10px 0; } .hentry dd, .comment-text dd { margin-left: 0; padding-left: 20px; } .hentry table, .comment-text table { border-collapse: collapse; border-bottom: solid 1px #e7e7e7; margin-bottom: 10px; } .hentry table caption, .comment-text table caption { color: #707070; font-size: 14px; letter-spacing: 1px; text-transform: uppercase; padding: 4px; } .hentry table th, .comment-text table th { padding: 6px 8px 6px 9px; text-align: left; } .hentry table td, .comment-text table td { padding: 5px 8px; border-top: solid 1px #e7e7e7; } .hentry table tr.alternate td, .comment-text table tr.alternate td { background: #f7f7f7; } blockquote { color: #777777; border-left: 5px solid #dddddd; margin: 15px 30px 0px 10px; padding-left: 20px; } blockquote p { } pre { padding: 10px; border: dashed 1px #cccccc; } #banner-bg { } #banner { position: relative; } #logo-area { margin-left: 20px; } @media only screen and (max-width: 959px) { #banner > div, #banner > nav { float: none; width: 100%; } } #main { padding: 30px 0; } #widgetarea-one { padding: 0 20px; } #content{ padding: 0 20px; } #footer-bg { background: #fcfcfc; padding: 30px 0; border-top: solid 1px #ddd; } #footer { text-align: center; color: #666666; } .hentry { position: relative; padding: 30px 0 25px 0; border-top: solid 1px #eee; } .hentry:first-child { border-top: none; } .hentry a { color: #0090d3; text-decoration: none; } .hentry > h1, .hentry > h2 { margin: 0; font-weight: normal; } .hentry > h2 { font-size: 40px; line-height: 38px; margin: 0 0 15px 0; } .hentry > h1 { color: #0090d3; font-size: 50px; line-height: 45px; margin: 0 0 20px 0; } .hentry h2 a .firstpart, .hentry h1 .firstpart { color: #000000; text-decoration: none; } .hentry:hover h2 a .firstpart { color: #0090d3; } .post-format { display: none; background: url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/icons.png) -120px -144px no-repeat; width: 24px; height: 24px; padding: 5px 13px; margin: 0 10px 0 0; vertical-align: 8px; font-size: 10px; } .hentry .comment-bubble { display: inline-block; height: 36px; width: 36px; color: #999; line-height: 27px; font-family: arial, sans-serif; font-size: 18px; font-weight: bold; text-align: center; background: url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/icons.png) -168px -108px no-repeat; margin-left: 8px; vertical-align: 8px; } .hentry:hover .comment-bubble { color: #fff; background: url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/icons.png) -168px -72px no-repeat; text-decoration: none; } .thumb-shadow { background: #fff url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/shadow.png) center 50px no-repeat; padding-bottom: 5px; margin-top: 7px; margin-left: -6px; } .hentry:hover .thumb-shadow { background-position: center bottom; } .post-thumb { margin: 0 auto 15px auto; display: block; padding: 6px 6px 5px 6px; border: solid 1px #ddd; border-bottom: solid 1px #ccc; background: #ffffff; } .post-thumb a { position: relative; display: block; } .post-thumb .img_wrapper{ } .post-thumb img { -webkit-filter: grayscale(0); opacity: 0; filter: alpha(opacity=0); -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=50)\"; display: block; } .post-thumb img.img_grayscale { filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter: url(\"http://www.happyhls.me/blog/wp-content/themes/montezuma/images/gray-filter.svg#grayscale\"); filter: gray; -webkit-filter: grayscale(1); -webkit-filter: grayscale(100%); } .post-thumb span { position: absolute; top: 0; bottom: 0; left: 0; right: 0; box-shadow: inset 15px 15px 20px -20px #000; z-index: 20000; } .post-bodycopy { } .post-bodycopy p { } p.post-pagination { clear: both; margin: 20px 0; } p.post-pagination ol { margin: 15px 0; } p.post-pagination a { } .post-edit-link { display: block; margin-top: 10px; } .post-date { border-right: solid 1px #999; float: left; text-align: center; margin-right: 10px; margin-top: 4px; margin-bottom: 8px; padding-right: 10px; } .post-day { font-size: 20px; line-height: 20px; margin: 4px auto 0px auto; } .post-month { font-size: 14px; line-height: 14px; margin: 0px auto; text-transform: uppercase; } .post-year { font-size: 11px; line-height: 14px; margin: 0px auto; } .post-footer { color: #bbbbbb; margin-top: 10px; } .post-footer a { color: #aaaaaa; padding: 2px 10px 4px 10px; border-radius: 3px; border: none; } .hentry:hover .post-footer a { color: #0090d3; } .hentry:hover .post-footer a:hover { text-decoration: none; color: #ffffff; background: #0090d3; } .post-tags, .post-categories { margin: 0; display: inline-block; } .post-tags { margin-left: 20px; } .post-tags i, .post-categories i { display: inline-block; width: 12px; height: 12px; margin-right: 5px; background-image: url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/icons.png); } .post-tags i { background-position: -168px -192px; } .post-categories i { background-position: -12px -228px; } .post-readmore { float: right; margin-top: -5px; } .gallery { margin: 20px 0 10px -7px; } .gallery figure { display: inline-block; padding: 7px; border: solid 1px #ccc; margin: 0 10px 5px 0; box-shadow: 0 0 10px -5px #ccc; } .gallery figure a { position: relative; display: block; border: 0; text-decoration: none; } .gallery figure a span { position: absolute; top: 0; bottom: 0; left: 0; right: 0; box-shadow: inset 15px 15px 20px -20px #000; z-index: 1000; } .ie8 .gallery figure a span { background: #fff; -ms-filter: \"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)\"; filter: alpha(opacity=0); } .ie8 .gallery figure { margin: 0 10px 10px 0; } .hentry .gallery figure a img { border: 0; padding: 0; } .gallery figcaption { } .image-attachment .post-bodycopy img { margin-left: -8px; } .image-attachment .singlenav { margin: 10px 0; } .image-attachment .singlenav .older a:before { content: '\\2039\\2039 \\00a0'; } .image-attachment .singlenav .newer a:after { content: '\\00a0 \\203a\\203a'; } #colorbox, #cboxOverlay, #cboxWrapper{position:absolute; top:0; left:0; z-index:9999; overflow:hidden;} #cboxOverlay{position:fixed; width:100%; height:100%;} #cboxMiddleLeft, #cboxBottomLeft{clear:left;} #cboxContent{position:relative;} #cboxLoadedContent{overflow:auto;} #cboxTitle{margin:0;} #cboxLoadingOverlay, #cboxLoadingGraphic{position:absolute; top:0; left:0; width:100%; height:100%;} #cboxPrevious, #cboxNext, #cboxClose, #cboxSlideshow{cursor:pointer;} .cboxPhoto{float:left; margin:auto; border:0; display:block; max-width:none;} .cboxIframe{width:100%; height:100%; display:block; border:0;} #colorbox, #cboxContent, #cboxLoadedContent{ -moz-box-sizing:content-box; -webkit-box-sizing:content-box; box-sizing:content-box; o-box-sizing:content-box; } #cboxOverlay{background:#fff;} #colorbox{} #cboxTopLeft{width:25px; height:25px; background:url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/colorbox/border1.png) no-repeat 0 0;} #cboxTopCenter{height:25px; background:url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/colorbox/border1.png) repeat-x 0 -50px;} #cboxTopRight{width:25px; height:25px; background:url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/colorbox/border1.png) no-repeat -25px 0;} #cboxBottomLeft{width:25px; height:25px; background:url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/colorbox/border1.png) no-repeat 0 -25px;} #cboxBottomCenter{height:25px; background:url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/colorbox/border1.png) repeat-x 0 -75px;} #cboxBottomRight{width:25px; height:25px; background:url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/colorbox/border1.png) no-repeat -25px -25px;} #cboxMiddleLeft{width:25px; background:url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/colorbox/border2.png) repeat-y 0 0;} #cboxMiddleRight{width:25px; background:url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/colorbox/border2.png) repeat-y -25px 0;} #cboxContent{background:#fff; overflow:hidden;} .cboxIframe{background:#fff;} #cboxError{padding:50px; border:1px solid #ccc;} #cboxLoadedContent{margin-bottom:20px;} #cboxTitle{position:absolute; bottom:0px; left:0; text-align:center; width:100%; color:#999;} #cboxCurrent{position:absolute; bottom:0px; left:100px; color:#999;} #cboxSlideshow{position:absolute; bottom:0px; right:42px; color:#444;} #cboxPrevious{position:absolute; bottom:0px; left:0; color:#444;} #cboxNext{position:absolute; bottom:0px; left:63px; color:#444;} #cboxLoadingOverlay{background:#fff url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/colorbox/loading.gif) no-repeat 5px 5px;} #cboxClose{position:absolute; bottom:0; right:0; display:block; color:#444;} .cboxIE #cboxTopLeft, .cboxIE #cboxTopCenter, .cboxIE #cboxTopRight, .cboxIE #cboxBottomLeft, .cboxIE #cboxBottomCenter, .cboxIE #cboxBottomRight, .cboxIE #cboxMiddleLeft, .cboxIE #cboxMiddleRight { filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#00FFFFFF,endColorstr=#00FFFFFF); } .widget { font-size: 14px; line-height: 1.3; color: #666666; margin-bottom: 30px; } .widget:hover { color: #000000; } .widget a { color: #000000; } .widget:hover a { color: #0090d3; } .widget > h3 { color: #0090d3; margin: 0 0 15px 0; font-size: 32px; line-height: 29px; } .widget:hover > h3 { color: #000000; } .widget > h3 > span { } .widget h3 span .firstpart { color: #000000; text-decoration: none; } .widget > h3 i { display: inline-block; width: 24px; height: 24px; margin-right: 15px; background-color: #ffffff; background-image: url( http://www.happyhls.me/blog/wp-content/themes/montezuma/images/icons.png ); } .widget > h3 i { background-position: -120px -216px } .widget_archive > h3 i { background-position: -120px -24px } .widget_tag_cloud > h3 i { background-position: -120px 0px } .widget_recent_comments > h3 i { background-position: -120px -72px } .widget_links > h3 i { background-position: -120px -96px } .widget_pages > h3 i { background-position: -120px -120px } .widget_recent_entries > h3 i { background-position: -120px -144px } .widget_meta > h3 i { background-position: -120px -192px } .widget_categories > h3 i { background-position: -120px -168px } .widget:hover > h3 i { background-position: -96px -216px } .widget_archive:hover > h3 i { background-position: -96px -24px } .widget_tag_cloud:hover > h3 i { background-position: -96px 0px } .widget_recent_comments:hover > h3 i { background-position: -96px -72px } .widget_links:hover > h3 i { background-position: -96px -96px } .widget_pages:hover > h3 i { background-position: -96px -120px } .widget_recent_entries:hover > h3 i { background-position: -96px -144px } .widget_meta:hover > h3 i { background-position: -96px -192px } .widget_categories:hover > h3 i { background-position: -96px -168px } .widget ul { list-style: none; margin-top: 0px; margin-bottom: 0px; margin-left: 0px; padding-left: 0; } .widget > ul { border-top: solid 1px #eeeeee } .widget ul ul { padding-left: 0px; margin-left: 0px; } .widget > ul > li { margin: 0; padding: 7px 0 8px 0; border-bottom: solid 1px #eeeeee; } .widget > ul > li:before { content: '\\203a \\00a0\\00a0'; margin-left: -10px; } .widget > ul > li { padding-left: 10px; } .widget li:hover { background: #f7f7f7 } .widget_categories > ul > li, .widget_archive li, .widget_meta li { float: left; width: 50%; } @media only screen and (max-width: 959px) { .widget_categories > ul > li, .widget_archive li, .widget_meta li { float: none; width: auto; } } .tagcloud a { font-size: 13px; padding: 2px 6px 4px 6px; border-radius: 2px; white-space: nowrap; margin: 0 3px 6px 0; color: #333333; border: solid 1px #ddd; background: #fcfcfc; display: inline-block; } .tagcloud a:hover { color: #ffffff !important; border: solid 1px #0090d3; background: #0090d3; text-decoration: none; } .tagcloud a.tagsize-1 { } .tagcloud a.tagsize-2 { } .tagcloud a.tagsize-3 { } .tagcloud a.tagsize-4 { } .tagcloud a.tagsize-5 { } .tagcloud a.tagsize-6 { } #calendar_wrap { } #wp-calendar { border-collapse: separate; line-height: 20px; width: 100%; text-align: center; } #wp-calendar caption { letter-spacing: 3px; border-bottom: 0; line-height: 25px; font-size: 15px; text-transform: uppercase; } #wp-calendar thead { } #wp-calendar thead tr { } #wp-calendar thead th { border: solid 1px #ddd; font-weight: normal; } #wp-calendar tbody { } #wp-calendar tbody tr { } #wp-calendar tbody td { border: solid 1px #ddd; color: #999; padding: 0; border-radius: 3px; } #wp-calendar tbody .pad { border: none; } #wp-calendar tbody a { background: #eee; display: block; } #wp-calendar tbody a:hover { } #wp-calendar tfoot { } #wp-calendar tfoot tr { } #wp-calendar tfoot td { } #wp-calendar tfoot .pad { } #wp-calendar tfoot a { } #wp-calendar tfoot a:hover { } #prev { } #next { } .menu-wrapper { position: relative; } .menu { list-style-type: none; line-height: 33px; margin: 0; padding: 0; } .menu ul { float: left; height: auto; left: -999em; position: absolute; } .menu ul ul { margin-top: -33px; margin-left: 150px; } .menu li { float: left; padding: 0; margin: 0; width: auto; display: block; } .menu ul li { float: none; width: 100%; } .menu a, #menu1-smooth a, #menu2-smooth a { display: block; padding: 0 8px; text-decoration: none; white-space: nowrap; width: auto; } .menu ul a, #menu1-smooth a, #menu2-smooth a { width: 150px; white-space: normal; } .menu li:hover ul ul , .menu li:hover ul ul ul, .menu li:hover ul ul ul ul, .menu li:hover ul ul ul ul ul, .menu li:hover ul ul ul ul ul ul, .menu li:hover ul ul ul ul ul ul ul { left: -999em; } .menu li:hover ul, .menu li li:hover ul, .menu li li li:hover ul, .menu li li li li:hover ul , .menu li li li li li:hover ul, .menu li li li li li li:hover ul, .menu li li li li li li li:hover ul, .menu li li li li li li li li:hover ul { left: auto; z-index: 100000; } #menu1-wrapper { z-index: 1000; background: #ffffff; position: absolute; bottom: 0; right: 0; border-bottom: solid 1px #cccccc; margin-bottom: -1px; } @media only screen and (max-width: 959px) { #menu1-wrapper { position: relative; } } #menu1, #menu1-smooth { display: table; margin: 0 auto; } #menu1 > li { background: transparent url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/menuline.png) 0 center no-repeat; box-shadow: 2px 4px 20px -18px #000; } #menu1 > li:first-child { background: none; } #menu1 > li > a > i { display: block; width: 24px; height: 24px; margin: 0 auto 5px auto; background: transparent url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/menu-icons-0090d3.png) 0 0 no-repeat; } #menu1 > li:hover > a > i { background: transparent url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/menu-icons-0090d3.png) -24px 0 no-repeat; } #menu1 .page-blog > a > i { background-position: 0px 0px ; } #menu1 .page-contact-us > a > i { background-position: 0px -24px; } #menu1 .page-features > a > i { background-position: 0px -48px ; } #menu1 .page-level-1 > a > i { background-position: 0px -72px; } #menu1 .page-news > a > i { background-position: 0px -96px } #menu1 .page-parent-page > a > i { background-position: 0px -120px; } #menu1 .page-support > a > i { background-position: 0px -144px; } #menu1 .page-wordpress-themes > a > i { background-position: 0px -168px; } #menu1 .page-blog:hover > a > i { background-position: -24px 0px ; } #menu1 .page-contact-us:hover > a > i { background-position: -24px -24px; } #menu1 .page-features:hover > a > i { background-position: -24px -48px ; } #menu1 .page-level-1:hover > a > i { background-position: -24px -72px; } #menu1 .page-news:hover > a > i { background-position: -24px -96px } #menu1 .page-parent-page:hover > a > i { background-position: -24px -120px; } #menu1 .page-support:hover > a > i { background-position: -24px -144px; } #menu1 .page-wordpress-themes:hover > a > i { background-position: -24px -168px; } #menu1 a, #menu1-smooth a { font-family: 'Yanone Kaffeesatz', sans-serif; font-size: 22px; font-weight: 300; color: #000; padding: 12px 15px 20px 15px; line-height: 22px; } #menu1 ul a, #menu1-smooth a { font-size: 18px; } #menu1 > li > a span.firstpart { color: #ccc; } #menu1 a:hover, #menu1-smooth a:hover, #menu1 .active a, #menu1-smooth .active a { color: #0090d3; } #menu1 > li { border-top: solid 5px transparent; } #menu1 > li:hover, #menu1 > li.active , #menu1 > li.ancestor { border-top: solid 5px #0090d3; } #menu1 .sub-menu, #menu1-smooth .sub-menu { list-style: none; background: #ffffff; background: hsla(36, 100%, 100%, 0.95); border: solid 1px #ddd; font-size: 18px; padding: 5px 15px; box-shadow: 5px 5px 20px -15px #000; } #menu1 .sub-menu a, #menu1-smooth .sub-menu a { padding: 5px 0; } #menu1 > ul > li > ul { margin-left: -20px; } #menu1 .sub-menu li, #menu1-smooth .sub-menu li { border-top: solid 1px #eee; } #menu1 .sub-menu li:first-child, #menu1-smooth .sub-menu li:first-child { border-top: none; } #menu1 .sub-menu .sub-menu, #menu1-smooth .sub-menu .sub-menu li:first-child { margin-top: -38px; } .menu1-mobile { display: none; font-size: 20px; padding: 10px; margin: 20px auto 30px auto; width: 90%; } @media only screen and (max-width: 959px) { .hentry .post-thumb img { opacity: 1 !important; z-index: 1000; } } @media only screen and (max-width: 767px) { ul#menu1, a.rsslink, img.avatar, .post-categories i { display: none; } .menu1-mobile { display: block; } .commentlist li > div { margin-left: 0 !important; } .post-footer a { padding: 7px 15px; } a.post-readmore { background: #f7f7f7; border: solid 1px #eee; color: #0090d3; } .hentry div.thumb-shadow { background-image: none !important; padding-bottom: 0; margin-left: 0; } div.post-thumb { border: none; padding: 0 !important; background: none; } .hentry .post-thumb span { display: none; } body { font-size: 15px; } .widget .searchform .field { max-width: 100% !important; padding: 10px; } #content { padding: 0 20px 20px 20px; } } #menu2-bg { background: #fcfcfc; border-bottom: solid 1px #dddddd; margin-bottom: 10px; } #menu2 > li > a { padding: 2px 8px; } #menu2 a { color: #333333; } #menu2 a:hover, #menu2 .active a, #menu2 .active a { color: #0090d3; } #menu2 ul { background: hsla(36, 100%, 100%, 0.95); border: solid 1px #dddddd; padding: 5px 10px; box-shadow: 5px 5px 20px -15px #000000; } #menu2 ul a { padding: 0; } #menu2 ul li { border-top: solid 1px #eeeeee; } #menu2 ul li:first-child { border-top: none; } #menu2 ul ul { margin-top: -39px; } .singlenav { margin-bottom: 10px; } .singlenav .older { float: left; } .singlenav .newer { float: right; } #singlenav2 { border-top: 3px solid #ededed; border-bottom: 0px none #f5f5f5; margin-top: 18px; padding-top: 13px; } .multinav { margin: 20px 0; padding-left: 20px; } .multinav a, .multinav span { padding: 3px 12px; border: solid 1px #ddd; text-decoration: none; display: inline-block; background: #fcfcfc; } .multinav a:hover { background: #0090d3; border: solid 1px #0090d3; color: #ffffff; } .multinav .current { background: #ffffff; } #multinav1 { border-bottom: solid 1px #dddddd; margin-bottom: 0; } #multinav1 a, #multinav1 span { margin-bottom: -1px; border-top-right-radius: 5px; border-top-left-radius: 5px; } #multinav1 .current { border-bottom: solid 1px #ffffff; } #multinav2 { border-top: solid 1px #dddddd; } #multinav2 a, #multinav2 span { margin-top: -1px; border-bottom-right-radius: 5px; border-bottom-left-radius: 5px; } #multinav2 .current { border-top: solid 1px #ffffff; } .breadcrumbs { color: #666666; font-size: 13px; } .breadcrumbs ol { list-style: none; padding: 0; margin: 0; } .breadcrumbs ol li { float: left; line-height: 32px; } .breadcrumbs ol li a { color: #333333; margin-left: 10px; } .breadcrumbs ol li a:hover { color: #0090d3; margin-left: 10px; } .breadcrumbs .bc-current, .breadcrumbs .bc-pagenumber { margin-left: 10px; } .breadcrumbs ol li.bc-home a { display: block; width: 12px; height: 12px; background: transparent url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/icons.png) -36px -108px no-repeat; margin: 8px 15px 0 5px; } .breadcrumbs ol li.bc-home a:hover { background: transparent url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/icons.png) -48px -108px no-repeat; text-decoration: none; } .breadcrumbs ol li i { margin: 0 0 0 5px; display: block; float: right; width: 17px; height: 32px; background: transparent url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/breadcr-arr.png) center left no-repeat; } #breadcrumbs1 { padding: 5px 0 5px 30px; } #breadcrumbs1-bg { border-top: solid 1px #cccccc; border-bottom: solid 1px #cccccc; background: #f7f7f7; position: relative; } #comments { padding-top: 20px; border-top: solid 1px #dddddd; } #comments-title { color: #999999; margin: 0 0 20px 0; font-size: 28px; } #comments-title span { color: #000000; } .commentlist { background: #ffffff; padding: 0; list-style: none; margin: 20px 0; } .commentlist ul { list-style: none; } .commentlist li { padding: 0px; } .commentlist li > div { border: solid 1px #dddddd; background: #fcfcfc; padding: 20px 20px 3px 20px; position: relative; margin-bottom: 20px; margin-left: 85px; border-radius: 5px; } .commentlist .pingback { margin-bottom: 20px; } .commentlist li > div:hover { background: #ffffff; } .commentlist li > div:before { content: url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/commentarrow.png); left: -17px; top: 25px; position: absolute; z-index: 1000000; } .commentlist li > div:hover:before { content: url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/commentarrow-white.png); } .commentlist .avatar { position: absolute; top: 3px; left: -80px; border-radius: 50%; box-shadow: 0 0 0 3px #cccccc; } .commentlist li li .avatar { left: -70px; } .comment-reply-link { position: absolute; top: 60px; left: -80px; font-size: 13px; width: 50px; text-align: center; color: #cccccc; } li li .comment-reply-link { top: 45px; left: -70px; } .commentlist li > div:hover > .comment-reply-link { color: #0090d3; } .comment-author { font-weight: bold; font-size: 16px; } .comment-date-link { position: absolute; top: 5px; right: 10px; font-size: 11px; line-height: 13px; text-align: right; } .comment-date-link a { color: #aaaaaa; } .commentlist li > div:hover .comment-date-link a { color: #0090d3; } .comment-edit-link { } .comment-delete-link { } .comment-spam-link { } .comment-text { } .comment-pagination { padding-left: 20px; margin-top: 10px; } .comment-pagination a, .comment-pagination .current { border: solid 1px #dddddd; padding: 3px 12px; display: inline-block; text-decoration: none; } .comment-pagination a { background: #fcfcfc; } .comment-pagination a:hover { background: #0090d3; border: solid 1px #0090d3; color: #ffffff; } #comment-pagination-1 { border-bottom: solid 1px #dddddd; } #comment-pagination-1 a, #comment-pagination-1 .current { border-top-right-radius: 5px; border-top-left-radius: 5px; margin-bottom: -1px; } #comment-pagination-1 .current { border-bottom: solid 1px #ffffff; } #comment-pagination-2 { border-top: solid 1px #dddddd; } #comment-pagination-2 a, #comment-pagination-2 .current { border-bottom-right-radius: 5px; border-bottom-left-radius: 5px; margin-top: -1px; } #comment-pagination-2 .current { border-top: solid 1px #ffffff; } #respond { margin: 30px 0 20px 0; padding-bottom: 40px; border-bottom: solid 1px #eee; } #reply-title { margin: 0 0 10px 0; } #commentform { } .quicktags-toolbar { margin-bottom: 10px; } .ed_button { color: #333333; background: #eeeeee; border: solid 1px #dddddd; margin-right: 5px; padding: 3px 8px; border-radius: 3px; } .ed_button:hover { color: #ffffff; background: #0090d3; border: solid 1px #0090d3; cursor: pointer; } #comment-form { width: 100%; } #comment-author { } #comment-url { } #comment-email { } .logged-in-as { } #comment { } .form-submit { } #submit { display: inline-block; outline: none; cursor: pointer; text-align: center; text-decoration: none; font-size: 14px; padding: 5px 10px; border-radius: 5px; color: #333333; border: solid 1px #dddddd; background: #eeeeee; } #submit:hover { color: #ffffff; border: solid 1px #0090d3; background: #0090d3; } .button:hover { text-decoration: none; } .button:active { position: relative; top: 1px; } #sitetitle { font-family: 'Yanone Kaffeesatz', sans-serif; font-size: 70px; font-weight: normal; margin: 25px auto 10px auto; line-height: 55px; } @media only screen and (max-width: 959px) { #sitetitle { display: table; } } #sitetitle a .firstpart { color: #000000; } #sitetitle a:hover { text-decoration: none; } #tagline { font-family: 'Yanone Kaffeesatz', sans-serif; font-weight: 200; font-size: 26px; letter-spacing: 0px; color: #4f4f4f; margin: 0 auto 20px auto; } @media only screen and (max-width: 959px) { #tagline { display: table; } } a.rsslink { position: absolute; top: 60px; right: 30px; width: 24px; height: 24px; display: block; background-image: url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/icons.png); background-position: -120px -48px; } #banner:hover a.rsslink { background-position: -96px -48px; } a.rsscommentslink { float: right; margin-top: 5px; margin-right: 8px; } .searchform .field { padding: 5px; width: 200px; border: solid 1px #dddddd; } .searchform .submit { width: 28px; height: 28px; background: url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/searchicon.png) 0 -5px no-repeat; overflow: hidden; border: none; margin-left: 3px; } #post-0 .searchform { position: relative; margin: 30px 0; width: 90%; } #post-0 .searchform .field { width: 95%; max-width: 100%; } .widget .searchform { position: relative; top: 0; left: 0; } .widget .submit { display: none; } .widget .searchform .field { width: 100%; max-width: 300px; background: url(http://www.happyhls.me/blog/wp-content/themes/montezuma/images/searchicon.png) right center no-repeat; } .page-title { color: #999999; font-size: 24px; margin: 10px 0; } .page-title span { color: #000000; } .credit-link { font-size: 13px; color: #aaaaaa; margin-top: 30px; margin-bottom: 0; } .credit-link a { color: #aaaaaa; font-weight: bold; text-decoration: none; } .sub-menu:before, .sub-menu:after, .cf:before, .cf:after, .row:before, .row:after, .row20:before, .row20:after, .row:before, .row:after, .row:before, .row:after, .row:before, .row:after, .lw:before, .lw:after { content: \".\"; display: block; height: 0; clear: both; visibility: hidden; } .sub-menu:after, .cf:after, .row:after, .row20:after, .lw:after { clear: both; } .sub-menu, .cf, .row, .row20, .lw { min-width: 0; display: inline-block; display: block; } * html .sub-menu, * html .cf, * html .row, * html .row20, * html .lw { height: 1%; }"},{"title":"","date":"2018-10-03T16:06:15.669Z","updated":"2015-05-20T03:17:18.000Z","comments":true,"path":"images/wordpress/redux/notice/notice.json","permalink":"http://yoursite.com/images/wordpress/redux/notice/notice.json","excerpt":"","text":"{\"type\":\"redux-message\",\"title\":\"Redux Framework: Complete Customizer Integration\",\"message\":\"Attention Devs! We need your support to complete Redux customizer integration before the end of the year. Read all about it!\",\"color\":\"rgba(0,162,227,1)\"}"},{"title":"","date":"2018-10-04T17:03:07.745Z","updated":"2018-10-04T17:03:07.745Z","comments":true,"path":"googlee212df586631527c.html","permalink":"http://yoursite.com/googlee212df586631527c.html","excerpt":"","text":"google-site-verification: googlee212df586631527c.html"}],"posts":[{"title":"Fresco源代码分析之二：SimpleDraweeView如何拉取图片并绘制在屏幕上？","slug":"android-fresco-source-code-2-simpledraweeview","date":"2015-12-27T15:59:56.000Z","updated":"2018-10-03T15:07:12.463Z","comments":true,"path":"2015/12/27/android-fresco-source-code-2-simpledraweeview/","link":"","permalink":"http://yoursite.com/2015/12/27/android-fresco-source-code-2-simpledraweeview/","excerpt":"","text":"Fresco源代码分析之二：SimpleDraweeView如何拉取图片并绘制在屏幕上？ 引言在《Fresco源代码分析之1：Fresco的初始化 》文章中，仔细分析了Fresco.init(Context)方法中所做的工作。总结下来有一下几点： 初始化了 ImagePipelineFactory ， 包括默认的ImagePipelineConfig（其中初始化了各种线程池、是否解码、旋转之类的设置、各种Cache的默认配置等等）。 初始化了默认的 SimpleDraweeView ，包括对应的ImagePipeline。 那么问题来了，当我们通过SimpleDraweeView的 setImageUri(Uri, Object) 方法调用的时候，Fresco到底做了哪些工作呢？图片是经过了哪些工作绘制在界面上的呢？这篇文章就来说说这些事情。 调用方法12345678910111213 \\* Displays an image given by the uri. \\* \\* @param uri uri of the image \\* @param callerContext caller context */public void setImageURI(Uri uri, @Nullable Object callerContext) &#123; DraweeController controller = mSimpleDraweeControllerBuilder .setCallerContext(callerContext) .setUri(uri) .setOldController(getController()) .build(); setController(controller);&#125; 在想象中，图片库要将图片显示出来，至少要经过查询缓存、网络获取、图片的解码、写入缓存、图片的后处理、显示图片这几个过程。但查看Fresco的代码，发现仅仅这几行，两句话就完事了，那么这两句话后面，到底有哪些故事发生呢？ 源代码分析从上述代码出发，分析图片加载的全过程。 获取DraweeController代码的第一行，典型的是一个获取DraweeController的方法，具体的工作是怎么样的呢？ DraweeController controller = mSimpleDraweeControllerBuilder .setCallerContext(callerContext) .setUri(uri) .setOldController(getController()) .build(); 其中mSimpleDraweeControllerBuilder是一个SimpleDraweeControllerBuilder的接口，该方法以此调用了四个方法，分别设置了 调用者的上下文、 Uri、 旧的Controller。从接口上看不出来Fresco具体做了什么工组的，因此还是要看看具体的实现。 在Fresco的初始化代码中，是这样初始化的 // 初始化Drawee private static void initializeDrawee(Context context) { sDraweeControllerBuilderSupplier = new PipelineDraweeControllerBuilderSupplier(context); SimpleDraweeView.initialize(sDraweeControllerBuilderSupplier); } 因此可以看出来，SimpleDraweeView所对应的Controller实际上是源自PipelineDraweeControllerBuilder，进一步查看，可以发现继承关系如下： SimpleDraweeControllerBuilder | | AbstractDraweeControllerBuilder | | PipelineDraweeControllerBuilder 既然在SimpleDraweeView.setUri()方法中只调用了setCallerContext\\setUri\\setOldController，那么我们就从这四个方法入手 setCallerContext(Object callerContext)这个方法源自 AbstractDraweeControllerBuilder /** Sets the caller context. */ @Override public BUILDER setCallerContext(Object callerContext) { mCallerContext = callerContext; return getThis(); } 和字面意思一样，该方法就是简单的设置了上下文，而且需要注意的是，上下文的类型为Object。 setUri(Uri uri)该方法首先调用 PipelineDraweeControllerBuilder 的对应的方法 @Override public PipelineDraweeControllerBuilder setUri(Uri uri) { return super.setImageRequest(ImageRequest.fromUri(uri)); } 其实本质上还是调用父类的这个方法，但需要注意的是，在这里面使用ImageRequest.fromUri(Uri)又将方法包装了一下，将Uri包装为ImageRequest的类型。ImageRequest的类的注释如下： Immutable object encapsulating everything pipeline has to know about requested image to proceed. 可以直接看出，在Fresco中，ImageRequest为一个不可变类，其中包含了一个请求所需要的全部信息。 而调用至 AbstractDraweeControllerBuilder 中对应的方法也很简单，就是设置了一下对应的成员变量 /** Sets the image request. */ public BUILDER setImageRequest(REQUEST imageRequest) { mImageRequest = imageRequest; return getThis(); } setOldController(DraweeController)此处也是调用的 AbstractDraweeControllerBuilder中的方法，具体代码如下： /** Sets the old controller to be reused if possible. */ @Override public BUILDER setOldController(@Nullable DraweeController oldController) { mOldController = oldController; return getThis(); } 工作也很简单，就是同样是设置了成员变量，那么这样看来，所有的工作应该都是放在了build()方法里面，现在去看看。 build()build方法也是直接调用的 AbstractDraweeControllerBuilder中的方法， /** Builds the specified controller. */ @Override public AbstractDraweeController build() { validate(); // if only a low-res request is specified, treat it as a final request. if (mImageRequest == null &amp;&amp; mMultiImageRequests == null &amp;&amp; mLowResImageRequest != null) { mImageRequest = mLowResImageRequest; mLowResImageRequest = null; } return buildController(); } 这里面有一个判断 仅仅在ImageRequest以及MultiImageRequest都为空，且LowResImagaeRequest(低质量请求)存在的时候，才将这个低质量的请求作为最终的请求来处理。 那 buildController() 方法做了什么呢？代码如下： /** Builds a regular controller. */ protected AbstractDraweeController buildController() { AbstractDraweeController controller = obtainController(); controller.setRetainImageOnFailure(getRetainImageOnFailure()); maybeBuildAndSetRetryManager(controller); maybeAttachListeners(controller); return controller; } 可以看出来，分了4个步骤： 获取对应的Controller 配置Controller是否显示失败重新获取的图片 设置重试管理器（RetryManager） 设置Attach事件监听者 要想搞明白了，还是一件一件事情依次看看做了什么。 AbstractDraweeController controller = obtainController(); AbstractDraweeControllerBuilder中并没有obtainController()的默认实现，并要求子类实现，在PipelineDraweeControllerBuilder中，其实现如下： /** * 该方法会尝试复用以前的Controller, * 复用的办法是: * 1\\首先判断Controller的类型,如果是PipelineDraweeController,则初始化即可 * 2\\如果不是如果是PipelineDraweeController的类型,则新建一个. * @return */ @Override protected PipelineDraweeController obtainController() { DraweeController oldController = getOldController(); PipelineDraweeController controller; if (oldController instanceof PipelineDraweeController) { controller = (PipelineDraweeController) oldController; controller.initialize( obtainDataSourceSupplier(), generateUniqueControllerId(), getCallerContext()); } else { controller = mPipelineDraweeControllerFactory.newController( obtainDataSourceSupplier(), generateUniqueControllerId(), getCallerContext()); } return controller; } 其实代码也很简单，就是检查之前通过setOldController设置的Controller是否为自身的类型，如果是，则通过设置重新使用，如果不是，则通过对应的工厂方法重新建立一个。 当然，我们不能看到这边就可以了，既然Controller可以复用，我们就看看重用Controller的初始化代码中都做了什么工作？ /** * 通过新配置的Id和调用者上下文,重新初始化AbstractDraweeController * 这种设计允许在不需要重新实例化controller的时候复用之前的Controller. * * Initializes this controller with the new id and caller context. * This allows for reusing of the existing controller instead of instantiating a new one. * This method should be called when the controller is in detached state. * @param id unique id for this controller * @param callerContext tag and context for this controller */ protected void initialize(String id, Object callerContext) { init(id, callerContext); } private void init(String id, Object callerContext) { // 记录事件:开始初始化Controller mEventTracker.recordEvent(Event.ON_INIT_CONTROLLER); // 如果之前有DeferredReleaser,则释放 // cancel deferred release if (mDeferredReleaser != null) { mDeferredReleaser.cancelDeferredRelease(this); } // 重新初始化各种状态 // reinitialize mutable state (fetch state) mIsAttached = false; releaseFetch(); mRetainImageOnFailure = false; // 重新初始化RetryManager // reinitialize optional components if (mRetryManager != null) { mRetryManager.init(); } // 重新初始化GestureDetector if (mGestureDetector != null) { mGestureDetector.init(); mGestureDetector.setClickListener(this); } // 清空ControllerListener if (mControllerListener instanceof InternalForwardingListener) { ((InternalForwardingListener) mControllerListener).clearListeners(); } else { mControllerListener = null; } // 清空Drawee视图 // clear hierarchy and controller overlay if (mSettableDraweeHierarchy != null) { mSettableDraweeHierarchy.reset(); mSettableDraweeHierarchy.setControllerOverlay(null); mSettableDraweeHierarchy = null; } mControllerOverlay = null; // reinitialize constant state if (FLog.isLoggable(FLog.VERBOSE)) { FLog.v(TAG, &quot;controller %x %s -&gt; %s: initialize&quot;, System.identityHashCode(this), mId, id); } mId = id; mCallerContext = callerContext; } 上面的代码就是Controller初始化或者说重新初始化过程，所调用的代码，具体都有哪些工作呢？依次来看： 记录事件：初始化Controller 如果之前调用了DeferredReleaser，则取消。 设置变量 mISAttached = false; 释放之前的网络获取。 重新配置RetryManager. 重新设置触摸事件检测 配置MControllerListener，若为内置转发Listener，则保留，反之清空。 清空对应的Drawee视图。 设置Id和上下文。 setController(DraweeController)setController(DraweeController)的代码如下： /** Sets the controller. */ public void setController(@Nullable DraweeController draweeController) { mDraweeHolder.setController(draweeController); super.setImageDrawable(mDraweeHolder.getTopLevelDrawable()); } 这一块代码也很简单，两句话： 为mDraweeHoler设置了Controller 调用了ImageView的setImageDrawable(Drawable)方法，设置了一张图片。 其实第2步代码的作用非常容易理解：就是在网络数据拉取成功之前，先设置一张默认的图片，这样在交互的时候，界面更加友好。 那么这样看来，网络请求发出等工作都是在第1步代码当中了。 /** * 配置新的Controller * Sets a new controller. */ public void setController(@Nullable DraweeController draweeController) { // 首先判断该DraweeHolder是否已经与某个Controller绑定.（按照Controller方法的调用行为,此处更应该表述的是,该图像已经需要Controller加载过） boolean wasAttached = mIsControllerAttached; // 如果之前绑定过,则首先解除绑定. if (wasAttached) { detachController(); } // Clear the old controller, 重置之前的Controller if (mController != null) { mEventTracker.recordEvent(Event.ON_CLEAR_OLD_CONTROLLER); mController.setHierarchy(null); } // 将新的Controller赋值给成员变量. mController = draweeController; // 记录事件,配置视图 if (mController != null) { mEventTracker.recordEvent(Event.ON_SET_CONTROLLER); mController.setHierarchy(mHierarchy); } else { mEventTracker.recordEvent(Event.ON_CLEAR_CONTROLLER); } // 如果之前的Controller曾经绑定,则进一步调用attachController if (wasAttached) { attachController(); } } setController 方法着实也非常简单，可以看出其实主要就是几个工作： 首先检查该DraweeHolder是否之前绑定过Controller，如果有，则调用detachController()方法释放之前的Controller。 清空之前的Controller，并将新的controller对象赋给mController。 记录事件，为新的controller配置视图。 如果该DraweeHolder之前绑定过Controller，则调用attachController()方法直接拉起下一步进程。 需要注意的是，我们在代码分析中可以发现，其实我们在setController的时候，Fresco并不一定会直接发出网络请求，那么Fresco是什么时候进行的呢？分为两种情况： 如果DraweeHoler之前有通过Controller加载过图片，则直接通过新的controller重新加载。 如果没有，则等待时机执行。那什么时候呢？接着分析一下。 图片的加载其实很简单，Controller中有个方法叫onAttach()，这个名字是不是很熟悉？没错，和View的onAttach()方法签名一样，同样的，则个方法也是监听DraweeHolder的onAttach()回调函数，来看看。 ViewHolder /** * Gets the controller ready to display the image. * * &lt;p&gt;The containing view must call this method from both {@link View#onFinishTemporaryDetach()} * and {@link View#onAttachedToWindow()}. */ public void onAttach() { mEventTracker.recordEvent(Event.ON_HOLDER_ATTACH); mIsHolderAttached = true; attachOrDetachController(); } 代码很简单，就是记录事件，然后设置变量，然后调用下面一个方法，接着看。 private void attachOrDetachController() { if (mIsHolderAttached &amp;&amp; mIsVisible &amp;&amp; mIsActivityStarted) { attachController(); } else { detachController(); } } 这个也不用多说，就是检查DraweeHolder是否已经已经在屏幕上了，是否是显示的，Activity是否已经启动，如果是，则直接attachController()。 AbastarctDraweeController 接下来就看看Controller的onAttach()方法了 @Override public void onAttach() { if (FLog.isLoggable(FLog.VERBOSE)) { FLog.v( TAG, &quot;controller %x %s: onAttach: %s&quot;, System.identityHashCode(this), mId, mIsRequestSubmitted ? &quot;request already submitted&quot; : &quot;request needs submit&quot;); } // 记录事件 mEventTracker.recordEvent(Event.ON_ATTACH_CONTROLLER); // 检查mSettingableDraweeHierarchy是否为null Preconditions.checkNotNull(mSettableDraweeHierarchy); // 释放DeferredReleaser mDeferredReleaser.cancelDeferredRelease(this); // 设置mISAttached mIsAttached = true; // 如果任务没有提交,则提交 if (!mIsRequestSubmitted) { submitRequest(); } } 代码也很简单，无需多说，任务就是在这里被提交的。 // 提交请求 protected void submitRequest() { // 记录事件 mEventTracker.recordEvent(Event.ON_DATASOURCE_SUBMIT); // 向Controller Listener 提交对应事件 getControllerListener().onSubmit(mId, mCallerContext); // 设置进度,设置不显示进度 mSettableDraweeHierarchy.setProgress(0, true); // 设置相关变量 mIsRequestSubmitted = true; mHasFetchFailed = false; mDataSource = getDataSource(); if (FLog.isLoggable(FLog.VERBOSE)) { FLog.v( TAG, &quot;controller %x %s: submitRequest: dataSource: %x&quot;, System.identityHashCode(this), mId, System.identityHashCode(mDataSource)); } final String id = mId; final boolean wasImmediate = mDataSource.hasResult(); // 添加DataSubscriber final DataSubscriber&lt;T&gt; dataSubscriber = new BaseDataSubscriber&lt;T&gt;() { @Override public void onNewResultImpl(DataSource&lt;T&gt; dataSource) { // isFinished must be obtained before image, otherwise we might set intermediate result // as final image. boolean isFinished = dataSource.isFinished(); float progress = dataSource.getProgress(); T image = dataSource.getResult(); if (image != null) { onNewResultInternal(id, dataSource, image, progress, isFinished, wasImmediate); } else if (isFinished) { onFailureInternal(id, dataSource, new NullPointerException(), /* isFinished */ true); } } @Override public void onFailureImpl(DataSource&lt;T&gt; dataSource) { onFailureInternal(id, dataSource, dataSource.getFailureCause(), /* isFinished */ true); } @Override public void onProgressUpdate(DataSource&lt;T&gt; dataSource) { boolean isFinished = dataSource.isFinished(); float progress = dataSource.getProgress(); onProgressUpdateInternal(id, dataSource, progress, isFinished); } }; mDataSource.subscribe(dataSubscriber, mUiThreadImmediateExecutor); } 提交请求的代码我也加了注释，但这个地方涉及到整个数据流的分析，后面接着讲，暂时就看到这里。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Fresco","slug":"Android/Fresco","permalink":"http://yoursite.com/categories/Android/Fresco/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Fresco","slug":"Fresco","permalink":"http://yoursite.com/tags/Fresco/"}]},{"title":"Fresco源代码分析：1、Fresco的初始化","slug":"android-fresco-source-code-1-initialization","date":"2015-12-24T12:59:38.000Z","updated":"2018-10-03T15:07:40.236Z","comments":true,"path":"2015/12/24/android-fresco-source-code-1-initialization/","link":"","permalink":"http://yoursite.com/2015/12/24/android-fresco-source-code-1-initialization/","excerpt":"","text":"Fresco源代码分析 之一 默认初始化Fresco被认为是现在最为好用的Android图片加载库，在之前的文章，有根据官方文档分析过Fresco的入门手册，但使用始终无法明白其具体是怎么样工作的，因为，我们还是要从源码上分析Fresco的工作原理。 Fresco的初始化在一般情况下，我们是使用默认的ImagePipeline配置来初始化Fresco的，代码如下： Fresco.initialize(this); 而实际上，Fresco一共提供了两个初始化方法 /** Initializes Fresco with the default config. */ public static void initialize(Context context) { // 初始化了ImagePipelineFactory的默认配置 ImagePipelineFactory.initialize(context); initializeDrawee(context); } /** Initializes Fresco with the specified config. */ public static void initialize(Context context, ImagePipelineConfig imagePipelineConfig) { ImagePipelineFactory.initialize(imagePipelineConfig); initializeDrawee(context); } 可以看到，这两个初始化方法仅仅是初始化ImagePipeline的不同，接下来依次分析。 初始化ImagePipelineFactory同样的，ImagePipelineFactory总共提供了两个初始化方法，代码分别如下： /** Initializes {@link ImagePipelineFactory} with default config. */ public static void initialize(Context context) { initialize(ImagePipelineConfig.newBuilder(context).build()); } /** Initializes {@link ImagePipelineFactory} with the specified config. */ public static void initialize(ImagePipelineConfig imagePipelineConfig) { sInstance = new ImagePipelineFactory(imagePipelineConfig); } 其中可以看到initialize(Context context)本质上也是调用initialize(ImagePipelineConfig)的方法，因此实际上也就是设置的ImagePipelineConfig的不同，而实际上，这个参数也是从Fresco的初始化Fresco.initialize(Context, ImagePipelineFactory)传入的。因此，我们从分析ImagePipelineConfig.newBuilder(context).build()开始。 ImagePipelineConfig初始化ImagePipelineConfig.newBuilder(context)其实是构造了ImagePipelineConfig#Builder对象，build()方法则反悔了ImagePipelineConfig对象，其中设置的属性都有如下： @Nullable private final AnimatedImageFactory mAnimatedImageFactory; // 动画工厂 private final Bitmap.Config mBitmapConfig; // Bitmap配置 private final Supplier&lt;MemoryCacheParams&gt; mBitmapMemoryCacheParamsSupplier; // 缓存Bitmap所对应的MemoryCacheParams的供应者 private final CacheKeyFactory mCacheKeyFactory; // CacheKey工厂 private final Context mContext; // Context上下文 private final boolean mDownsampleEnabled; // 是否运行下载缩略图 private final boolean mDecodeFileDescriptorEnabled; // 是否允许解码文件描述否 private final boolean mDecodeMemoryFileEnabled; // 是否允许解码内存中的文件 private final Supplier&lt;MemoryCacheParams&gt; mEncodedMemoryCacheParamsSupplier; // 缓存未解码的图像所对应的MemoryCacheParams的供应者 private final ExecutorSupplier mExecutorSupplier; // 线程池供应商 private final ImageCacheStatsTracker mImageCacheStatsTracker; // 记录ImageCache各种状态的工具 @Nullable private final ImageDecoder mImageDecoder; // 图片解码工具类 private final Supplier&lt;Boolean&gt; mIsPrefetchEnabledSupplier; // 是否允许预取的供应商 private final DiskCacheConfig mMainDiskCacheConfig; // 磁盘缓存配置 private final MemoryTrimmableRegistry mMemoryTrimmableRegistry; // 监听内存状态 private final NetworkFetcher mNetworkFetcher; // 内存 @Nullable private final PlatformBitmapFactory mPlatformBitmapFactory; // 不同版本对应的BitmapFactory private final PoolFactory mPoolFactory; // Pool的工厂 private final ProgressiveJpegConfig mProgressiveJpegConfig; // 对于渐进式Jpeg的配置 private final Set&lt;RequestListener&gt; mRequestListeners; // Request的监听者 private final boolean mResizeAndRotateEnabledForNetwork; // 是否允许网络请求的图片设置大小或是旋转 private final DiskCacheConfig mSmallImageDiskCacheConfig; // 小图片的磁盘缓存配置 ImagePipelineConfig内部的构造方法对本身复杂的参数进行设置，具体如下： private ImagePipelineConfig(Builder builder) { // 动画工厂 mAnimatedImageFactory = builder.mAnimatedImageFactory; // Bitmap 内存缓存参数 Supplier mBitmapMemoryCacheParamsSupplier = builder.mBitmapMemoryCacheParamsSupplier == null ? new DefaultBitmapMemoryCacheParamsSupplier( (ActivityManager) builder.mContext.getSystemService(Context.ACTIVITY_SERVICE)) : builder.mBitmapMemoryCacheParamsSupplier; // 图片的默认格式为 ARGB_8888 mBitmapConfig = builder.mBitmapConfig == null ? Bitmap.Config.ARGB_8888 : builder.mBitmapConfig; mCacheKeyFactory = builder.mCacheKeyFactory == null ? DefaultCacheKeyFactory.getInstance() : builder.mCacheKeyFactory; mContext = Preconditions.checkNotNull(builder.mContext); mDecodeFileDescriptorEnabled = builder.mDownsampleEnabled &amp;&amp; builder.mDecodeFileDescriptorEnabled; mDecodeMemoryFileEnabled = builder.mDecodeMemoryFileEnabled; mDownsampleEnabled = builder.mDownsampleEnabled; mEncodedMemoryCacheParamsSupplier = builder.mEncodedMemoryCacheParamsSupplier == null ? new DefaultEncodedMemoryCacheParamsSupplier() : builder.mEncodedMemoryCacheParamsSupplier; // 默认不记录Cache的Stat mImageCacheStatsTracker = builder.mImageCacheStatsTracker == null ? NoOpImageCacheStatsTracker.getInstance() : builder.mImageCacheStatsTracker; mImageDecoder = builder.mImageDecoder; mIsPrefetchEnabledSupplier = builder.mIsPrefetchEnabledSupplier == null ? new Supplier&lt;Boolean&gt;() { @Override public Boolean get() { return true; } } : builder.mIsPrefetchEnabledSupplier; // 磁盘默认 缓存大小配置 mMainDiskCacheConfig = builder.mMainDiskCacheConfig == null ? getDefaultMainDiskCacheConfig(builder.mContext) : builder.mMainDiskCacheConfig; // 默认磁盘整理策略,该默认配置什么也不做 mMemoryTrimmableRegistry = builder.mMemoryTrimmableRegistry == null ? NoOpMemoryTrimmableRegistry.getInstance() : builder.mMemoryTrimmableRegistry; // 默认的网络Fetcher:HttpURLConnection mNetworkFetcher = builder.mNetworkFetcher == null ? new HttpUrlConnectionNetworkFetcher() : builder.mNetworkFetcher; mPlatformBitmapFactory = builder.mPlatformBitmapFactory; mPoolFactory = builder.mPoolFactory == null ? new PoolFactory(PoolConfig.newBuilder().build()) : builder.mPoolFactory; mProgressiveJpegConfig = builder.mProgressiveJpegConfig == null ? new SimpleProgressiveJpegConfig() : builder.mProgressiveJpegConfig; mRequestListeners = builder.mRequestListeners == null ? new HashSet&lt;RequestListener&gt;() : builder.mRequestListeners; mResizeAndRotateEnabledForNetwork = builder.mResizeAndRotateEnabledForNetwork; mSmallImageDiskCacheConfig = builder.mSmallImageDiskCacheConfig == null ? mMainDiskCacheConfig : builder.mSmallImageDiskCacheConfig; // Below this comment can&apos;t be built in alphabetical order, because of dependencies int numCpuBoundThreads = mPoolFactory.getFlexByteArrayPoolMaxNumThreads(); mExecutorSupplier = builder.mExecutorSupplier == null ? new DefaultExecutorSupplier(numCpuBoundThreads) : builder.mExecutorSupplier; } 实际上，对于ImagePipeline默认初始化的理解，就在于对这些参数设置的理解上，因此，接下来我们因此分析每一种配置的所表示的意义是什么。 Supplier mBitmapMemoryCacheParamsSupplier该配置用来表示默认的解码之后的Bitmap的缓存策略，其默认配置如下： // Bitmap 内存缓存参数 Supplier mBitmapMemoryCacheParamsSupplier = builder.mBitmapMemoryCacheParamsSupplier == null ? new DefaultBitmapMemoryCacheParamsSupplier( (ActivityManager) builder.mContext.getSystemService(Context.ACTIVITY_SERVICE)) : builder.mBitmapMemoryCacheParamsSupplier; 可以看到，如果默认情况下没有在builder中提供mBitmapMemoryCacheParamsSupplier中提供配置的话，会通过DefaultBitmapMemoryCacheParamsSupplier创建一个，那创建的内容是什么呢？DefaultBitmapMemoryCacheParamsSupplier代码比较简单，其配置的MemoryCacheParams内容通过表格简单列举一下。 MemoryCacheParams 配置： 变量名 默认值 备注 maxCacheSize 不同内存，cache大小不同，见下表 cache的最大空间，单位kb maxCacheEntries 256 cache中允许的有效元素的最大数量 maxEvictionQueueSize Integer.MAX_VALUE cache待回收空间队列大小，单位kb maxEvictionQueueEntries Integer.MAX_VALUE cache待回收队列最大元素数量 maxCacheEntrySize Integer.MAX_VALUE 单个cache所能容纳的最大元素数量 不同机器上，所配置的cache大小分别为： 序号 内存 设定值 说明 1 &lt;32MB 4MB 2 =32MB &amp;&amp; &lt;64MB 6MB 3 不在1、2之列 &amp;&amp; API &lt; 11 8MB 之前版本使用共享内存无法获得足够理想的效果 4 不再1、2之列 &amp;&amp; API &gt;= 11 程序可用Heap大小/4 CacheKeyFactory mCacheKeyFactoryCacheKeyFactory的配置代码如下： mCacheKeyFactory = builder.mCacheKeyFactory == null ? DefaultCacheKeyFactory.getInstance() : builder.mCacheKeyFactory; 对于CacheKeyFactory而言，其配置主要分为两类，一类是未解码的ImageRequest，一类是已经解码的ImageRequest，分别如下： 未解码的ImageRquest对于这种ImageRquest，通过的SimpleCacheKey来实现。 @Override public CacheKey getEncodedCacheKey(ImageRequest request) { return new SimpleCacheKey(getCacheKeySourceUri(request.getSourceUri()).toString()); } 而实际上，SimpleCache则是简单的对传入的String取.hashCode()，换句话说，就是根据Uri生成了hashCode 解码的ImageRequest剩余情况下，所使用的参数有： 参数名称 参数描述 mSourceString 一般对应Uri mResizeOptions 大小调整参数 mAutoRotated 自动旋转参数 mImageDecodeOptions 解码配置 mPostprocessorCacheKey 后处理器CacheKey mPostprocessorName 后处理器名称 Supplier mEncodedMemoryCacheParams该变量提供未解码图片缓存配置策略，代码如下： mEncodedMemoryCacheParamsSupplier = builder.mEncodedMemoryCacheParamsSupplier == null ? new DefaultEncodedMemoryCacheParamsSupplier() : builder.mEncodedMemoryCacheParamsSupplier; 看看DefaultEncodedMemoryCacheparamsSupplier都配置了什么？其实与CacheKeyFactory mCacheKeyFactory类似。区别在于Cache大小取值不同，具体如下： 序号 内存 &lt;16MB 1MB &lt;32MB 2MB =64MB 4MB ImageCacheStatsTracker mImageCacheStatsTracker该配置主要用来控制ImageCache统计信息记录，相关代码如下： mImageCacheStatsTracker = builder.mImageCacheStatsTracker == null ? NoOpImageCacheStatsTracker.getInstance() : builder.mImageCacheStatsTracker; 默认配置为：什么ImageCache的统计信息也不记录。 DiskCacheConfig mMainDiskCacheConfig磁盘缓存策略配置 mMainDiskCacheConfig = builder.mMainDiskCacheConfig == null ? getDefaultMainDiskCacheConfig(builder.mContext) : builder.mMainDiskCacheConfig; 默认配置 private static DiskCacheConfig getDefaultMainDiskCacheConfig(final Context context) { return DiskCacheConfig.newBuilder() // 默认文件路径 .setBaseDirectoryPathSupplier( new Supplier&lt;File&gt;() { @Override public File get() { return context.getApplicationContext().getCacheDir(); } }) // 目录 .setBaseDirectoryName(&quot;image_cache&quot;) // 默认大小 40MB .setMaxCacheSize(40 * ByteConstants.MB) // 磁盘空间不足时候,默认大小 10MB .setMaxCacheSizeOnLowDiskSpace(10 * ByteConstants.MB) // 磁盘控件极其不足时,默认 2MB .setMaxCacheSizeOnVeryLowDiskSpace(2 * ByteConstants.MB) .build(); } NetworkFetcher mNetworkFetcherNetworkFetcher,Fresco支持okHttp和Android自带的HttpURLConnection实现。 mNetworkFetcher = builder.mNetworkFetcher == null ? new HttpUrlConnectionNetworkFetcher() : builder.mNetworkFetcher; 网络的获取部分是一个图片库的重要部分，在后面我们需要重点分析，此处知道在默认情况下，Fresco采用Android自带的网络库即可。 PoolFactory mPoolFactory在图形库当中，由于需要频繁小块的内存访问，重复申请空间会花费大量的时间，因此都会采用对象池/数据池的办法重复利用以前的对象，Fresco也不例外： mPoolFactory = builder.mPoolFactory == null ? new PoolFactory(PoolConfig.newBuilder().build()) : builder.mPoolFactory; 对应的默认配置代码如下： private PoolConfig(Builder builder) { mBitmapPoolParams = builder.mBitmapPoolParams == null ? DefaultBitmapPoolParams.get() : builder.mBitmapPoolParams; mBitmapPoolStatsTracker = builder.mBitmapPoolStatsTracker == null ? NoOpPoolStatsTracker.getInstance() : builder.mBitmapPoolStatsTracker; mFlexByteArrayPoolParams = builder.mFlexByteArrayPoolParams == null ? DefaultFlexByteArrayPoolParams.get() : builder.mFlexByteArrayPoolParams; mMemoryTrimmableRegistry = builder.mMemoryTrimmableRegistry == null ? NoOpMemoryTrimmableRegistry.getInstance() : builder.mMemoryTrimmableRegistry; mNativeMemoryChunkPoolParams = builder.mNativeMemoryChunkPoolParams == null ? DefaultNativeMemoryChunkPoolParams.get() : builder.mNativeMemoryChunkPoolParams; mNativeMemoryChunkPoolStatsTracker = builder.mNativeMemoryChunkPoolStatsTracker == null ? NoOpPoolStatsTracker.getInstance() : builder.mNativeMemoryChunkPoolStatsTracker; mSmallByteArrayPoolParams = builder.mSmallByteArrayPoolParams == null ? DefaultByteArrayPoolParams.get() : builder.mSmallByteArrayPoolParams; mSmallByteArrayPoolStatsTracker = builder.mSmallByteArrayPoolStatsTracker == null ? NoOpPoolStatsTracker.getInstance() : builder.mSmallByteArrayPoolStatsTracker; } 依赖来看： PoolParams mBitmapPoolParams默认情况下，Fresco不缓存任何Bitmap对象，如果使用完毕，则立刻释放。 PoolParams参数 名称 含义 默认配置 maxSizeHardCap 最大实际使用空间，当pool的size达到该设定值时，再申请空间会抛出BasePool.PoolSizeViolationException异常 内存&gt;16MB -&gt; 0.75Max; 内存&lt;=16MB -&gt; 0.5Max maxSizeSoftCap 一个pool的虚拟容量： 当pool的size达到该设定值时，pool会尝试清理空间，直至size&lt;该设定值 或者 空闲空间=0&lt; 0：不缓存 bucketSizes pool可以包含各种各样的「size」，一个bucket用来表示一种大小，额外的，每一中bucket包含max-length，用来表示bucket中used+free的总共的元素数量,此处的maxSize是上面的soft类型的maxSize，如果达到限制，不会抛出异常，而仅仅是开始释放空间，如果此时仍有请求过来，则是和简单的alloc+free一样，不会被pool管理。如果该参数null，那么pool会根据需求自动创建bucket 0：不缓存 minBucketSize 表示pool中最小的bucket数量，可以保证任何元素小于等于该参数的都可以保存的bucket中 0 maxBucketSize 仅有元素size小于该参数时，才会保存至bucket中，如果尺寸超过该参数，会抛出异常。 Integer.MAX_VALUE 其他的也是各种Pool的配置，此处就不再多分析，需要的时候再过来看。 ProgressiveJpegConfig渐进式照片显示控制。 RequestListeners保存所有的请求监听者对象 ResizeAndRotateEnabledForNetwork是否允许从网络获取的图像，调整大小/缩放 SmallImageDiskCacheConfig较小图片的Disk Cache配置 ExecutorSupplier线程池对象，注意，该对象初始化代码如下： int numCpuBoundThreads = mPoolFactory.getFlexByteArrayPoolMaxNumThreads(); mExecutorSupplier = builder.mExecutorSupplier == null ? new DefaultExecutorSupplier(numCpuBoundThreads) : builder.mExecutorSupplier; 也就是说，这个是依赖于FlexByteArrayPoolMaxNumThreads()的，那么这个方法默认的参数是什么呢？跟进去看一下 FlexByteArrayPool中的线程池数量为：public static final int DEFAULT_MAX_NUM_THREADS = Runtime.getRuntime().availableProcessors(); 初始化DraweeDrawee的初始化代码如下： // 初始化Drawee private static void initializeDrawee(Context context) { sDraweeControllerBuilderSupplier = new PipelineDraweeControllerBuilderSupplier(context); SimpleDraweeView.initialize(sDraweeControllerBuilderSupplier); } 可以看到Drawee的初始化分为两步： 实例化PipelineDraweeControllerBuilderSuppplier。 使用PipelineDraweeControllerBuilderSupplier初始化SimpleDraweeView。 PipelineDraweeControllerBuilderSupplier该对象的实例过程如下： public PipelineDraweeControllerBuilderSupplier( Context context, ImagePipelineFactory imagePipelineFactory, Set&lt;ControllerListener&gt; boundControllerListeners) { mContext = context; mImagePipeline = imagePipelineFactory.getImagePipeline(); mPipelineDraweeControllerFactory = new PipelineDraweeControllerFactory( context.getResources(), DeferredReleaser.getInstance(), imagePipelineFactory.getAnimatedDrawableFactory(), UiThreadImmediateExecutorService.getInstance()); mBoundControllerListeners = boundControllerListeners; } 步骤如下： 获取ImagePipeline 实例化PipelineDraweeControllerFactory 设置Controller监听者 而PipelineDraweeController则设置了一下的属性 // 资源所在的Resource private Resources mResources; // DeferredReleaser 用于释放任务 private DeferredReleaser mDeferredReleaser; // 动画Drawable工厂 private AnimatedDrawableFactory mAnimatedDrawableFactory; // 基于主线程的线程池 private Executor mUiThreadExecutor; 其中变量的含义比较容易理解，就不再解释，需要注意的是， mUiThreadExecutor是一个封装了主线程Looper的Executor。 SimpleDraweeView的初始化SimpleDraweeView的初始化更加简单，只有一行代码。 public static void initialize( Supplier&lt;? extends SimpleDraweeControllerBuilder&gt; draweeControllerBuilderSupplier) { sDraweeControllerBuilderSupplier = draweeControllerBuilderSupplier; } 就是将前面初始化好的 PipelineDraweeControllerBuilderSupplier 设置给SimpleDraweeView. 好了，Fresco最基本的初始化过程就是这些，但这些还不能向我们解释，Fresco具体是将图片怎么样绘制到界面上的，在下一篇文章中，将对这些内容进行分析。","categories":[{"name":"Fresco","slug":"Fresco","permalink":"http://yoursite.com/categories/Fresco/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Fresco","slug":"Fresco","permalink":"http://yoursite.com/tags/Fresco/"},{"name":"图片库","slug":"图片库","permalink":"http://yoursite.com/tags/图片库/"}]},{"title":"Fresco学习笔记","slug":"android-fresco-notes","date":"2015-08-03T08:58:10.000Z","updated":"2018-10-03T15:06:48.238Z","comments":true,"path":"2015/08/03/android-fresco-notes/","link":"","permalink":"http://yoursite.com/2015/08/03/android-fresco-notes/","excerpt":"","text":"Fresco学习笔记Fresco是Facebook出品的一款比较新的图片库，相比 Volley 或者 Picasso 具有很多优点，这篇文章主要是记录如何学习使用Fresco。 内容主要来自： http://fresco-cn.org/docs/getting-started.html 配置和使用引用Gradle添加lib dependencies { compile &apos;com.facebook.fresco:fresco:0.5.0+&apos;} 使用网络权限初始化Fresco注意，初始化Fresco的代码必须位于setContentView(ResourceId)代码调用之前。 Fresco.initialize(context); xml布局文件命名空间使用SimpleDraweeView需要注意的是，Fresco的layout_width/height必须要设置，但不能使用wrap_content来根据图片自动调整布局大小，但根据layout_weight属性均分的时候，可以使用wrap_content属性。 加载图片Uri uri = Uri.parse(&quot;https://raw.githubusercontent.com/facebook/fresco/gh-pages/static/fresco-logo.png&quot;); SimpleDraweeView draweeView = (SimpleDraweeView) findViewById(R.id.my_image_view); draweeView.setImageURI(uri); 剩余的工作，Fresco完成 显示占位图直到加载完成 下载图片 缓存图片 图片不再显示时，从内存中移除 几个概念DraweesDrawees负责图片的显示、包括几个组件，组织上类似MVC架构。 DraweeView继承自View，负责图片的显示。（需要注意的是，Fresco并没有使用自定义View，而使用了View来显示图片） 一般情况下，使用SimpleDraweeView即可。 DraweeHierarchyDraweeHierarchy用于组织和维护Draweeable对象，相比于MVC中的Module，需要在Java代码中自定义图片的显示，可通过该类实现。 DraweeControllerDraweeController负责和image loader交互(默认情况下使用Fresco的image pipeline)，可创建一个该类的实例，用于实现对图片的更多的控制。 DraweeControllerBuilderDraweeControllers由DraweeControllerBuilder采用Builder构建者模式创建，immutable。 Lisenersbuilder的作用之一就是，当图片从服务器下载时，在某些状态时刻设置需要执行的代码。 Image PipelineFraesco使用image pipeline来处理图片获取的过程，包括从网络、本地文件、content provider、本地资源中获取，Image pipeline在本地磁盘中保存了一份压缩的图片缓存，在RAM中一份未压缩的图片。 Image pipeline使用特定的技术 pinned purgeables 来在Java heap之外保存图片，这也要求在图片使用完成之后要关闭 close 图片。 SimpleDraweeView自动处理这一过程，大部分情况下可以满足我们的使用需求。 支持的URIFresco 不支持 相对路径的 URI，因此所有的URI在使用的时候指定绝对路径，包括scheme。 Fresco支持的URI包括： Type Scheme Fetch method used File on network http://, https:// HttpURLConnection or network layer File on device file:// FileInputStream Content Provider content:// ContentResolver Asset in app asset:// AssetManager Resource in app res:// Resource.openRawResource 注意：image pipeline仅仅支持图片资源，比如PNG图片格式，并未支持其他的比如String或者XML Drawable等。其中可能困惑的就是使用 XML 声明的Drawable，比如ShapeDraable，需要注意的是，ShapeDrawable也并非图片。如果必须要在Fresco中使用XML Drawable，可以将XML drawable指定为 placeholder，并指定uri为 null. Drawee在XML中使用Draweesxml中支持的可配置属性 wrap_content需要注意的是，必须为Drawees指定layout_width和layout_height，但Drawees不支持wrap_content属性。原因是：占位图和所下载的图像可能大小并不一致，如果不一致，那么下载完成之后，若为warp_content，那么View将会重新layout，改变大小和位置，导致界面跳跃。（其他的Picasso和Volley是怎么处理的？是默认使用placeholder的大小吗？） 固定宽高比如果需要设置固定的宽和高的比例，比如4：3，那么则在XML中，指定width，height设定为warp_content。在代码中指定比例，如下： mSimpleDraweeView.setAspectRatio(1.33f); Java中使用Drawee更改图片大小最简单的方法是，setImageURI即可。 mSimpleDraweeView.setImageURI(uri); 如果需要更加复杂的效果，可使用controller builder. 自定义Hierarchy在一般情况下，XML中的配置参数可满足对hierarchy参数设置的需求，但有的时候，用户可能有更多的需求： 首先创建一个hierarchy builder的实例，然后构建hierarchy并传递给Drawee。 List backgroundsList; List overlaysList; // 创建Hierarchy Builder GenericDraweeHierarchyBuilder builder = new GenericDraweeHierarchyBuilder(getResources()); // 创建Hierarchy GenericDraweeHierarchy hierarchy = builder .setFadeDuration(300) .setPlaceholderImage(new MyCustomDrawable()) .setBackgrounds(backgroundList) .setOverlays(overlaysList) .build(); // 设置给DraweeView mSimpleDraweeView.setHierarchy(hierarchy); 需要注意的是，对于同一个View，不要调用超过1次的setHierarchy方法，即使该view已经被回收也不可以。 Hierarchy的创建是 耗时 的，因此要注意重复利用而不是反复创建。 需要更改显示的图片可通过调用setController或者setImageURI来实现。 修改Hierarchy的配置Hierarchy中的配置可在运行期间进行多次修改，调用下列代码获取Hierarchy GenericDraweeHierarchy hierarchy = mSimpleDraweeView.getHierarchy(); 修改placeholderhierarchy.setPlaceholderImage(R.drawable.placeholderId); Drawable drawable; // create your drawable hierarchy.setPlaceholderImage(drawable); 修改图片修改图片缩放方式 hierarchy.setActualImageScaleType(ScalingUtils.ScaleType.CENTER_INSIDE); 如果设置的缩放方式为 focusCrop , 那么需要设置焦点： hierarchy.setActualImageFocusPoint(point); 给图片添加Color Filer ColorFilter filter; // create your filter hierarchy.setActualImageColorFilter(filter); 设置RoundingRoundingParams roundingParams = hierarchy.getRoundingParams(); roundingParams.setCornersRadius(10); hierarchy.setRoundingParams(roundingParams); Drawee Components定义Drawees中，除了真实的需要显示的图片之外，其他的属性均可通过XML进行配置，在XML中配置的属性，必须为Android drawable或者color资源。 这些属性也可通过GenericDraweeHierarchyBuilder在程序中进行配置，如果在程序中配置，那么配置的资源必须为Drawable的子类。 有些属性可以在程序运行中实时配置，这些拥有可配置的属性都在GenericDraweeHierarchy类中拥有对应的方法。 ActualActual即对应的需要显示的图片，使用URI指定，可为网络资源、本地文件、本地资源或者content provider。 Actual为controller的属性而不是hierarchy的属性。因此在一个Drawee中配置的Actual不会出现在其他的Drawee中。 可使用setImageURI来设置图片或者通过设置controller来设置。 除了sclale类型之外，hierarchy还公开了设置Acutal图片的其他的方法： focus point，当设置scale type为focuesCrop时有效 color filter 默认的scale type为：centerCrop Placeholder当Drawee出现在界面的时候，会首先显示 placeholder ，当调用 setControlelr 或者 setImageURI 设置Drawee显示的图像之后， placeholder 仍会显示直至图片加载完成。如果加载的图片为渐进式JPEG（progressive JPEG），可设置JPEG的清晰度阈值，当清晰度满足条件之后，则placeholder不再显示。 XML属性：placeholderImage Hierarchy builder方法：setPlaceholderImage Hierarchy方法：setPlaceholderImage 默认值：transparent ColorDrawable 默认sclale方式：centerInside Failure加载失败的时候，显示Failure XML属性：failureImage Hierarchy builder方法：setFailureImage 默认值：*placeholder image* 默认sclale方式：centerInside Retry当图片下载失败，且对应的controller设置 enable tap-to-retry 属性之后。 必须在 build your own Controller 中设置tap-to-retry属性： setTapToRetryEnabled(true) image piple会在用户点击之后重试，最高可重试4次。 XML属性：retryImage Hierarchy builder方法：setRetryImage 默认值：*placeholder image* 默认sclale方式：centerInside Progress Bar如果设置该属性，则会在Drawee之上显示一层overlay，直至最终的图片加载完成。 XML属性：progressBarImage Hierarchy builder方法：setProgressBarImage 默认值：*placeholder image* 默认sclale方式：centerInside BackgroundsBackground会首先绘制，在hierarchy其余层次之下。 在XML中仅仅可以指定一个Background，但是在Java代码中可以指定多个，这种情况下，则会将第一绘制在地下，然后绘制剩下的Background。 Backgound images不支持scale-types，并且自动缩放至Drawee的尺寸。 XML属性：backgroundImage Hierarchy builder方法：setBackground、setBackgrounds 默认值：None 默认sclale方式：N/A OverlaysOverlays会最后绘制，在hierarchy其余层次之上。 在XML中仅仅可以指定一个Overlay，但是在Java代码中可以指定多个，这种情况下，则会将第一绘制在地下，然后绘制剩下的Overlay。 Overlay images不支持scale-types，并且自动缩放至Drawee的尺寸。 XML属性：overlayImage Hierarchy builder方法：setOverlay、setOverlays 默认值：None 默认sclale方式：N/A Pressed State Overlay如果指定Pressed State Overlay，那么在用户点击Drawee区域之后，则会显示对应的Overlay。比如，Drawee在显示一个button图片，overlay可以用于在用户点击之后改变button的颜色。 不支持scale-types。 XML属性：pressedStateOverlayImage Hierarchy builder方法：setPressedStateOverlay 默认值：None 默认sclale方式：N/A Progress Bars在应用程序中，最简单的使用progress bar的方式是在构建hierarchy的时候使用ProgressBarDrawable。 .setProgressBarImage(new ProgressBarDrawable()) 通过该操作可在Drawee下面显示一个黑色蓝角的progress bar。 定义自己的progress bar如果我们需要定义自己的progress bar，需要 注意 的是 为了当加载的时候，progress能够动态变化，需要覆写Drawable.onLevelChange方法 class CustomProgressBar extends Drawable { @Override protected void onLevelChange(int level) { // level is on a scale of 0-10,000 // where 10,000 means fully downloaded // your app&apos;s logic to change the drawable&apos;s // appearance here based on progress } } Scaling可用缩放类型ScaleType Explanation center Center the image in the view, but perform no scaling. centerCrop Scales the image so that both dimensions will be greater than or equal to the corresponding dimension of the parent. One of width or height will fit exactly. The image is centered within parent’s bounds. focusCrop Same as centerCrop, but based around a caller-specified focus point instead of the center. centerInside Downscales the image so that it fits entirely inside the parent. Unlike fitCenter, no upscaling will be performed. Aspect ratio is preserved. The image is centered within parent’s bounds. fitCenter Scales the image so that it fits entirely inside the parent. One of width or height will fit exactly. Aspect ratio is preserved. The image is centered within the parent’s bounds. fitStart Scales the image so that it fits entirely inside the parent. One of width or height will fit exactly. Aspect ratio is preserved. The image is aligned to the top-left corner of the parent. fitEnd Scales the image so that it fits entirely inside the parent. One of width or height will fit exactly. Aspect ratio is preserved. The image is aligned to the bottom-right corner of the parent. fitXY Scales width and height independently, so that the image matches the parent exactly. Aspect ratio is not preserved. none Used for Android’s tile mode. 以上的ScleType与Android中提供的Scale Type类似，但不同的是Fresco中不提供 matrix,然而Fresco中提供 focusCrop以实现更好的效果。 如何设置Scale TypeActual, placeholder, retry和failure图片均可在XML中配置，使用方法为：fresco:actualImageScaleType，我们同样也可以在GenericDraweeHierachyBuilder类中使用代码设置。 即使在hierarchy设置之后，我们仍然可以通过GenericDraweeHierarchy来配置。 然而， 不要使用 android:scaleType属性，同样 不要使用 .setScaleType方法，这两种方式对Drawees没有效果。 focusCropAndroid和Fresco均提供 centerCrop缩放类型，该类型很常用，但也会存在使用场景的尴尬时刻，比如图片的左上角为头像，则无法通过 centerCrop来获取。 通过设置focus point，我们可以设置获取图片的某些部分，比如我们设置focus point为图片的边上，比如(0.5f, 0f)，Fresco可以保证，无论怎样扩展，该focus point均可以显示。 Focus points使用相对坐标系统，(0f, 0f)为左上角，(1f, 1f)为右下角。 如果focus point设置为(0.5f, 0.5f)，那么则等于 centerCrop。 为了使用focus points，必须在XML中首先设置正确的scale type。 fresco:actualImageScaleType=&quot;focusCrop&quot; 在Java代码中，必须程序 显式 设置正确的focus point。 PointF focusPoint; // your app populates the focus point mSimpleDraweeView .getHierarchy() .setActualImageFocusPoint(focusPoint); Rounded Corners and Circles Edit on GitHub在很多时候，APP需要图片有圆角或者是园。Drawee支持各种各样的变化，但不会引入由于复制bitmaps而引入的额外的内存开销。 图片可以以两种方式制作成圆角 circle，圆形，设置roundAsCircle为true 如果图片是个直角，需要圆角，那么同时需要设置roundedCornerRadius。 图片是直角的情况下，支持为4个角分别设置4个不同的圆弧半径，但这种情况下只能在Java中设置而不是XML中设置。 怎么设置图片可以通过两种方式来设置圆弧 BITMAP_ONLY：使用一个shader来绘制图片以及圆角。这是默认的生成圆角的办法。这种方法在针对actual image和placeholder的时候有效。针对其他的，比如failure和retry的图片，不会生成圆角。此外，这种生成圆角的方式不支持动画效果。 OVERLAY_COLOR ：通过生成一个solid color的overlay来生成圆角，由调用者指定。在这种情况下，Drawee的背景颜色应该设置为固定的，且与solid color同样。可在XML中设置 roundWithOverlayColor或者在Java代码中调用setOverlayColr方法来设置这种效果。 ###XML 通过在XML中配置此类属性，可以将设置传递给RoundingParams。 Java代码当创建hierarchy的时候，我们可以传递一个RoundingParams的实例给GenericDraweeHierarchyBuilder： RoundingParams roundingParams = RoundingParams.fromCornersRadius(7f); // alternatively use fromCornersRadii or asCircle roundingParams.setOverlayColor(R.color.green); genericDraweeHierarchyBuilder .setRoundingParams(roundingParams); 我们也可以在代码运行的时候修改大部分的rounding参数： RoundingParams roundingParams = RoundingParams.fromCornersRadius(5f); roundingParams.setBorder(R.color.red, 1.0); roundingParams.setRoundAsCircle(true); mSimpleDraweeView.getHierarchy().setRoundingParams(roundingParams); 注意在使用BITMAP_ONLY（默认）情况下，有几种使用上的限制： 并非所有的图片都会圆角处理，只有actual image和placeholder会被处理。当前Fresco的代码在修改支持对background进行处理。 只有图片可转化为BitmapDrawable或者ColorDrawable可以被rounded处理。对NinePathDrawable、ShapeDrawable以及其他类似的Drawable不会被处理（无论是XML或者Java编程方式） 动画不会被rounded。 由于Android中BitmapShader的限制，如果image的大小无法覆盖住整个View，那么不会说不绘制任何东西，而是edges会被不断重复。一种变通的方法是设置不同的scale类型，比如centerCrop来保证整个View被覆盖住。 OVERLAY_COLOR模式并没有上述限制，但由于其模仿实现rounded的思路是通过在image之上覆盖一层图层的方法实现，因此仅仅在Drawee的背景设置为固定的相同的颜色的时候，具有较好的效果。 Drawee原本拥有CLIPPING模式，但已经取消。 最后，这些问题都可通过设孩子一个临时bitmap的方式解决，但这会引入额外的性能负担，并不推荐。 因此，在Android平台上，没有一个完美的解决方案来实现绘制圆角。 使用ControllerBuilderSimaleDraweeView可以通过两种方法指定图片，最简单的方式为setImageURI。 如果希望对Drawee拥有更加详细的控制，可以使用DraweeController。 构建DraweeController将image request传递给一个PipelineDraweeControllerBuilder，并为Controller设置更加详尽的设置。 ControllerListener listener = new BaseControllerListener() {...} DraweeController controller = Fresco.newDraweeControllerBuilder() .setUri(uri) .setTapToRetryEnabled(true) .setOldController(mSimpleDraweeView.getController()) .setControllerListener(listener) .build(); mSimpleDraweeView.setController(controller); 注意 我们应当记住，当构建一个新的controller的时候，应当调用setOldController以避免不必要的内存开销。 自定义ImageRequest在一些比较高级的应用场合，我们可能需要向pipeline传递一个ImageRequest，而不仅仅是一个URI。其中一个例子就是使用postprocessor。 Uri uri; Postprocessor myPostprocessor = new Postprocessor() { ... } ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri) .setPostprocessor(myPostprocessor) .build(); DraweeController controller = Fresco.newDraweeControllerBuilder() .setImageRequest(request) .setOldController(mSimpleDraweeView.getController()) // other setters as you need .build(); Progressive JPEGs 渐进式JPEGsFresco支持从网络上获取Progressive JPEGs。 渐进式JPEGs仅仅在从网络上获取的时候支持。本地的图片在一次解码中全部完成，因此并不需要这种需求。 构建image request如果需要Fresco支持渐进式JPEG，那么必须在配置image request的时候明确指定渲染此类型的image。 Uri uri; ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri) .setProgressiveRenderingEnabled(true) .build(); DraweeController controller = Fresco.newDraweeControllerBuilder() .setImageRequest(request) .setOldController(mSimpleDraweeView.getController()) .build(); mSimpleDraweeView.setController(controller); Fresco会考虑在以后的版本中，通过setImageURI支持渐进式JPEGs。 动画图像Fresco支持 GIF 动画和 WebP 格式的动画。 Fresco 在Android 2.3+ 版本上支持 WebP 以及 WebP extended 格式的图片，而此类格式在Android原生版本中并未支持。 自动播放动画如果希望当图片出现在屏幕上的时候立刻开始绘制，而当图片不显示的时候停止播放动画，可通过对image request进行配置实现： Uri uri; DraweeController controller = Fresco.newDraweeControllerBuilder() .setUri(uri) .setAutoPlayAnimations(true) . // other setters .build(); mSimpleDraweeView.setController(controller); 手动控制播放如果希望手动控制播放，那么需要监听图片加载的过程。 ControllerListener controllerListener = new BaseControllerListener () { @Override public void onFinalImageSet( String id, @Nullable ImageInfo imageInfo, @Nullable Animatable anim) { if (anim != null) { // app-specific logic to enable animation starting anim.start(); } }; Uri uri; DraweeController controller = Fresco.newDraweeControllerBuilder() .setUri(uri) .setControllerListener(controllerListener) // other setters .build(); mSimpleDraweeView.setController(controller); 此外，controller暴露Animatable的接口。如果non-null，我们可通过该接口直接控制动画播放。 Animatable animatable = mSimpleDraweeView.getController().getAnimatable(); if (animatable != null) { animatable.start(); // later animatable.stop(); } 局限性动画Animations不支持postprocessors功能。 Requesting Multiple Images (Multi-URI)这种方法要求我们实现自己的 image request , 主要有以下几种使用场景： 从低分辨率–&gt;高分辨率有的情况下，高分辨率的图片其体积较大，这个时候直接下载的话，就会导致图片很长时间无法显示，在这种情况下，可以先设置一个低分辨率的图片，然后当高分辨率的图片下载完成之后显示。 Uri lowResUri, highResUri; DraweeController controller = Fresco.newDraweeControllerBuilder() .setLowResImageRequest(ImageRequest.fromUri(lowResUri)) .setImageRequest(ImageRequest.fromUri(highResUri)) .setOldController(mSimpleDraweeView.getController()) .build(); mSimpleDraweeView.setController(controller); 使用缩略预览图本选项仅供本地URI使用，且仅供JPEG图像使用 如果JPEG图像在其EXIF元信息中保存了缩略图，那么image pioeline可以先返回该缩略图。那么我们的Drawee则会先显示缩略预览图，当完整的图片加载完成并成功解码之后，会更改为显示完整的图像。 Uri uri; ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri) .setLocalThumbnailPreviewsEnabled(true) .build(); DraweeController controller = Fresco.newDraweeControllerBuilder() .setImageRequest(request) .setOldController(mSimpleDraweeView.getController()) .build(); mSimpleDraweeView.setController(controller); 加载第一张下载成功的图片一般时候，一张图片仅仅对应一个URI，但有的场景也是例外的。 比如，我们可能拥有一张从Camera获取的已经上传过的图像。原始的图像直接上传的话，体积实在太大，因此需要首先将该图像压缩。在这种场景下，我们就可以先使用压缩的图像(local-downscaled-uri)，如果加载失败之后，则加载Camera原始图像(local-original-uri)，即使失败了，那么则尝试加载网络上的图像(network-uploaded-uri)。 正常情况下，image pipeline会首先从memory cache中搜索图像，然后是disk cache，再然后才是network或者其他的资源。我们可以使得pipeline首先搜索memory cache中所有的图像，而不是一次一次依次操作，只有在没有找到任何图片的时候，再从disk cache中进行搜索。如果仍然没有，则会继续发出其他的请求。 实现起来也很简单，仅仅需要创建一个image request的数组，然后传递给controller的builder。 Uri uri1, uri2; ImageRequest request = ImageRequest.fromUri(uri1); ImageRequest request2 = ImageRequest.fromUri(uri2); ImageRequest[] requests = { request1, request2 }; DraweeController controller = Fresco.newDraweeControllerBuilder() .setFirstAvailableImageRequests(requests) .setOldController(mSimpleDraweeView.getController()) .build(); mSimpleDraweeView.setController(controller); 以上的两个请求中，仅仅有一个图像可以得到显示，主要取决于哪张图片最先加载成功，无论是memory、disk或者network。pipeline会假设requests数组的顺序为用户所期待的搜索顺序。 指定自定义DataSource Supplier为了更加灵活的使用，我们可以在构建Drawee controller的时候，为Drawee controller指定一个自定义的DataSource Supplier。我们可以自定义一个DataSource Supplier或者是组合一些已经有的实现。可以参考 FirstAvailableDataSourceSupplier和InscreasingQualityDataSourceSupplier作为例子。参考AbastractDraweeControllerBuilder来参考怎么组合不同的DataSource Supplier。 监听Downloads Events原因 当图片下载完成的时候，我们可能需要执行一些特殊的操作：比如，显示其他的图片，显示标题等等；或者说当网络故障，提示用户等等。 图片的加载是异步进行的，所以需要额外的操作来监听DraweeController发布的events事件，其原理就是controller listener。 注意 此处不允许对图片本上进行修改，如果需要对图片本身进行修改，使用Postprocessor即可。 使用使用很简单，只要实现ControllerListener接口即可，我们建议集成BaseControllerListener来实现。 ControllerListener controllerListener = new BaseControllerListener () { @Override public void onFinalImageSet( String id, @Nullable ImageInfo imageInfo, @Nullable Animatable anim) { if (imageInfo == null) { return; } QualityInfo qualityInfo = imageInfo.getQualityInfo(); FLog.d(&quot;Final image received! &quot; + &quot;Size %d x %d&quot;, &quot;Quality level %d, good enough: %s, full quality: %s&quot;, imageInfo.getWidth(), imageInfo.getHeight(), qualityInfo.getQuality(), qualityInfo.isOfGoodEnoughQuality(), qualityInfo.isOfFullQuality()); } @Override public void onIntermediateImageSet(String id, @Nullable ImageInfo imageInfo) { FLog.d(&quot;Intermediate image received&quot;); } @Override public void onFailure(String id, Throwable throwable) { FLog.e(getClass(), throwable, &quot;Error loading %s&quot;, id) } }; Uri uri; DraweeController controller = Fresco.newDraweeControllerBuilder() .setControllerListener(controllerListener) .setUri(uri); // other setters .build(); mSimpleDraweeView.setController(controller); onFinalImageSet or onFailure 对于所有的image加载工作都会起作用。 对于渐进式JPEG，如果允许渐进显示，那么每次解码之后，都会调用onIntermediateImageSet方法。 Resizing and Rotating调整大小、旋转是图像显示中经常使用的功能，要实现功能，需要手工直接指定image request。 Resizing ImagesResizing VS Scaling Resizing：是一种软件操作，在pipeline中执行，返回一个完整的拥有不同尺寸的新的图像。 Scaling：是一种绘制操作，一般采用硬件加速。图像本身大小不变。 Resize和Scaling如何选择？ Resizing并不经常使用，Scaling经常使用，即使在resizing中，也会使用Scaling。 Resizing在使用上有几个局限性： Resizing不会返回比原始图像更大的image，Resizing操作只会使得图像更小。 当前仅仅JPEG支持resized。 对于图像的Resize的尺寸控制，仅仅有个大约的数字。图像无法调制大小至非常精确的尺寸，这就意味着，图像即使经过Resized，那么在显示的时候，也需要缩放才能使用View大小。 仅仅支持一下的Resizing尺寸： N/8 with 1 &lt;= N &lt;= 8. Resize调整大小是纯软件操作，相比硬件加速的scaling，速度要慢很多。R 相比之下，Scaling没有以上的局限。Scaling使用Android内置的缩放算法。在Android4.0以上的设备上可以使用GPU硬件加速。在大多数情况下，这也是最快以及最有效的将图片调整至合适尺寸的方法。为一的缺点是，如果图片的尺寸要远远大于界面的话，内存就浪费掉了。 那为什么还要使用Resizing呢？这是一种权衡。我们仅仅在图像的大小远大约View的大小，可以通过Resizing来节约内存的使用。一个具体的例子比如说，我们需要在1280*800（大约1MP）的分辨率上显示相机拍摄的一个8MP的相片。那么这个8MP的图像在ARGB排列的时候大约占据32MB的内存，如果将尺寸Resized，那么可以最低占用4MB的内存。 如果图像是从网络上获取的，在resizing之前，应当考虑能否从网络中获取对应大小尺寸的图像。如果服务器可以返回一个较小尺寸的图像，不要尝试获取8MP的图像。在开发中，要考虑使用者的数据流量消耗。除此之外，获取较小尺寸的图像，还可以节省内存存储空间和CPU时间。如果服务器无法返回一个合适较小尺寸的图片，或者正在使用本地图库，那么应该考虑resizing。除了这些情况之外，我们应当首先考虑使用Rescaling。如果需要Scale，仅仅需要设定SimpleDraweeView的layout_width/layout_height即可。 ResizingResizing不会修改原先的文件，而是对内存中的图像进行解码。当前的Fresco仅仅支持JPEG调整尺寸。为ImageRequest传递ResizeOptions即可。 Uri uri = &quot;file:///mnt/sdcard/MyApp/myfile.jpg&quot;; int width = 50, height = 50; ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri) .setResizeOptions(new ResizeOptions(width, height)) .build(); PipelineDraweeController controller = Fresco.newDraweeControllerBuilder() .setOldController(mDraweeView.getController()) .setImageRequest(request) .build(); mSimpleDraweeView.setController(controller); Auto-rotation自动旋转 ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri) .setAutoRotateEnabled(true) .build(); // as above 对图像进行编辑原因有些情况下，需要对从服务器或者本地获取的图片进行修改，最好的方法是使用Postprocessor，其中组好的实现方式是集成BasePostprocessor类。 例子：在图像上添加红色网： Uri uri; Postprocessor redMeshPostprocessor = new BasePostprocessor() { @Override public String getName() { return &quot;redMeshPostprocessor&quot;; } @Override public void process(Bitmap bitmap) { for (int x = 0; x &lt; bitmap.getWidth(); x+=2) { for (int y = 0; y &lt; bitmap.getHeight(); y+=2) { bitmap.setPixel(x, y, Color.RED); } } } } ImageRequest request = ImageRequestBuilder.newBuilderWithSource(uri) .setPostprocessor(redMeshPostprocessor) .build(); PipelineDraweeController controller = (PipelineDraweeController) Fresco.newDraweeControllerBuilder() .setImageRequest(request) .setOldController(mSimpleDraweeView.getController()) // other setters as you need .build(); mSimpleDraweeView.setController(controller); 需要明确 图像进入postprocessor得到修改，但需要注意的是，cache中的图像不会受到此处postprocessor的影响。在Android4.x及以下版本，修改后的图像与原图像一起保存在Java堆之外。 为了每次都能够展现同样的编辑效果，使用的时候必须每次都指定postprocessor。对于不同请求的同一个图像，可以使用不同的postprocessor。 动态图像不支持postprocessor 复制图像可能有些原因导致无法针对原图像直接编辑，如果这种情况下，BasePostprocessor拥有另外的方法签名已解决这个问题，此处例子展示了如何将bitmap做水平翻转。 @Override public void process(Bitmap destBitmap, Bitmap sourceBitmap) { for (int x = 0; x &lt; destBitmap.getWidth(); x++) { for (int y = 0; y &lt; destBitmap.getHeight(); y++) { destBitmap.setPixel(destBitmap.getWidth() - x, y, sourceBitmap.getPixel(x, y)); } } } 原图像与目标图像大小完全一样。 注意： 不要修改元sourceBitmap，在以后的版本中，如果将sourceBitmap进行修改将会抛出异常。 不要保存对任一个bitmap对象的引用，此处的bitmap对象均由pipeline管理，destBitmap生命周期与Drawee或者DataSource同样。 复制图像，且图像尺寸不一致如果postprocessed图像需要一个不一样尺寸的图像，此处有第三个方法签名：使用PlatformBitmapFacotry类来安全的创建一个保存在Java heap之外的自定义尺寸的Bitmap。 此处例子展示如何创建一个1/4尺寸的图像： @Override public CloseableReference process( Bitmap sourceBitmap, PlatformBitmapFactory bitmapFactory) { CloseableReference bitmapRef = bitmapFactory.createBitmap( sourceBitmap.getWidth() / 2, sourceBitmap.getHeight() / 2); try { Bitmap destBitmap = bitmapRef.get(); for (int x = 0; x &lt; destBitmap.getWidth(); x+=2) { for (int y = 0; y &lt; destBitmap.getHeight(); y+=2) { destBitmap.setPixel(x, y, sourceBitmap.getPixel(x, y)); } } return CloseableReference.cloneOrNull(bitmapRef); } finally { CloseableReference.closeSafely(bitmapRef); } } 注意，必须遵守closeable reference的使用规范。 不要使用 Android的Btimap.createBitmap的方法，此方法创建的图像保存在Java heap当中。 Which to override?Do not override more than one of the three process methods. Doing so can produce unpredictable results. Caching postprocessed images可以将postprocess处理的图像进行保存，为了实现这个效果，自定义的postprocessor必须实现getPostprocessorCacheKey方法并且返回一个not null的值。 为了使得cache命中，在以后的request中的postprocessor必须为同样的类，并且返回同样的cache key。如果不是，那么将会覆盖之前生成的cache entry。 public class OperationPostprocessor extends BasePostprocessor { private int myParameter; public OperationPostprocessor(int param) { myParameter = param; } public void process(Bitmap bitmap) { doSomething(myParameter); } public CacheKey getPostprocessorCacheKey() { return new MyCacheKey(myParameter); } } 如果希望cache始终命中，则设置getPostprocessorCacheKey方法返回固定常量，如果不想使cache命中，则返回null即可。 Repeated Postprocessors可能需要对同一张图片重复处理多次。这种情况下，仅仅需要集成BaseRepeatedPostprocessor即可。 此处的例子允许对图片上的网格在任意时间变换颜色。 public class MeshPostprocessor extends BaseRepeatedPostprocessor { private int mColor = Color.TRANSPARENT; public void setColor(int color) { mColor = color; update(); } @Override public String getName() { return &quot;meshPostprocessor&quot;; } @Override public void process(Bitmap bitmap) { for (int x = 0; x &lt; bitmap.getWidth(); x+=2) { for (int y = 0; y &lt; bitmap.getHeight(); y+=2) { bitmap.setPixel(x, y, mColor); } } } } MeshPostprocessor meshPostprocessor = new MeshPostprocessor(); ///\u0010 setPostprocessor as in above example meshPostprocessor.setColor(Color.RED); meshPostprocessor.setColor(Color.BLUE); 需要注意的是，每一个image request仍然需要设置Postprocessor。 Image Requests如果简单的通过Image URI设置图像，那么使用ImageRequest.fromURI方法即可，但如果需要更多的设置，则需要ImageRequestBuilder； Uri uri; ImageDecodeOptions decodeOptions = ImageDecodeOptions.newBuilder() .setBackgroundColor(Color.GREEN) .build(); ImageRequest request = ImageRequestBuilder .newBuilderWithSource(uri) .setAutoRotateEnabled(true) .setLocalThumbnailPreviewsEnabled(true) .setLowestPermittedRequestLevel(RequestLevel.FULL_FETCH) .setProgressiveRenderingEnabled(false) .setResizeOptions(new ResizeOptions(width, height)) .build(); Fields in ImageRequestFiled Description uri the only mandatory field. See Supported URIs. autoRotateEnabled whether to enable auto-rotation. progressiveEnabled whether to enable progressive loading. postprocessor component to postprocess the decoded image. resizeOptions desired width and height. Use with caution. See Resizing. Lowest Permitted Request Levelimage pipeline根据确定的顺序查找图像 Check the bitmap cache. This is nearly instant. If found, return. Check the encoded memory cache. If found, decode the image and return. Check the “disk” (local storage) cache. If found, load from disk, decode, and return. Go to the original file on network or local file. Download, resize and/or rotate if requested, decode, and return. For network images in particular, this will be the slowest by a long shot. setLowestPermittedRequestLevel方法允许设置pipeline可以走多远，其数值为： BITMAP_MEMORY_CACHE ENCODED_MEMORY_CACHE DISK_CACHE FULL_FETCH 自定义ViewDraweeHolders总有时候DraweeViews无法满足我们的需求。比如我们可能需要在Image所在的View上添加额外的内容，我们可能需要在一个View中显示多个图片。Fresco提供了各种各样的类用于功能扩展： DraweeHolder -&gt; 单个图片 MultiDraweeHolder -&gt; 多个图片 自定义View需要做的事情Android绘制View中的组件，且这些时间仅仅在Android系统内部调用，DraweeViews使用这些时间可以更好的管理内存，提高内存的高效使用。但我们使用holders的时候，必须手动实现其中的部分功能。 处理attach/detach事件如果不进行该操作，我们的自定义holder可能会出现内存泄露 当Android界面不再绘制图片的时候，图片也就没有在内存中保存的意义。Drawees通过监听detach事件来及时的释放内存。当Android重新绘制的时候，这些图片也会自动恢复以供显示。 这些操作在DraweeView中是自动处理的，但在自定义View中需要我们手动处理4个系统调用，并传递给DraweeHolder，下面为例子： DraweeHolder mDraweeHolder; @Override public void onDetachedFromWindow() { super.onDetachedFromWindow(); mDraweeHolder.onDetach(); } @Override public void onStartTemporaryDetach() { super.onStartTemporaryDetach(); mDraweeHolder.onDetach(); } @Override public void onAttachedToWindow() { super.onAttachedToWindow(); mDraweeHolder.onAttach(); } @Override public void onFinishTemporaryDetach() { super.onFinishTemporaryDetach(); mDraweeHolder.onAttach(); } 处理touch events如果我们在Drawee中允许tap-to-retry功能，那么需要监听屏幕的触摸事件。 @Override public boolean onTouchEvent(MotionEvent event) { return mDraweeHolder.onTouchEvent(event) || super.onTouchEvent(event); } 定制onDraw我们必须调用以下代码Drawable drawable = mDraweeHolder.getTopLevelDrawable(); drawable.setBounds(...);否则Drawee不会显示在界面上。 Do not downcast this Drawable. Do not translate it. 其他需要做的工作设置Drawable.Callback// When a holder is set to the view for the first time, // don&apos;t forget to set the callback to its top-level drawable: mDraweeHolder = ... mDraweeHolder.getTopLevelDrawable().setCallback(this); // In case the old holder is no longer needed, // don&apos;t forget to clear the callback from its top-level drawable: mDraweeHolder.getTopLevelDrawable().setCallback(null); mDraweeHolder = ... Override verifyDrawable: @Override protected boolean verifyDrawable(Drawable who) { if (who == mDraweeHolder.getTopLevelDrawable()) { return true; } // other logic for other Drawables in your view, if any } Make sure invalidateDrawable invalidates the region occupied by your Drawee. Constructing a DraweeHolder组织构造函数推荐构建函数如下安排： 覆写View的全部3个构造函数 每个构造函数中调用父类的构造方法，然后调用私有的init方法 所有的初始化操作放在 init 方法中完成 这样做的初衷是：不要在一个构造方法中调用其他的构造方法。同时保证了无论调用哪个构造方法，其初始化顺序都是正确的。我们的holder在init方法中创建。 创建Holder如果可能，总是在自定义View创建之后立刻创建Drawee。hierarchy的创建开销较大，因此最好仅仅操作一次。 class CustomView extends View { DraweeHolder mDraweeHolder; // constructors following above pattern private void init() { GenericDraweeHierarchy hierarchy = new GenericDraweeHierarchyBuilder(getResources()); .set... .set... .build(); mDraweeHolder = DraweeHolder.create(hierarchy, context); } } 设置图片使用controller build实现，但要调用holder的setController方法而不是View中的方法。 DraweeController controller = Fresco.newControllerBuilder() .setUri(uri) .setOldController(mDraweeHolder.getController()) .build(); mDraweeHolder.setController(controller); MultiDraweeHolderMultiDraweeHolder mMultiDraweeHolder; private void init() { GenericDraweeHierarchy hierarchy = new GenericDraweeHierarchyBuilder(getResources()); .set... .build(); mMultiDraweeHolder = new MultiDraweeHolder (); mMultiDraweeHolder.add(new DraweeHolder (hierarchy, context)); // repeat for more hierarchies } 其他与DraweeHolder类似。 一些陷阱Don’t use ScrollViews如果想要实现滑动一列图片的功能，要使用RecyclerView, ListView, or GridView.这些可以复用View，因此Fresco可以知道什么时候Drawee显示了，什么时候不显示了，但ScrollView无法实现，ScrollView会始终保持图像直至Fragment或者Activity销毁，因此如果使用ScrollView，那么程序更有可能遇到OOM的问题。 Don’t downcastIt is tempting to downcast objects returns by Fresco classes into actual objects that appear to give you greater control. At best, this will result in fragile code that gets broken next release; at worst, it will lead to very subtle bugs. Don’t use getTopLevelDrawableDraweeHierarchy.getTopLevelDrawable() should only be used by DraweeViews. Client code should almost never interact with it. The sole exception is custom views. Even there, the top-level drawable should never be downcast. We may change the actual type of the drawable in future releases. Don’t re-use DraweeHierarchiesNever call DraweeView.setHierarchy with the same argument on two different views. Hierarchies are made up of Drawables, and Drawables on Android cannot be shared among multiple views. Don’t use Drawables in more than one DraweeHierarchyThis is for the same reason as the above. Drawables cannot be shared in multiple views. You are completely free, of course, to use the same resourceID in multiple hierarchies and views. Android will create a separate instance of each Drawable for each view. Don’t set images directly on a DraweeViewCurrently DraweeView is a subclass of Android’s ImageView. This has various methods to set an image (such as setImageBitmap, setImageDrawable) If you set an image directly, you will completely lose your DraweeHierarchy, and will not get any results from the image pipeline. Don’t use ImageView attributes or methods with DraweeViewAny XML attribute or method of ImageView not found in View will not work on a DraweeView. Typical cases are scaleType, src, etc. Don’t use those. DraweeView has its own counterparts as explained in the other sections of this documentation. Any ImageView attrribute or method will be removed in the upcoming release, so please don’t use those. Image PipelineIntroduction流水线主要进行以下的操作： 1. 检查bitmap cache，如果存在，则返回。 2. 切换至其他的线程。 3. 检查memory cache，如果存在，则对图像解码、变换、返回，并保存至bitmap cache。 4. 检查disk cache。如果存在，则对图像解码、变换、返回，并保存至memory cache 和 bitmap cache。 5. 检查网络或者其他位置的资源，如果存在，则对图像解码、变换、返回，并保存至disk cache、memory cache 和 bitmap cache。 上图中，’disk’ cache绘制在encode memory cache中来保持流程图正解。 流水线支持从本地文件、网络中获取。支持PNG、GIF、WebP、JPEG文件。 旧设备上支持WebPAndroid在3.0之后才支持WebP，Extended WebP在Android 4.1.2之后才支持。如果设备不支持WebP，image pipeline会将其转换为JPEG，这样就可以在Android2.3以上的系统中均可使用WebP。 配置Image Pipeline大部分程序可通过 Fresco.initialize(context)来简单配置Fresco。 如果程序需要更加自定义的配置，可使用ImagePipelineConfig类。 ImagePipelineConfig config = ImagePipelineConfig.newBuilder(context) .setBitmapMemoryCacheParamsSupplier(bitmapCacheParamsSupplier) .setCacheKeyFactory(cacheKeyFactory) .setEncodedMemoryCacheParamsSupplier(encodedCacheParamsSupplier) .setExecutorSupplier(executorSupplier) .setImageCacheStatsTracker(imageCacheStatsTracker) .setMainDiskCacheConfig(mainDiskCacheConfig) .setMemoryTrimmableRegistry(memoryTrimmableRegistry) .setNetworkFetchProducer(networkFetchProducer) .setPoolFactory(poolFactory) .setProgressiveJpegConfig(progressiveJpegConfig) .setRequestListeners(requestListeners) .setSmallImageDiskCacheConfig(smallImageDiskCacheConfig) .build(); Fresco.initialize(context, config); 理解Suppliers在上述参数配置中，很多都配置对应的Supplier的实例，而不是对应的实例。这样看起来可能会麻烦些，但会带来更多的收益，我们可以在程序运行中动态切换Fresco的行为。比如Memory caches，可以每5分钟检查其Supplier。 如果不需要动态调整这些参数，那么可设置Supplier每次返回都一个实例。 Supplier xSupplier = new Supplier () { public X get() { return new X(xparam1, xparam2...); } ); // when creating image pipeline .setXSupplier(xSupplier); 线程池默认情况下，Image pipeline使用3个线程池。 3个线程用于下载； 2个线程用于所有的disk操作：本地文件读取、disk cache相关 2个线程用于CPU敏感操作：decodes、transforms、后台操作 可通过设置自己的network layer来自定义网络的行为。 对于其他的修改，可通过设置ExecutorSupplier完成。 使用MemoryTrimmableRegistry如果我们的程序监听系统内存事件，那么可以将这些事件传递给Fresco以优化memory cache； 最简单的方法是覆写 Avtivity.onTrimMemory。也可以使用ComponmentCallbacks2的子类实现。 我们应当使用MemoryTrimableRegistry。该类用于保存MemoryTrimmable的实例-Fresco的cache也在其中。当接收到系统内存事件的时候，依次调用每个trimmable的MemoryTrimable方法。 配置memory cachesbitmap cache以及解码memory cache使用MemoryCacheParams中的Supplier配置。 配置disk cache使用构造者模式创建DiskCacheConfig实例： DiskCacheConfig diskCacheConfig = DiskCacheConfig.newBuilder() .set.... .set.... .build() // when building ImagePipelineConfig .setMainDiskCacheConfig(diskCacheConfig) 追踪Cache统计信息If you want to keep track of metrics like the cache hit rate, you can implement the ImageCacheStatsTracker class. This provides callbacks for every cache event that you can use to keep your own statistics. Caching总共三种CacheBitmap cachebitmap cache保存Android Bitmap对象。这里面的对象都已经解码完成，准备用于展示或者用于postprocess。 在Android 4.x或者更低的版本中，bitmap的cache数据放在ashmen heap，而不是Java heap中。这意味着这些图像并不需要运行额外的GC，避免降低app的运行速度。 Android 5.0中已经相比之前的版本对内存管理进行了很好的优化，所以将bitmap的cache数据放在Java heap中是合适的。 当app切换到背景之后，bitmap cache则会被清空。 Encoded memory cache此处Cache保存了原始的压缩的图像格式。此处的图像在展示之前必须首先解码才行。 如果需要其他的变换，比如resizing、rotating或者转码，那么这些操作在decode解码之前进行。 当app切换到背景之后，encoded memory cache也会被清空。 Disk cacheDisk cache即保存在local storage中的cache。 与Encoded Memory Cache一样，Disk cache中保存的也是压缩的图像，与encoded memory cache一样，图像在展示之前也必须解码。 与Bitmap cache/Encoded memory cache不同，在app切换到背景之后，Disk cache中的数据并不会被清空。用户可以在Android Setting界面中将这部分数据清除。 从cache中删除数据可以使用ImagePipeline中的方法从cache中清除单独的cache数据。 ImagePipeline imagePipeline = Fresco.getImagePipeline(); Uri uri; imagePipeline.evictFromMemoryCache(uri); imagePipeline.evictFromDiskCache(uri); // combines above two lines imagePipeline.evictFromCache(uri); evictFromDiskCache(Uri) 默认情况下假设使用的是默认的cache key factory。如果自定义了Cache Key，那么则需要调用 evictFromDiskCache(ImageRequest)方法。 清空cacheImagePipeline imagePipeline = Fresco.getImagePipeline(); imagePipeline.clearMemoryCaches(); imagePipeline.clearDiskCaches(); // combines above two lines imagePipeline.clearCaches(); 使用一个disk cache还是两个？大多数应用程序仅仅使用1个disk cache。但是在某些使用场景中，我们需要将尺寸的图片放在一个单独的cache中以避免由于cache中存放了过多的较大的尺寸的图片而迅速将cache填满，进而导致这小较小的图片从cache中被清楚。 为了实现这种思路，则在配置image pipeline中调用setMainDiskCacheConfig和setSmallImageDiskCacheConfig方法即可。 怎么定义什么叫small，小的图片？我们的程序自己定义，我们在构造一个image request的时候，设置其ImageType： ImageRequest request = ImageRequest.newBuilderWithSourceUri(uri) .setImageType(ImageType.SMALL) 如果我们仅仅需要1个cache，那么我们应该避免调用setSmallImageDiskCacheConfig。在这种情况下，pipeline会默认使用同一个cache，设置的ImageType并不会起作用。 调整caches - Trimming the caches当配置image pipeline的时候，我们可以设置每一个cache的最大空间。但是在某些场景下，我们仍然希望降低cache所占的空间。 Fresco的cache实现了DiskTrimmable或者MemoryTrimmable接口。这些接口中有钩子可以使得我们在app中压缩cache。 然后我们的程序则可以调用DiskTrimmableRegistry和MemoryTrimmableRegistry接口。 These objects must keep a list of trimmables. They must use app-specific logic to determine when memory or disk space must be preserved. They then notify the trimmable objects to carry out their trims. 直接使用Image Pipeline在大多数情况下，Image Pipeline不需要单独使用，大多数的APP上使用Drawee来处理与Fresco的交互即可。 由于内存使用的原因，在Fresco上直接使用image pipeline是比较困难的。Drawee可以自动追踪我们的图片是否需要在内存中存储。当不需要的时候，Fresco可以将图片自动转存，当需要的时候图片可以自动将图片重新加载到内存中。如果我们需要直接使用image pipeline，则需要手动处理这些逻辑。 image pipeline中返回的实例都是ClosableReference的包装类。Drawee在处理完成的时候会调用.close()方法。如果我们不是直接使用Drawee，那么也需要这样处理。 Java的GC会在图片out of scope的时候自动回收内存，但这样回收的太迟，而且GC的代价较高，而且对于较大的实例会导致较大的性能损失，尤其是对于Android 4.x即以下的版本中，Android没有单独的内存用于存储Bitmap，这会特别突出。 调用pipeline我们必须构建一个image request，然后将这个image request传递给ImagePipeline: ImagePipeline imagePipeline = Fresco.getImagePipeline(); DataSource &gt; dataSource = imagePipeline.fetchDecodedImage(imageRequest); 参考DataSource来看怎么从其中获取数据。 跳过解码如果不需要解码，而是直接保持其中压缩的格式，那么仅仅使用fetchEncodedImage即可： DataSource &gt; dataSource = imagePipeline.fetchEncodedImage(imageRequest); 直接使用bitmap cache中的数据与其他操作不同，bitmap cache的查找工作是直接在UI线程中执行的，如果Bitmap在内存中，那么可以直接获取使用： DataSource &gt; dataSource = imagePipeline.fetchImageFromBitmapCache(imageRequest); try { CloseableReference imageReference = dataSource.getResult(); if (imageReference != null) { try { CloseableImage image = imageReference.get(); // do something with the image } finally { CloseableReference.closeSafely(imageReference); } } } finally { dataSource.close(); } 注意，不要避免finally块中的调用dataSource.close()。 Prefetching对图片进行预取可以降低用户等待的时间，进而优化用户体验，但需要注意的是，这也是一种trade-off。预取图片会增加用户数据流量的使用，增加CPU和内存的使用。因此，对于大多数APP来说，不建议开启图片的预取。 尽管如此，image pipeline允许我们将图片提前预取至disk或者bitmap cache。这两种方案都会增加网络数据的使用，但是区别在于disk cache并不会对图片进行解码，因此其CPU的占用率更低。 预取至disk cache： imagePipeline.prefetchToDiskCache(imageRequest); 预取至bitmap cache中： imagePipeline.prefetchToBitmapCache(imageRequest); DataSources和DataSubscribersDataSource类似于Java的Future，用于异步返回计算结果。DataSource与Future不同的是，DataSource可以返回单个命令对于的一系列运算结果，而不仅仅是一个。 当提交了一个image request之后，image pipeline会返回一个data source。为了从其中获取运算结果，因此需要使用DataSourceSubScriber。 I just want a bitmap…如果我们向image request提交的请求仅仅decoded image - Android Bitmap，我们可以充分利用BaseBitmapDataSubscriber： dataSource.subscribe(new BaseBitmapDataSubscriber() { @Override public void onNewResultImpl(@Nullable Bitmap bitmap) { // You can use the bitmap in only limited ways // No need to do any cleanup. } @Override public void onFailureImpl(DataSource dataSource) { // No cleanup required here. } }, executor); 使用起来很简单，但有几个使用上需要注意的地方： 对于animated images 动画图像无法使用subscriber 不能将bitmap变量赋值给onNewResultImpl方法之外的任何变量。原因是，当subscriber执行完成之后，image pipeline则会复用bitmap并且释放内存。如果在其后绘制图片，则会导致应用程序崩溃并抛出IllegalStateException。 * 将Bimap传递给Android通知或者remote view是安全的。如果Android需要使用Bitmap并传递给系统调用，Fresco会将Bitmap数据在ashmem中复制一份数据。所以Fresco在这种情况下可以自动清理内存。 通用解决方案如果需要使用bitmap，那么不能直接使用Bitmap，可以通过cloaseable reference和BaseDataSubscriber： DataSubscriber dataSubscriber = new BaseDataSubscriber &gt;() { @Override public void onNewResultImpl( DataSource &gt; dataSource) { if (!dataSource.isFinished()) { FLog.v(&quot;Not yet finished - this is just another progressive scan.&quot;); } CloseableReference imageReference = dataSource.getResult(); if (imageReference != null) { try { CloseableImage image = imageReference.get(); // do something with the image } finally { imageReference.close(); } } } @Override public void onFailureImpl(DataSource dataSource) { Throwable throwable = dataSource.getFailureCause(); // handle failure } }; dataSource.subscribe(dataSubscriber, executor); If you want to deviate from the example above and assign the CloseableReference to another variable somewhere else, you can. Just be sure to follow the rules. Closeable References大多数的应用程序进需要使用Drawee即可，而且不需要担心Drawee关闭的问题。 由于Java是支持垃圾回收的编程语言，因此大多数开发者都是任意创建对象，并且理所当然的认为这些对象最后都会从内存中释放。 但实际上，在Android 5.0以上，这种情况才算得上理想，因此在之前的版本中，这种方法并不适合处理Bitmaps。在Android 5.0以前的版本中，Bitmap会占用APP共享内存中的一大部分，由于Bitmap的存在，会大大增加系统GC的频率，降低程序的执行效果。 Bitmap的问题，使得开发者更加思念C++以及其智能指针，比如Boost。 Fresco的解决方案是CloseableReference类。为了保证能够正确的使用CloseableReference，必须遵守以下的规则： 调用者拥有CloseableReference的引用。 比如，此处我们创建了一个CloseableReference引用，但由于我们将其传递你给caller，因此该CloseableReference引用的所有权移交给该caller： CloseableReference foo() { Val val; return CloseableReference.of(val);} 引用的所有者在使用完CloseableReference引用之后，必须调用close方法释放该引用。 例子中，我们创建了一个CloseableReference引用，但是没有将其给传递给调用者，因此我们必须手动关闭该引用。 void gee() { CloseableReference ref = foo(); try { haa(ref); } finally { ref.close(); } } 一般而言，finally块最适合完成该操作。 其他的，除了CloseableReference引用的所有者之外的，其他代码不能关闭引用。 例子中，我们从参数中获取到一个CloseableReference引用。但caller仍然是其所有者，因此我们不能调用对应的close方法。 void haa(CloseableReference ref) { Log.println(“Haa: “ + ref.get());} 在赋值之前，要记得调用clone方法复制CloseableReference引用。 如果需要保持CloseableReference引用，需要调用clone方法： class MyClass { CloseableReference myValRef; void mmm(CloseableReference ref) { myValRef = ref.clone(); }; // caller can now safely close its copy as we made our own clone. void close() { CloseableReference.closeSafely(myValRef); }}// Now the caller of MyClass must close it! 如果在内部类中使用该CloseableReference引用： void haa(CloseableReference ref) { final CloseableReference refClone = ref.clone(); executor.submit(new Runnable() { public void run() { try { Log.println(&quot;Haa Async: &quot; + refClone.get()); } finally { refClone.close(); } } }); // caller can now safely close its copy as we made our own clone. }","categories":[{"name":"Fresco","slug":"Fresco","permalink":"http://yoursite.com/categories/Fresco/"}],"tags":[]},{"title":"EventBus源代码解析：2、消息的发布与处理","slug":"android-eventbus-1-publish-process","date":"2014-12-17T09:20:07.000Z","updated":"2018-10-03T15:30:53.297Z","comments":true,"path":"2014/12/17/android-eventbus-1-publish-process/","link":"","permalink":"http://yoursite.com/2014/12/17/android-eventbus-1-publish-process/","excerpt":"","text":"在上一篇文章《EventBus源代码解析：1、初始化与订阅者注册》当中，我们主要分析了两个事情： EventBus初始化 订阅者的注册 我们通过分析，EventBus在初始化的时候，初始化了几个集合，分别用来根据EventType和Event Handler所在的类索引对应的Handler方法；并且也同时初始化了用于不同ThreadMode的Poster。订阅者在注册的时候，EventBus会解析要注册的类，分析其所有的方法，从中找出Event的Handler方法(即public修饰的以onEvent开头)，然后根据EventType保存到相应的List中。 但我们一直没有分析到一个分析，那就是，EventBus到底是如何去Post消息的呢？接下来我们就去分析这个问题。按照我们的老套路，还是从最常用的代码入手： 12MessageEvent event = new MessageEvent(System.currentTimeMillis(), \"Message Sequence \" + mSequence.getAndIncrement());EventBus.getDefault().post(event); 这个代码主要分为两步，第一步是构建了一个需要处理的Event即MessageEvent，根据我们之前的分析，在我们调用register()方法的时候，EventBus会解析并将MessageBus作为key保存在一个HashMap中。通过调用EventBus.getDefault().post(event)方法，EventBus会自动调用我们的onEvent方法，我们这里的实现如下： 12345678910// Called in Android UI's main threadpublic void onEventMainThread(MessageEvent event) &#123; mMessages.add(\"onEventMainThread Receive : \" + event); mAdapter.notifyDataSetChanged();&#125; public void onEvent(MessageEvent event) &#123; Log.i(TAG, \"Thread name : \" + Thread.currentThread().getName()); mHandler.obtainMessage(MESSAGE\\_WHAT\\_MESSAGEEVENT, event).sendToTarget();&#125; 那这一个过程当中，EventBus都做了哪些事情呢？我们先来看看post()方法的源代码： post(Object event)1234567891011121314151617181920212223242526272829public void post(Object event) &#123; // 获取当前线程(调用post方法的线程)中的一个PostingThreadState实例 PostingThreadState postingState = currentPostingThreadState.get(); // 获取当前线程(调用post方法的线程)中的EventQueue List&lt;Object&gt; eventQueue = postingState.eventQueue; // 将Event添加到队列当中 eventQueue.add(event); // 如果当前线程(调用post方法的线程)没有在发布Event if (!postingState.isPosting) &#123; // 判断调用者是否工作在主线程上 postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); // 设置标志，正在发布Event postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException(\"Internal error. Abort state was not reset\"); &#125; try &#123; // 依次发送，直至eventQueue为空为止 while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125;&#125; 我们依次来分析每行代码的作用： PostingThreadState postingState = currentPostingThreadState.get(); 这一行代码中，有一个PostingThreadState的定义，我们首先要搞明白PostingThreadState到底是怎么回事？ 123456789101112131415/\\*\\* For ThreadLocal, much faster to set (and get multiple values). */final static class PostingThreadState &#123; // eventQueue final List&lt;Object&gt; eventQueue = new ArrayList&lt;Object&gt;(); // 标志：正在发布？ boolean isPosting; // 标志：是主线程？ boolean isMainThread; // 订阅者 Subscription subscription; // Event Object event; // 已经取消 boolean canceled;&#125; 我们可以看到，原来这是一个静态不可变类，按照作者的描述，该类的作用用来提高性能，用于ThreadLocal，可以更快的去设置获取读取多个值。等下ThreadLocal在哪里呢？我们继续看， 123456private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123; @Override protected PostingThreadState initialValue() &#123; return new PostingThreadState(); &#125;&#125;; 这是currentPostingThreadState的定义，我们可以看到，currentPostingThreadState定义为一个ThreadLocal对象，其内容是PostingThreadState对象，可以看到其中的initialValue()方法返回了一个新的PostingThreadState()对象，这是什么意思呢？换句话每当从一个线程调用currentPostingThreadState.get()方法的时候，系统会检查当前线程是否有一份PostingThreadState实例，如果没有则新建一个，再换句话说，每一个线程中都有其独一无二的一个PostingThreadState实例。那这个用来做什么呢？我们继续分析。 List eventQueue = postingState.eventQueue; 这一行代码就比较有意思，post方法从postingState中获取了一个eventQueue，我们再回到刚刚去看一下PostingThreadState中关于eventQueue的定义 1final List&lt;Object&gt; eventQueue = new ArrayList&lt;Object&gt;(); 可以看到，每一个新的PostingThreadState对象中都有自己的一个eventQueue对象，并单独指向一个ArrayList，什么意思呢？我们可以明白，每个线程中都有自己的一份PostingThreadState拷贝，那么换言之，每一个线程中，同样有这样一个自己专属的eventQueue。也就是说代码List eventQueue = postingState.eventQueue;其实是获取了当前线程中的对应的eventQueue。(注意哦，EventBus中所有线程中消息的发送都是可以通过这个post方法实现的) eventQueue.add(event); 这段代码就相当简单了，将event添加到自己所在线程的eventQueue当中。 继续往下看，发现是一个判断 1if (!postingState.isPosting) 那么我们就根据分支来分析： ture:也就是说postingState.isPosting=false;也就是说，当前的线程没有在发布event，则进入以下的流程：12345678910111213postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();postingState.isPosting = true;if (postingState.canceled) &#123; throw new EventBusException(\"Internal error. Abort state was not reset\");&#125;try &#123; while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125;&#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false;&#125; 我们来分析下，这里面都做了什么的工作呢？ 1. 首先会先判断当前的线程是否是在UI线程上，为什么要判断呢？什么这个还要问吗？UI线程不能做太多事情当然要小心处理啊！！！所以通过代码 1Looper.getMainLooper() == Looper.myLooper() 来了解。 2. 然后呢？判断当前的线程是否已经canceled，也就是当前的线程是否已经unregistered了，这个容易理解，不去细细分析。 3. 然后进入一个while循环 123while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState);&#125; 这个代码也很明了啊，就是不断的通过postSingleEvent发送Event直至队列尾空为止。 2. false：哦，这里应该写另外分支要做的事情，额，如果当前的线程正在发送，那么就不去做任何事情了，等待上一次的while循环处理就好。 所以，通过上面的分析，我们发现最终代码还是进入1postSingleEvent(eventQueue.remove(0), postingState); 对所有的消息进行发送处理，那我们继续分析一下这一个方法就好了。 private void postSingleEvent(Object event, PostingThreadState postingState) throws Error首先看源代码：123456789101112131415161718192021222324252627282930// 发送单个的Eventprivate void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; // 获取event的类 Class&lt;?&gt; eventClass = event.getClass(); // 标记，用来表示是否已经找到event对应的订阅者 boolean subscriptionFound = false; // 判断event是否开启继承？ if (eventInheritance) &#123; // 查找Event对应的所有的event类型（包括父类和接口）。 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; // 获取其中的一个Event类型(Event对应的类或者其父类或者其实现的接口的一种) Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; // 如果没有开启Event继承，则直接根据Event的类型，在指定的线程中发送Event即可。 subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; Log.d(TAG, \"No subscribers registered for event \" + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; post(new NoSubscriberEvent(this, event)); &#125; &#125;&#125; 其实我们大体上一看就知道，这段代码也并没有执行具体的消息发送，但做了很必要的预处理工作，那都有哪些工作呢？我已经在程序里面加了很多注释了，我们可以很容易的发现，其实关键的代码在里面的那个if..else…分支语句里面，我们来依次来看看。 12345678910111213if (eventInheritance) &#123; // 查找Event对应的所有的event类型（包括父类和接口）。 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; // 获取其中的一个Event类型(Event对应的类或者其父类或者其实现的接口的一种) Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125;&#125; else &#123; // 如果没有开启Event继承，则直接根据Event的类型，在指定的线程中发送Event即可。 subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);&#125; 两个分支有什么不同呢？eventInheritance表示用户是否开启Event继承，如果不开启，则通过 postSingleEventForEventType(event, postingState, eventClass); 方法发送Event，如果开启，则首先通过 lookupAllEventTypes(eventClass); 查找event类所有的Event类型，然后依次通过代码 postSingleEventForEventType(event, postingState, eventClass); 进行消息处理，所以，我们分两步来，首先来看看lookupAllEventTypes的代码。 private List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass)12345678910111213141516private List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123; synchronized (eventTypesCache) &#123; List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass); if (eventTypes == null) &#123; eventTypes = new ArrayList&lt;Class&lt;?&gt;&gt;(); Class&lt;?&gt; clazz = eventClass; while (clazz != null) &#123; eventTypes.add(clazz); addInterfaces(eventTypes, clazz.getInterfaces()); clazz = clazz.getSuperclass(); &#125; eventTypesCache.put(eventClass, eventTypes); &#125; return eventTypes; &#125;&#125; 其实这个代码并不负责，简单的理解就是根据Event类查找其父类，然后添加到eventTypesCache里面。那另外一个函数干什么的呢？其实真正的工作都在postSingleEventForEventType(event, postingState, clazz);里面，我们去看看。 private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)12345678910111213141516171819202122232425262728293031private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; // 根据Event类型获取其对应的订阅者。 subscriptions = subscriptionsByEventType.get(eventClass); &#125; // 如果存在订阅者 if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; // 依次发送给对应的订阅者 for (Subscription subscription : subscriptions) &#123; // 设置post()方法调用线程中对应的postingState postingState.event = event; postingState.subscription = subscription; boolean aborted = false; try &#123; // 将event发送给对应的订阅者。 postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; if (aborted) &#123; break; &#125; &#125; return true; &#125; return false;&#125; 什么？我们再一看，好吧，这个代码也没有去真正的发送消息，那我们看看这个方法到底做了什么工作呢？ subscriptions = subscriptionsByEventType.get(eventClass);首先通过这行代码，从subscriptionsByEventType中，根据Event的类，获取所有的对应的subscriptions，需要注意的是，此段代码使用EventBus的实例进行同步，实际上是同步的订阅者的List 如果subscriptions==null 或者 subscriptions.size()==0，即如果不存在对应的subscriptions，那么则返回即可。 将Event依次发送给每一个Subscription 设置postingState.event = event，设置postingState.subscription = subscription； 调用方法postToSubscription(subscription, event, postingState.isMainThread);发送消息 恢复postingState默认状态为null 重复步骤3 可以看到，真正发送消息的工作还没有看到，在postToSubscription方法当中，好吧，那我们继续来学习这个方法都做了什么？ postToSubscription源代码如下：12345678910111213141516171819202122232425262728293031323334// 将event发送给对应的调用者private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case PostThread: // 直接调用 invokeSubscriber(subscription, event); break; case MainThread: if (isMainThread) &#123; // 如果post的发送线程是UI线程，那么则直接调用对应的方法即可 invokeSubscriber(subscription, event); &#125; else &#123; // 否则则发送到main线程中对应的Handler中 mainThreadPoster.enqueue(subscription, event); &#125; break; case BackgroundThread: // 背景线程 if (isMainThread) &#123; // 如果当前工作在主线程，则直接压入背景Poster的队列 backgroundPoster.enqueue(subscription, event); &#125; else &#123; // 反之则直接调用 invokeSubscriber(subscription, event); &#125; break; case Async: //直接压入异步Poster的队列 asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode); &#125;&#125; 可以看到，这里是最终的调用订阅者Event处理方法的地方，针对ThreadMode的不同，postToSubscription方法采取了不同的策略 PostThread：这个是直接在当前线程上调用处理的方法，所以直接通过invokeSubscriber(subscription, event);调用对应的方法 MainThread： 当前在主线程上：同PostThread一样，直接通过invokeSubscriber(subscription, event);反射调用对应的方法 不在主线程上，则通过mainThreadPoster.enqueue(subscription, event);将Event压入队列等待处理 BackgroundThread： 当前在主线程上：通过backgroundPoster.enqueue(subscription, event);将Event压入队列，等待处理 当前不在主线程上：通过invokeSubscriber(subscription, event);反射调用对应的方法 Async:直接将Event压入队列asyncPoster.enqueue(subscription, event); 好了，到这里，我们基本上明白了Event在EventBus中数据是怎么传递的了，但每一个ThreadMode不同的处理方法我们还没有看，到底是怎么样的呢？ invokeSubscriber(Subscription subscription, Object event) 源代码123456789 try &#123; // 使用反射机制，调用对应的事件处理函数。 subscription.subscriberMethod.method.invoke(subscription.subscriber, event); &#125; catch (InvocationTargetException e) &#123; handleSubscriberException(subscription, event, e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new IllegalStateException(\"Unexpected exception\", e); &#125;&#125; 这个地方的代码比较简单了，其实就是将反射的调用包装了一下，不需要多说。 我们先来看一下MainThread的时候，其Poster的处理办法： HandlerPoster123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/\\* \\* Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de) \\* \\* Licensed under the Apache License, Version 2.0 (the \"License\"); \\* you may not use this file except in compliance with the License. \\* You may obtain a copy of the License at \\* \\* http://www.apache.org/licenses/LICENSE-2.0 \\* \\* Unless required by applicable law or agreed to in writing, software \\* distributed under the License is distributed on an \"AS IS\" BASIS, \\* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \\* See the License for the specific language governing permissions and \\* limitations under the License. */package de.greenrobot.event;import android.os.Handler;import android.os.Looper;import android.os.Message;import android.os.SystemClock;/\\*\\* \\* 主线程Poster，本质上为一个Handler * */final class HandlerPoster extends Handler &#123; // 维护一个PendingPostQueue的队列 private final PendingPostQueue queue; // 不太懂 private final int maxMillisInsideHandleMessage; // EventBus对象 private final EventBus eventBus; // 标记本Handler是否空闲：true：忙，false：空闲 private boolean handlerActive; HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) &#123; super(looper); this.eventBus = eventBus; this.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage; queue = new PendingPostQueue(); &#125; // 入队列 void enqueue(Subscription subscription, Object event) &#123; // 获取一个PendingPost PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; // 将pendingPost放入queue队列当中 queue.enqueue(pendingPost); // 发送消息 if (!handlerActive) &#123; handlerActive = true; // 通过Handler中的MessageQueue，将通知工作在某个线程(可能是main Thread，post thread,background thread,asnyc thread)处理消息 if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(\"Could not send handler message\"); &#125; &#125; &#125; &#125; // 消息的处理，需要注意的是，该函数段是工作在Looper对应的线程之上的。 // 有个问题，如果event很快处理完成，那么这个时候是不需要rescheduled的，那么如果在该event处理过程当中，已经放入其他的消息，那么这个消息会在什么时候得到处理呢？ @Override public void handleMessage(Message msg) &#123; boolean rescheduled = false; try &#123; // 记录开始时间 long started = SystemClock.uptimeMillis(); while (true) &#123; // 从等待处理的队列当中获取一个PendingPost PendingPost pendingPost = queue.poll(); // 判断获取到的pendingPost是否为null，如果null则是没有需要处理的event if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized // 再次处理，需要注意的是，该方法是同步的，跟谁同步的呢？是跟enqueue方法中的代码块同步，做什么用呢？ // 我理解的是，此处的代码主要是用于避免一种现象的发生，就是上面已经给Handler发送消息，但并未处理的时候。---&gt; 但貌似又不是 // 这次是对的：就是等待前面的enqueue函数执行完成，以便于从中获取event进行处理，如果此时仍然为空，说明队列是空的，标记handlerActive为空， // 这样的话，下次enqueue的时候，就可以直接通过sendMessage通知Handler立刻进行处理。 pendingPost = queue.poll(); // 如果再次从中获取数据，但为空，则说明handler不是Activie的了。 if (pendingPost == null) &#123; // 标记handler已经空闲 handlerActive = false; return; &#125; &#125; &#125; // eventBus调用订阅者的对应的方法 eventBus.invokeSubscriber(pendingPost); // 工作做完，统计消耗时间 long timeInMethod = SystemClock.uptimeMillis() - started; // 超时 if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123; // 立刻尝试处理下一个消息 if (!sendMessage(obtainMessage())) &#123; throw new EventBusException(\"Could not send handler message\"); &#125; // 设置标记 rescheduled = true; return; &#125; &#125; &#125; finally &#123; // 如果已经rescheduled，那么说明此时该handler已经在忙，否则则说明handler已经空闲。 handlerActive = rescheduled; &#125; &#125;&#125; 上面是我添加过注释的源代码，我们可以发现以下的特点： 主线程的Poster本质上是一个Handler，因此关键的一点就是，看Handler到底工作在哪个Looper上，通过EventBus的默认初始化代码 mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); 可以发现，其实主线程上的Poster就是一个工作在主线程上的Handler，那么剩下的就比较简单了。 enqueue，入队列，其实就做了以下的事情： 同步保护，防止从多个线程同时发送消息的时候出现错误 queue.enqueue(pendingPost);将需要处理的PendingPost压入队列 通过sendMessage(obtainMessage())将消息发送给Handler进行处理 handleMessage(Message msg)：消息处理的方法 pendingPost = queue.poll();获取数据，如果为null，那么意味着没有数据可以处理，标记当前活动状态为false，那么下一次enqueue入列的时候，就可以直接通知handler进行数据处理 获取成功，则通过eventBus.invokeSubscriber(pendingPost);调用相应的方法进行处理 如果此次消息处理超时，则直接通过sendMessage(obtainMessage())进行下一次消息处理 BackgroundPoster源代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/\\* \\* Copyright (C) 2012 Markus Junginger, greenrobot (http://greenrobot.de) \\* \\* Licensed under the Apache License, Version 2.0 (the \"License\"); \\* you may not use this file except in compliance with the License. \\* You may obtain a copy of the License at \\* \\* http://www.apache.org/licenses/LICENSE-2.0 \\* \\* Unless required by applicable law or agreed to in writing, software \\* distributed under the License is distributed on an \"AS IS\" BASIS, \\* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \\* See the License for the specific language governing permissions and \\* limitations under the License. */package de.greenrobot.event;import android.util.Log;/\\*\\* \\* Posts events in background. \\* 在后台线程当中处理events \\* @author Markus */final class BackgroundPoster implements Runnable &#123; // 一个保存有PendingPost的队列 private final PendingPostQueue queue; // 保持对EventBus的引用 private final EventBus eventBus; // 看现在的BackgroundPoster是否正在处理event private volatile boolean executorRunning; BackgroundPoster(EventBus eventBus) &#123; this.eventBus = eventBus; queue = new PendingPostQueue(); &#125; public void enqueue(Subscription subscription, Object event) &#123; // 根据subscription和event构建PendingPost PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; // 将构建好的PendingPost加入到队列。 queue.enqueue(pendingPost); if (!executorRunning) &#123; // 如果当前队列空闲，则设置其为忙，并通过EventBus的线程池执行该线程 executorRunning = true; eventBus.getExecutorService().execute(this); &#125; &#125; &#125; @Override public void run() &#123; try &#123; try &#123; while (true) &#123; // 阻塞方法，从PendignPostQueue中获取一个PendingPost PendingPost pendingPost = queue.poll(1000); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized // 原理同我们之前分析的mainPoster一样的，都是防止在加入的时候尝试取PendignPost而取不到， // 代码到这里的时候，则保证如果要加入队列，工作已经完成的。 pendingPost = queue.poll(); if (pendingPost == null) &#123; executorRunning = false; return; &#125; &#125; &#125; // 调用对应的订阅者方法 eventBus.invokeSubscriber(pendingPost); &#125; &#125; catch (InterruptedException e) &#123; Log.w(\"Event\", Thread.currentThread().getName() + \" was interruppted\", e); &#125; &#125; finally &#123; // 此时说明没有工作可做，因此释放该线程完成工作，设置标记为false。 executorRunning = false; &#125; &#125;&#125; 通过比较和Poster代码，发现其实现的原理不一样，但大体的机制基本一直：所有的Event都是缓存在PendingPostQueue当中，当enqueue的时候入队列，然后不同ThreadMode的Poster会以不同的方式处理相应的Event。 BackgroundPoster的Event的入列方式： 将PendingPost加入到队列当中 判断如果当前的executorRunning==false，即当前BackgroundPoster没有线程在处理 设置标记executorRunning=true 将该线程提交给EventBus默认的ExecutorService进行处理 BackgroundPoster的Event的处理方式的几个特点： 当开启一个BackgroundPoster之后，会一直处理所有的PendignPost直至所有的全部处理完成。 当使用queue.poll(1000)获取PendignPost，仍然没有取回之后，会进入同步保护块(避免此时有新的PendignPost加入队列，但该线程看不到)，再次尝试，如果依然没有PendingPost，说明此时没有Event通过BackgroundPoster进行处理，线程可以安全退出。 此时，我们再来回顾使用EventBus中，关于BackgroundPoster的几个说明： BackgroundPoster只会顺序对Event进行处理，因此不适合并发的情况。 对比看完了BackgroundPoster，还需要继续学习一下AsyncPoster的使用 AsyncPoster1234567891011121314151617181920212223242526272829class AsyncPoster implements Runnable &#123; private final PendingPostQueue queue; private final EventBus eventBus; AsyncPoster(EventBus eventBus) &#123; this.eventBus = eventBus; queue = new PendingPostQueue(); &#125; public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); queue.enqueue(pendingPost); // 与mainPoster和backgroundPoster相比，直接将PendingPost执行 eventBus.getExecutorService().execute(this); &#125; @Override public void run() &#123; // 获取需要处理的PendingPost PendingPost pendingPost = queue.poll(); if(pendingPost == null) &#123; throw new IllegalStateException(\"No pending post available\"); &#125; // 调用相应的订阅者方法 eventBus.invokeSubscriber(pendingPost); &#125;&#125; 一对比，发现跟BackgroundPoster有两点有区别： 入队列的时候，会直接将线程提交给ExecutorService()进行处理，不需要检查当前是否有AsyncPoster任务在执行 每一个AsyncPoster任务只负责一个PendignPostQueue的处理。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"EventBus","slug":"Android/EventBus","permalink":"http://yoursite.com/categories/Android/EventBus/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"EventBus","slug":"EventBus","permalink":"http://yoursite.com/tags/EventBus/"}]},{"title":"EventBus源代码解析：1、初始化与订阅者注册","slug":"android-eventbus-1-initialization-register","date":"2014-12-16T14:32:44.000Z","updated":"2018-10-03T16:12:52.603Z","comments":true,"path":"2014/12/16/android-eventbus-1-initialization-register/","link":"","permalink":"http://yoursite.com/2014/12/16/android-eventbus-1-initialization-register/","excerpt":"","text":"和以前一样，我们同样从我们最经常使用的代码入手，分析EventBus到底是如何进行工作的。所以，第一步，我们先分析EventBus的初始化代码，看看初始化代码当中，都做了哪些工作？ 一：初始化单例模式12345678910public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance;&#125; 首先，我们最经常使用的EventBus的默认配置，其实就是一个我们常用的单例模式： 首先尝试获取defaultInstance，如果defaultInstance为null，说明默认的EventBus还没有初始化，因此接下来的工作就是需要对EventBus进行初始化。 此时，为了同一个时刻只有一个EventBus在初始化，也是为了避免多个线程同时访问的时候，各自生成了不同的EventBus对象，因此我们需要对初始化的代码块进行同步。当然同步的范围选择很重要，同步的范围必须是所有的线程都能够同时看到，因此选用了EventBus的类对象作为同步代码块的同步对象。 此时，由于进入到同步代码块之后，可能是由于和其他线程竞争，但没有竞争过，那么此时的时候，很有可能其他线程当中已经将EventBus初始化完成了，所以此时需要再次检查EventBus有没有初始化好，没有的话，说明是第一次进行初始化，那进行初始化工作就可以。 返回唯一的EventBus对象defaultInstance。 具体的初始化工作构造函数：123public EventBus() &#123; this(DEFAULT_BUILDER); &#125; 构造函数非常简单，调用了另外的构造函数EventBus(EventBusBuilder builder)实现功能，我们还是需要看看这个构造函数中，都做了哪些工作？ 1234567891011121314151617181920212223EventBus(EventBusBuilder builder) &#123; // 订阅者们，根据Event类型分类：Key是订阅者的类，Value为对应的订阅者 subscriptionsByEventType = new HashMap&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt;(); // 订阅者所支持的Event类型 typesBySubscriber = new HashMap&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt;(); // 保存Sticky Events，注意，这个地方用的是一个线程安全的HashMap stickyEvents = new ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;(); // 主线程的Poster mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); // 后台线程的Poster backgroundPoster = new BackgroundPoster(this); // 异步的Poster asyncPoster = new AsyncPoster(this); // 订阅者方法寻找器 subscriberMethodFinder = new SubscriberMethodFinder(builder.skipMethodVerificationForClasses); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; eventInheritance = builder.eventInheritance; executorService = builder.executorService;&#125; 初始化了以下的队列 subscriptionsByEventType：Event的类型作为Key的HashMap，需要注意的是，其中用到了一个CopyOnWriteArrayList，当列表中的元素，其读取次数远远超过写入次数的时候，使用该集合类可以大大提高效率，且该类是线程同步保护的。 typesBySubscriber：同样的一个HashMap，保存了某一个订阅者当中所支持的消息类型。有个细节可以注意到，这个地方HashMap的Key是List&lt;Class&lt;?&gt;&gt;，而subscriptionsByEvent中的Key是指定了OnWriteArrayList&gt;，这其中有什么技巧吗？我的理解是这个样子的： 从调用的次数上来考虑，当我们POST一个event的时候，按照我们的常规思路，EventBus就应该根据Event的类型，也就是类去找到那些能够处理这个Event的Subcription，那么这些Subcriptions保存在哪里呢？–&gt;CopyOnWriteArrayList。所以对于这一个列表来说，我们很少回去改动其中的元素，除非有新的Subcription注册。但另外一个，还没想到做什么使用，可能是注销的时候依次注销所注册的订阅者？ stickyEvents：保存stickey的Events，需要注意的是，这里面用到的都是ConcurrentHashMap，是线程安全的。 初始化了以下的Poster（后面会依次分析几种Poster的不同实现） mainThreadPoster：通过运行在main线程上的Handler实现 backgroundPoster：本质上为一个Runnable asyncPoster：本质上同样为一个Runnable 注册了一个subscriberMethodFinder：即查找订阅者类当中对应的Handler方法 初始化了各种参数：需要注意的是，其中有一个executorService，其默认实现为 private final static ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool(); 后面我们还看到，很多消息的Post都是通过该线程池实现。 上面，我们分析完成EventBus的初始化工作，下面我们继续来分析一下我们在代码中向EventBus注册订阅者的时候，都发生了什么事情？ 二、订阅者注册1、注册：我们一般情况下，使用的注册代码是： 1register(Object subscriber) 跟踪代码，发现该代码实际上通过调用resiter(Object subscriber, boolean sticky, int priority)实现，我们来看看这段代码都做了哪些工作？ 12345678private synchronized void register(Object subscriber, boolean sticky, int priority) &#123; // 查找订阅类当中的处理方法（包括其父类的方法） List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriber.getClass()); // 根据获取的订阅者方法，将其依次订阅 for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod, sticky, priority); &#125; &#125; 上面的代码主要做了两件事情： 从对应的subscriber类中查找到所有的SubscriberMethod 依次订阅所有的SubscriberMethod SubscriberMethod源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; // 获取类的全名作为key String key = subscriberClass.getName(); // 订阅者方法列表 List&lt;SubscriberMethod&gt; subscriberMethods; // 尝试从methodCache中获取订阅者方法 synchronized (methodCache) &#123; subscriberMethods = methodCache.get(key); &#125; // 如果订阅者方法列表已经存在，则直接返回 if (subscriberMethods != null) &#123; return subscriberMethods; &#125; subscriberMethods = new ArrayList&lt;SubscriberMethod&gt;(); Class&lt;?&gt; clazz = subscriberClass; HashSet&lt;String&gt; eventTypesFound = new HashSet&lt;String&gt;(); StringBuilder methodKeyBuilder = new StringBuilder(); while (clazz != null) &#123; String name = clazz.getName(); // 如果这些类是java，javax或者android的话，则直接跳过。 if (name.startsWith(\"java.\") || name.startsWith(\"javax.\") || name.startsWith(\"android.\")) &#123; // Skip system classes, this just degrades performance break; &#125; // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again) // 从EventBus2.2开始，强制必须将修饰符设置为public Method\\[\\] methods = clazz.getDeclaredMethods(); // 依次遍历类的全部方法 for (Method method : methods) &#123; // 获取方法名 String methodName = method.getName(); // 判断方法名是否以ON\\_EVENT\\_METHOD_NAME，即是否以\"onEvent\"开头 if (methodName.startsWith(ON\\_EVENT\\_METHOD_NAME)) &#123; // 获取方法的修饰符 int modifiers = method.getModifiers(); // 要求方法匹配public修饰符，并且不是(Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC)中任一种 if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; // 获取参数的类型 Class&lt;?&gt;\\[\\] parameterTypes = method.getParameterTypes(); // 如果参数的类型只有一种，也就是说，参数只有一个 if (parameterTypes.length == 1) &#123; // 获取方法名当中去掉onEvent剩下的部分，并根据这一部分判断其工作在哪个县城之上 String modifierString = methodName.substring(ON\\_EVENT\\_METHOD_NAME.length()); ThreadMode threadMode; if (modifierString.length() == 0) &#123; // PostThread threadMode = ThreadMode.PostThread; &#125; else if (modifierString.equals(\"MainThread\")) &#123; // MainThread threadMode = ThreadMode.MainThread; &#125; else if (modifierString.equals(\"BackgroundThread\")) &#123; // BackgroundThread threadMode = ThreadMode.BackgroundThread; &#125; else if (modifierString.equals(\"Async\")) &#123; // AsyncThread threadMode = ThreadMode.Async; &#125; else &#123; if (skipMethodVerificationForClasses.containsKey(clazz)) &#123; continue; &#125; else &#123; throw new EventBusException(\"Illegal onEvent method, check for typos: \" + method); &#125; &#125; // 获取订阅者处理方法onEvent方法的参数类型 Class&lt;?&gt; eventType = parameterTypes\\[0\\]; methodKeyBuilder.setLength(0); // 添加方法名 methodKeyBuilder.append(methodName); // 添加方法类型 methodKeyBuilder.append('&gt;').append(eventType.getName()); String methodKey = methodKeyBuilder.toString(); // 将methodKey添加到eventTypesFound当中 true:说明该方法没有被添加过，false:说明该方法已经被添加过 if (eventTypesFound.add(methodKey)) &#123; // Only add if not already found in a sub class // 如果methodKey在子类当中没有被添加过，则构造SubscriberMethod，并添加到subscriberMethods当中 subscriberMethods.add(new SubscriberMethod(method, threadMode, eventType)); &#125; &#125; &#125; else if (!skipMethodVerificationForClasses.containsKey(clazz)) &#123; Log.d(EventBus.TAG, \"Skipping method (not public, static or abstract): \" + clazz + \".\" \\+ methodName); &#125; &#125; &#125; // 该类处理完成，继续处理其父类！！！ clazz = clazz.getSuperclass(); &#125; // 如果该类或者其父类当中不包含订阅者方法，那么则抛出异常 if (subscriberMethods.isEmpty()) &#123; throw new EventBusException(\"Subscriber \" + subscriberClass + \" has no public methods called \" \\+ ON\\_EVENT\\_METHOD_NAME); &#125; else &#123; // 该类或者其父类当中，包含订阅者方法，则将其添加到methodCache当中 synchronized (methodCache) &#123; methodCache.put(key, subscriberMethods); &#125; return subscriberMethods; &#125;&#125; SubscriberMethod方法的程序流程图： 简单的理解， findSubscriberMethods的工作就依次遍历指定类中的所有方法，从中找到EventBus的handler并将其添加到subscriberMethods集合当中。具体的步骤如下： 首先判断clazz类以否是java/javax/android的类，如果是，则说明这个类并不是我们的订阅者(可能是订阅者的父类，不需要处理)。 然后遍历类中所有的方法，首先挑选出其中以onEvent开头的方法，继续判断是否是我们的Event处理方法。 判断该方法的修饰符，要求方法匹配public修饰符，并且不是(Modifier.ABSTRACT | Modifier.STATIC | BRIDGE | SYNTHETIC)中任一种。 获取onEvent方法的参数类型，即要处理的Event的类型。 构建SubscriberMethod对象，并添加到subscriberMethods 获取clazz的父类，重复步骤1-6 subscribe代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Must be called in synchronized block// 必须要在同步快中执行private void subscribe(Object subscriber, SubscriberMethod subscriberMethod, boolean sticky, int priority) &#123; // 获取订阅者处理方法的参数类型，即Event事件的类型 Class&lt;?&gt; eventType = subscriberMethod.eventType; // 根据类型尝试从subscriptionsByEventType中获取参数类型，即Event事件类型所对应的订阅者列表。 CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); // 生成新的订阅者对象 Subscription newSubscription = new Subscription(subscriber, subscriberMethod, priority); // 如果订阅者列表为null，则说明是头一次添加该Event类型。 if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;Subscription&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \" \\+ eventType); &#125; &#125; // Starting with EventBus 2.2 we enforced methods to be public (might change with annotations again) // subscriberMethod.method.setAccessible(true); // 从EventBus2.2之后，设置方法必须为public // subscriberMethod.method.setAccessible(true); int size = subscriptions.size(); // 根据优先级，将包含订阅者处理方法的订阅者对象添加到队列的合适位置上 for (int i = 0; i &lt;= size; i++) &#123; if (i == size || newSubscription.priority &gt; subscriptions.get(i).priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; // 保存订阅者类所能够处理的EventType List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;Class&lt;?&gt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); // 如果Event设置为sticky if (sticky) &#123; Object stickyEvent; synchronized (stickyEvents) &#123; stickyEvent = stickyEvents.get(eventType); &#125; if (stickyEvent != null) &#123; // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state) // --\\&gt; Strange corner case, which we don't take care of here. postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper()); &#125; &#125;&#125; 其程序架构图如下： 这个其实理解起来比较简单，主要分了下面几个步骤： 根据订阅者所在的类，订阅者的方法，生成相应的订阅者对象，即Subscription对象。 获取Event的事件类型，查看此事件是否有相应的List，如果有，则说明之前有注册过其他的可以处理该事件类型的Subcription，那么则根据优先级将此次的Subcription对象插入到合适的位置，否则则新建List，并将Subcription对象插入进来。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"EventBus","slug":"Android/EventBus","permalink":"http://yoursite.com/categories/Android/EventBus/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"EventBus","slug":"EventBus","permalink":"http://yoursite.com/tags/EventBus/"}]},{"title":"自定义View：3、编写自己的ViewGroup","slug":"android-custom-view-3-custom-viewgroup","date":"2014-12-13T12:07:04.000Z","updated":"2018-10-03T16:12:52.631Z","comments":true,"path":"2014/12/13/android-custom-view-3-custom-viewgroup/","link":"","permalink":"http://yoursite.com/2014/12/13/android-custom-view-3-custom-viewgroup/","excerpt":"","text":"前面我们已经分析过两种自定义View的方法： 自定义View：1、定制自己的饼形图 自定义View：2、组合视图 今天我们来继续学习第三种自定义View的方法，继承ViewGroup，实现自己的Layout。什么意思呢？其实前两种自定义View的方法，我们都是编写的具体的每一个View，然后整合到我们现有的Layout(比如LinearLayout，RelativeLayout等等)当中，但很多情况下，自定义View并不能完全满足我们的需求，或者说，我们想要使用现成的控件，但我们希望我们的界面上，我们可以完全自己来控制如何摆放这些控件。那这个时候怎么做呢？ 我们先来看一下我们想要实现的效果是什么样子的？ 简单分解一下上面我们要实现的需求： 每一小块为自定义View(称之为磁贴)，大小共有3中规格，分别是：横向占据屏幕1/4（size=one），横向占据屏幕1/2（size=two），横向占据屏幕全部（size=four）。其高度始终为屏幕1/4。颜色与文字均可以通过XML直接指定。 要求在XML定义各个View之后，要求能够从左上角开始能够自动占据铺满屏幕。 好了，要求说完了，那么该怎么去实现呢？首先我们来分解任务，要实现上面的功能，其实我们总共需要两个步骤，第一步，参考自定义View：1、定制自己的饼形图，定制我们自己的磁贴。第二步，指定我们自定的ViewGroup，自动对添加的磁贴贴到合适的位置上。 一、定制磁贴1、定制属性首先，我们需要在attrs.xml中为磁贴定义一些属性，在这边定义之后，我们就可以直接在Layout的XML中为磁贴指定颜色，文字，大小等内容。代码如下： 123456789&lt;declare-styleable name=\"Tile\"&gt; &lt;attr name=\"background\" format=\"color\"/&gt; &lt;attr name=\"title\" format=\"string\"/&gt; &lt;attr name=\"size\" format=\"enum\"&gt; &lt;enum name=\"one\" value=\"1\"/&gt; &lt;enum name=\"two\" value=\"2\"/&gt; &lt;enum name=\"four\" value=\"4\"/&gt; &lt;/attr&gt;&lt;/declare-styleable&gt; 如上所示，我们总共为磁贴定义了3个属性，其中包括背景颜色，文字内容，以及尺寸，one代表占据宽度的1/4，two代表占据宽度的1/2，而four则代表了占据宽度的全部。 2、定义View：Tile接下来就是很重要的一步，定义View，即Tile，还记得我们之前的文章具体是怎么做的吗？没做，就是分3步走： 构造函数从XML中获取参数，初始化。 覆写onMeasure方法，指定View具体的大小。 覆写onDraw方法，按照参数指定的颜色，文字及大小进行绘制。 初始化123456789101112131415161718192021222324public Tile(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray typedArray = context.getTheme().obtainStyledAttributes(attrs, R.styleable.Tile, 0, 0); mContent = new TileContent(); try &#123; mContent.mBackgroundColor = typedArray.getColor(R.styleable.Tile_background, Color.BLUE); mContent.mTitle = typedArray.getString(R.styleable.Tile_title); mContent.mSize = typedArray.getInt(R.styleable.Tile_size, 1); &#125; finally &#123; typedArray.recycle();; &#125; init(); &#125; private void init() &#123; mPaint = new Paint(Paint.ANTI\\_ALIAS\\_FLAG); mRect = new Rect(); mTextPaint = new TextPaint(Paint.ANTI\\_ALIAS\\_FLAG); mTextPaint.setTextSize(50.0f); mTextSize = new Rect(); mTextPaint.getTextBounds(mContent.mTitle, 0, mContent.mTitle.length(), mTextSize); &#125; 初始化代码比较简单了： 从context.getTheme()/obtainStyeAttributes中获取包含属性的TypeArray。 从中读取设置的参数 初始化画笔，获取文字所占的边界大小。 onMeasure(init widthMeasureSpec, int heightMeasureSpec)12345678910111213141516171819202122232425262728293031323334@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int width = 0; int height = 0; //如果指定了尺寸，那么就使用指定的尺寸，否则使用我们容器尺寸的一半 if (widthMode == MeasureSpec.EXACTLY) &#123; width = widthSize; height = width; &#125; else &#123; switch (mContent.mSize) &#123; case SIZE_ONE : width = widthSize &gt;&gt; 2; height = width; break; case SIZE_TWO: width = widthSize &gt;&gt; 1; height = width &gt;&gt; 1; break; case SIZE_FOUR: width = widthSize; height = width &gt;&gt; 2; break; &#125; &#125; mRect.set(0, 0, width, height); setMeasuredDimension(width, height);&#125; 在这个界面设置当中，onMeasure方法是比较关键的一步，因为我们要在这个地方为每一个磁贴，根据他们配置的属性为其指定合适的尺寸，那么我们具体是怎么做的呢？ 获取widthMode，如果是MeasureSpec.EACTLY，即在XML中指定了具体的大小，那么我们就应该使用指定的大小。 如果没有指定具体的大小，而是让View根据需求来自己指定的话，我们就按照原先的设计，如果尺寸为one，那么就将宽度设置为全部的宽度1/4，高度则与宽度想的呢个，如果尺寸为two，那么则宽度为全部宽度的一半，高度为对应宽度的1/2，如果为four，则宽度为全部的宽度，高度是宽度的1/4。 onDrawonDraw方法是我们经常用到的方法了，简单的讲就是根据我们的需求画图呗，看看代码就行。 1234567@Override protected void onDraw(Canvas canvas) &#123; mPaint.setColor(mContent.mBackgroundColor); canvas.drawRect(mRect, mPaint); mTextPaint.setColor(Color.WHITE); canvas.drawText(mContent.mTitle, getMeasuredWidth()/2 - mTextSize.width()/2, getMeasuredHeight()/2 + mTextSize.height()/2, mTextPaint); &#125; 上面的代码中，我们首先画好北京颜色，然后设置文字的画笔颜色，为其在中间写好文字。 好了，至此，具体的Tile就准备完毕了，再来看怎么编写我们自定的ViewGroup 二、定制ViewGroup：TileLayout1、覆写onMeasure方法自定义View的onMeasure方法我们有写过，但是自定义Layout的onMeasure方法怎么写呢？因为ViewGroup继承自View，因此思路和View基本上差别不大，我们这里先简单考虑，我们先将整个屏幕的全部空间都占据使用。那该怎么写呢？ 12345@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; measureChildren(widthMeasureSpec, heightMeasureSpec); super.onMeasure(widthMeasureSpec, heightMeasureSpec);&#125; 其中做了两个工作： 依次通知子View们进行测量 调用父类的onMeasure方法。 2、onLayout布局该方法是ViewGroup的核心方法之一，简单的理解，在该方法中，我们需要设计将子元素放在合适的位置上。根据需求，我们对TileLayout的onLayout方法可以如下实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; Log.i(TAG, \"onLayout:\" + \" position:\" + left + \",\" + top + \",\" + right + \",\" + bottom); int positionX = left; int positionY = top; int childCount = getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; View childView = getChildAt(i); if(! (childView instanceof Tile) ) &#123; throw new IllegalArgumentException(\"Catch Exception not Tile!\"); &#125; Tile item = (Tile) childView; int width = childView.getMeasuredWidth(); int height = childView.getMeasuredHeight(); int itemPostitionX = left; int itemPositionY = top; switch (item.getSize()) &#123; case Tile.SIZE_ONE: if( !isSpaceEmpty(Tile.SIZE_ONE) ) &#123; LayoutPositions params = mSizeOneSpaces.remove(); itemPostitionX = params.x; itemPositionY = params.y; &#125; else &#123; if (positionX + width &lt;= right) &#123; itemPostitionX = positionX; itemPositionY = positionY; positionX += width; if (positionX &gt;= right) &#123; positionX = left; positionY = positionY + height; &#125; &#125; else &#123; itemPostitionX = left; itemPostitionX = positionY + height; positionX = itemPostitionX + width; positionY = itemPositionY; &#125; &#125; break; case Tile.SIZE_TWO: if (positionX + width &lt;= right) &#123; itemPostitionX = positionX; itemPositionY = positionY; positionX += width; if (positionX &gt;= right) &#123; positionX = left; positionY = positionY + height; &#125; &#125; else &#123; for (int start=positionX; start + (width &gt;&gt; 1) &lt;= right; start=start + (width &gt;&gt; 1)) &#123; mSizeOneSpaces.add(new LayoutPositions(start, positionY)); &#125; positionX = left; positionY = positionY + height; itemPostitionX = positionX; itemPositionY = positionY; &#125; break; case Tile.SIZE_FOUR: if (positionX == left) &#123; itemPostitionX = positionX; itemPositionY = positionY; positionX += width; positionY += height; &#125; else &#123; for (int start=positionX; start + (width &gt;&gt; 2) &lt;= right; start=start + (width &gt;&gt; 2)) &#123; mSizeOneSpaces.add(new LayoutPositions(start, positionY)); &#125; positionX = left; positionY = positionY + height; itemPostitionX = positionX; itemPositionY = positionY; positionX = left; positionY = positionY + height; &#125; break; &#125; Log.i(TAG, \"Item:\" + item.getTitle() + \" position:\" + itemPostitionX + \",\" + itemPositionY + \",\" + (itemPostitionX + width) + \",\" + (itemPositionY + height)); childView.layout(itemPostitionX, itemPositionY, itemPostitionX + width, itemPositionY + height); &#125;&#125; 其实思路也很简单，首先尝试摆放，如果能将子View摆在某处，那么则摆放这里，继续摆放下面的地方，如果不能，则说明此行空间不足，那么将剩下的空间根据大小分配给合适的数量的size=“one”的元素。依次摆放就可以。 三、使用按照我们设计的，将所有的属性设置都放在XML当中，Activity代码如下： 12345678public class TestTileLayout extends Activity&#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.tile); &#125;&#125; 布局代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;me.happyhls.androiddemo.view.TileLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tile=\"http://schemas.android.com/apk/res-auto\" android:layout\\_width=\"match\\_parent\" android:layout\\_height=\"match\\_parent\" &gt; &lt;me.happyhls.androiddemo.view.Tile xmlns:tile=\"http://schemas.android.com/apk/res-auto\" android:layout\\_width=\"wrap\\_content\" android:layout\\_height=\"wrap\\_content\" tile:background=\"#0000FF\" tile:title=\"Title1\" tile:size=\"one\" /&gt; &lt;me.happyhls.androiddemo.view.Tile xmlns:tile=\"http://schemas.android.com/apk/res-auto\" android:layout\\_width=\"wrap\\_content\" android:layout\\_height=\"wrap\\_content\" tile:background=\"#00FF00\" tile:title=\"Title2\" tile:size=\"two\" /&gt; &lt;me.happyhls.androiddemo.view.Tile xmlns:tile=\"http://schemas.android.com/apk/res-auto\" android:layout\\_width=\"wrap\\_content\" android:layout\\_height=\"wrap\\_content\" tile:background=\"#FF0000\" tile:title=\"Title3\" tile:size=\"four\" /&gt; &lt;me.happyhls.androiddemo.view.Tile xmlns:tile=\"http://schemas.android.com/apk/res-auto\" android:layout\\_width=\"wrap\\_content\" android:layout\\_height=\"wrap\\_content\" tile:background=\"#0000FF\" tile:title=\"Title4\" tile:size=\"one\" /&gt; &lt;me.happyhls.androiddemo.view.Tile xmlns:tile=\"http://schemas.android.com/apk/res-auto\" android:layout\\_width=\"wrap\\_content\" android:layout\\_height=\"wrap\\_content\" tile:background=\"#00FF00\" tile:title=\"Title5\" tile:size=\"one\" /&gt; &lt;me.happyhls.androiddemo.view.Tile xmlns:tile=\"http://schemas.android.com/apk/res-auto\" android:layout\\_width=\"wrap\\_content\" android:layout\\_height=\"wrap\\_content\" tile:background=\"#FF00FF\" tile:title=\"Title6\" tile:size=\"two\" /&gt; &lt;me.happyhls.androiddemo.view.Tile xmlns:tile=\"http://schemas.android.com/apk/res-auto\" android:layout\\_width=\"wrap\\_content\" android:layout\\_height=\"wrap\\_content\" tile:background=\"#FF000F\" tile:title=\"Title7\" tile:size=\"four\" /&gt; &lt;me.happyhls.androiddemo.view.Tile xmlns:tile=\"http://schemas.android.com/apk/res-auto\" android:layout\\_width=\"wrap\\_content\" android:layout\\_height=\"wrap\\_content\" tile:background=\"#0000FF\" tile:title=\"Title8\" tile:size=\"one\" /&gt;&lt;/me.happyhls.androiddemo.view.TileLayout&gt; 好了，上面就是简单的对自定义ViewGroup的使用。总结来说，我们只是大体了解了一下如何自定义View，如何自定义ViewGroup，但深入的我们依然没有设计到，因此后面会有至少两篇文章，我们来分析Android原生控件TextView和Android原生Layout:LinearLayout的源代码。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"},{"name":"ViewGroup","slug":"ViewGroup","permalink":"http://yoursite.com/tags/ViewGroup/"}]},{"title":"自定义View：2、组合视图","slug":"android-custom-view-2-composition","date":"2014-12-09T03:48:04.000Z","updated":"2018-10-03T16:12:52.602Z","comments":true,"path":"2014/12/09/android-custom-view-2-composition/","link":"","permalink":"http://yoursite.com/2014/12/09/android-custom-view-2-composition/","excerpt":"","text":"昨天联系了自定义View的第一类，直接继承View自己画图。其实很多情况下，我们并不需要自己去从头开始画图，而是将现有的各种视图组合在一起，方便我们的使用。那这种情况下该怎么做呢？ 我们先来看看实现的效果怎么样（下图中，我将组合视图与CardView和RecyclerView结合在一起，看起来效果还蛮不错的）： 其实操作起来也很简单，与直接继承View的办法类似，一共3个步骤： 编写Layout，可以在代码中设置Layout，也可以直接通过XML配置Layout，然后在代码中直接解析就可以。 编写属性 组合在一起成为一个新的View 使用我们新的编写的View 很简单吧？我们依次来看，具体应该怎么来做。 一：编写对应的Layout代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout\\_width=\"match\\_parent\" android:layout\\_height=\"match\\_parent\" &gt; &lt;ImageView android:layout_width=\"100dp\" android:layout_height=\"100dp\" android:layout_alignParentLeft=\"true\" android:layout_alignParentTop=\"true\" android:scaleType=\"centerInside\" android:src=\"@drawable/ic_launcher\" android:id=\"@+id/avator\"/&gt; &lt;TextView android:layout\\_width=\"wrap\\_content\" android:layout\\_height=\"wrap\\_content\" android:layout\\_marginLeft=\"@dimen/activity\\_horizontal_margin\" android:paddingTop=\"@dimen/activity\\_vertical\\_margin\" android:layout_toRightOf=\"@id/avator\" android:layout_alignTop=\"@id/avator\" android:id=\"@+id/name\" android:text=\"name\" android:textAppearance=\"?android:attr/textAppearanceLarge\"/&gt; &lt;TextView android:layout\\_width=\"wrap\\_content\" android:layout\\_height=\"wrap\\_content\" android:layout\\_marginTop=\"@dimen/activity\\_vertical_margin\" android:layout_alignLeft=\"@id/name\" android:layout_below=\"@id/name\" android:text=\"Description here\" android:layout_alignBottom=\"@id/avator\" android:id=\"@+id/description\"/&gt;&lt;/RelativeLayout&gt; 视图的定义就不需要多说了，比较简单，其界面效果就是其中的名片小卡片，包括了一张图像，名字和简单的简介。 二、编写属性为了以后能够更加方便的使用，我们当然最好为我们新编写的视图增加属性设置，其实和上一篇文章当中介绍的基本上一样，贴上代码。 12345&lt;declare-styleable name=\"NameCard\"&gt; &lt;attr name=\"avatar\" format=\"reference\"/&gt; &lt;attr name=\"name\" format=\"string\"/&gt; &lt;attr name=\"description\" format=\"string\"/&gt;&lt;/declare-styleable&gt; 我们为其制定了3个属性，分别是图像，姓名，介绍。通过这些，我们就可以在XML中直接指定默认的属性。 三、构建新的View思路： 第一步：我们需要加载我们在步骤1中编写的Layout 第二步：根据XML属性或者用户的设置更改其中图像，姓名和介绍的内容。 其他的，就交给RelativeLayout去做吧。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class NameCard extends RelativeLayout&#123; public static class NameCardContent &#123; private Drawable mAvatarImageDrawable; private String mName; private String mDescription; public NameCardContent() &#123; &#125; public NameCardContent(Drawable avatarImageDrawable, String name, String description) &#123; mAvatarImageDrawable = avatarImageDrawable; mName = name; mDescription = description; &#125; public Drawable getAvatarImageDrawable() &#123; return mAvatarImageDrawable; &#125; public void setAvatarImageDrawable(Drawable avatarImageDrawable) &#123; mAvatarImageDrawable = avatarImageDrawable; &#125; public String getName() &#123; return mName; &#125; public void setName(String name) &#123; mName = name; &#125; public String getDescription() &#123; return mDescription; &#125; public void setDescription(String description) &#123; mDescription = description; &#125; &#125; private NameCardContent mNameCardContent = new NameCardContent(); private ImageView mImageViewAvator; private TextView mTextViewName; private TextView mTextViewDescription; public NameCard(Context context) &#123; this(context, null); &#125; public NameCard(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public NameCard(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); TypedArray typedArray = context.getTheme().obtainStyledAttributes(attrs, R.styleable.NameCard, 0, 0); try &#123; mNameCardContent.mAvatarImageDrawable = typedArray.getDrawable(R.styleable.NameCard_avatar); mNameCardContent.mName = typedArray.getString(R.styleable.NameCard_name); mNameCardContent.mDescription = typedArray.getString(R.styleable.NameCard_description); &#125; finally &#123; typedArray.recycle();; &#125; inflate(context, R.layout.namecard, this); mImageViewAvator = (ImageView) findViewById(R.id.avator); mTextViewName = (TextView) findViewById(R.id.name); mTextViewDescription = (TextView) findViewById(R.id.description); mImageViewAvator.setImageDrawable(mNameCardContent.getAvatarImageDrawable()); mTextViewName.setText(mNameCardContent.getName()); mTextViewDescription.setText(mNameCardContent.getDescription()); &#125; public Drawable getAvatarImageDrawable() &#123; return mNameCardContent.getAvatarImageDrawable(); &#125; public void setAvatarImageDrawable(Drawable avatarImageDrawable) &#123; mNameCardContent.setAvatarImageDrawable(avatarImageDrawable); mImageViewAvator.setImageDrawable(avatarImageDrawable); &#125; public String getName() &#123; return mNameCardContent.getName(); &#125; public void setName(String name) &#123; mNameCardContent.setName(name); mTextViewName.setText(name); &#125; public String getDescription() &#123; return mNameCardContent.getDescription(); &#125; public void setDescription(String description) &#123; mNameCardContent.setDescription(description); mTextViewDescription.setText(description); &#125;&#125; 四、使用根据我们上面的所想要的效果，首先，为CardView编写子视图界面： 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout\\_width=\"match\\_parent\" android:layout\\_height=\"wrap\\_content\" &gt; &lt;android.support.v7.widget.CardView xmlns:card_view=\"http://schemas.android.com/apk/res-auto\" android:layout\\_width=\"match\\_parent\" android:layout\\_height=\"wrap\\_content\" android:id=\"@+id/cardview\" android:layout_gravity=\"center\" card_view:cardCornerRadius=\"10dp\" card_view:cardElevation=\"10dp\" &gt; &lt;me.happyhls.androiddemo.view.NameCard android:layout\\_width=\"match\\_parent\" android:layout\\_height=\"wrap\\_content\" android:id=\"@+id/namecard\"&gt; &lt;/me.happyhls.androiddemo.view.NameCard&gt; &lt;/android.support.v7.widget.CardView&gt;&lt;/LinearLayout&gt; 然后编写Activity对应的RecyclerView的界面 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout\\_width=\"match\\_parent\" android:layout\\_height=\"match\\_parent\" android:orientation=\"vertical\" android:paddingBottom=\"@dimen/activity\\_vertical\\_margin\" android:paddingLeft=\"@dimen/activity\\_horizontal\\_margin\" android:paddingRight=\"@dimen/activity\\_horizontal\\_margin\" android:paddingTop=\"@dimen/activity\\_vertical\\_margin\"&gt; &lt;android.support.v7.widget.RecyclerView android:layout\\_width=\"match\\_parent\" android:layout\\_height=\"match\\_parent\" android:id=\"@+id/recycleview\" android:layout_gravity=\"center\" &gt;&lt;/android.support.v7.widget.RecyclerView&gt;&lt;/LinearLayout&gt; 最后，在Activity中初始化RecyclerView和数据，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class TestNameCard extends Activity &#123; private static final String TAG = TestNameCard.class.getSimpleName(); @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.lollipop_recyclerviewandcardview); RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycleview); RecyclerView.LayoutManager layoutManager = new LinearLayoutManager(this); recyclerView.setLayoutManager(layoutManager); List&lt;NameCard.NameCardContent&gt; items = new ArrayList&lt;NameCard.NameCardContent&gt;(); Drawable drawable = getResources().getDrawable(R.drawable.ic_launcher); for (int i = 0; i &lt; 100; i++) &#123; items.add(new NameCard.NameCardContent(drawable, \"Name\" + i, \"Description\" + i)); &#125; MyAdapter adapter = new MyAdapter(this, items); recyclerView.setAdapter(adapter); &#125; static class MyAdapter extends RecyclerView.Adapter&lt;ViewHolder&gt; &#123; private List&lt;NameCard.NameCardContent&gt; mItems; private LayoutInflater mLayoutInflater; public MyAdapter(Context context, List&lt;NameCard.NameCardContent&gt; items) &#123; this.mItems = new ArrayList&lt;NameCard.NameCardContent&gt;(items); mLayoutInflater = LayoutInflater.from(context); &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int position) &#123; Log.d(TAG, \"Adapter creating view for \" + position); View view = mLayoutInflater.inflate(R.layout.namecard_item, parent, false); ViewHolder viewHolder = new ViewHolder(view); viewHolder.mNameCard = (NameCard) view.findViewById(R.id.namecard); return viewHolder; &#125; @Override public void onBindViewHolder(ViewHolder viewHolder, int position) &#123; Log.d(TAG, \"Adapter binding view for \" + position); viewHolder.mNameCard.setAvatarImageDrawable(mItems.get(position).getAvatarImageDrawable()); viewHolder.mNameCard.setName(mItems.get(position).getName()); viewHolder.mNameCard.setDescription(mItems.get(position).getDescription()); &#125; @Override public int getItemCount() &#123; return mItems.size(); &#125; &#125; static class ViewHolder extends RecyclerView.ViewHolder &#123; public ViewHolder(View view) &#123; super(view); &#125; NameCard mNameCard; &#125;&#125; 思考：优化的空间？ 需要注意的是，上面我们的实现中，仅仅是展示了组合视图的相关的原理和RecyclerView/CardView的使用，但实际的生产环境中不会这么简单，几个简单的点： 1、NameCard当中，我们为每一个名片都保存了Drawable，而且是强引用，同时我们观察代码，可以发现所有的DrawableActivity中的List中的NameCardContent里面，在上面的代码中，我们所有的Drawable都是指向同一个对象，因此不会占用太多的内容空间，但在实际应用当中，不同的人对应的头像必然是不同的，那这个时候就不能再这样使用了，否则会必然导致OOM。（解决办法，加入Cache，保存Drawable对应的地址或者Id） 2、关于视图层次，上面的代码中，NameCard是一个RelativeLayout，但我们注意到其中加载的namecard.xml仍然其中任然有一层RelativeLayout，其实是不需要的，多于的，由于这个视图会多次被解析，因此这样必然会严重影响加载速度，所以此处应该将namecard.xml最外层去掉RelativeLayout，设置为merge标签即可。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"CardView","slug":"CardView","permalink":"http://yoursite.com/tags/CardView/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://yoursite.com/tags/RecyclerView/"},{"name":"View","slug":"View","permalink":"http://yoursite.com/tags/View/"},{"name":"自定义View","slug":"自定义View","permalink":"http://yoursite.com/tags/自定义View/"}]},{"title":"自定义View：1、定制自己的饼形图","slug":"android-custom-view-1-pie-chart","date":"2014-12-08T10:31:20.000Z","updated":"2018-10-03T16:12:52.599Z","comments":true,"path":"2014/12/08/android-custom-view-1-pie-chart/","link":"","permalink":"http://yoursite.com/2014/12/08/android-custom-view-1-pie-chart/","excerpt":"","text":"Android本身为我们提供了View，但很多情况下，仍然无法满足我们自己的需求，那么这个时候就需要自己定制View。自定义View的办法有很多，我们从最基础的开始。 上图就是我们要实现的效果，具体的我们依次来列举一下： 首先要画出上面的界面 饼形图，饼的面积代表其进度。 在饼形图中间可以设定是否显示数字进度。 要可以设置饼形图的各种参数，包括颜色，大小等等 要能够通过UI中其他的控件比如SeekBar来设置饼形图的参数。 要有回调函数能够使得其他的控件接收到饼形图中进度的变化。 当手指按在饼形图上时，要能够不断自增进度。 好了，上面就是我们规划的需求，那么我们来依次编写代码，首先来分析我们需要做的工作有哪些？ 资源文件 attrs.xml中准备饼形图可设置的参数，这样我们可以直接在Layout中设置饼形图的各个参数 程序代码 覆写onMeasure方法来设置界面的大小 覆写onDraw()方法来绘图 设计各种回调函数(Listener) 覆写onTouchEvent()设计触摸事件 资源文件首先，我们需要在attrs.xml中为饼形图设计各种参数，我们将饼形图名称定义为ProgressPie，那我们为其设计的属性为： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"ProgressPie\"&gt; &lt;attr name=\"max\" format=\"integer\"/&gt; &lt;attr name=\"progress\" format=\"integer\"/&gt; &lt;attr name=\"showText\" format=\"boolean\"/&gt; &lt;attr name=\"textSize\" format=\"dimension\"/&gt; &lt;attr name=\"textColor\" format=\"color\"/&gt; &lt;attr name=\"textPosition\" format=\"enum\"&gt; &lt;enum name=\"left\" value=\"0\"/&gt; &lt;enum name=\"middle\" value=\"1\"/&gt; &lt;enum name=\"right\" value=\"2\"/&gt; &lt;/attr&gt; &lt;attr name=\"color\" format=\"color\"/&gt; &lt;attr name=\"showBorder\" format=\"boolean\"/&gt; &lt;attr name=\"borderColor\" format=\"color\"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 我们为ProgressPie声明了一些属性，有一点需要注意的是属性的各种类型，比如整形，尺寸，布尔型，颜色，枚举类型(其中元素要在对应的View中定义)等等。 那怎么使用呢？activity.xml的界面如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout\\_width=\"match\\_parent\" android:layout\\_height=\"match\\_parent\" android:paddingBottom=\"@dimen/activity\\_vertical\\_margin\" android:paddingLeft=\"@dimen/activity\\_horizontal\\_margin\" android:paddingRight=\"@dimen/activity\\_horizontal\\_margin\" android:paddingTop=\"@dimen/activity\\_vertical\\_margin\"&gt; &lt;CheckBox android:layout\\_width=\"wrap\\_content\" android:layout\\_height=\"wrap\\_content\" android:text=\"Visiablity\" android:id=\"@+id/visiablityCheckBox\" android:checked=\"true\" /&gt; &lt;SeekBar android:layout\\_width=\"match\\_parent\" android:layout\\_height=\"wrap\\_content\" android:id=\"@+id/seekbar\" /&gt; &lt;me.happyhls.androiddemo.view.ProgressPie xmlns:progresspie=\"http://schemas.android.com/apk/res-auto\" android:layout\\_width=\"match\\_parent\" android:layout\\_height=\"match\\_parent\" android:layout\\_marginTop=\"@dimen/activity\\_vertical_margin\" progresspie:max=\"100\" progresspie:progress=\"90\" progresspie:textColor=\"#0000FF\" progresspie:showText=\"true\" progresspie:textSize=\"50sp\" progresspie:textPosition=\"right\" progresspie:color=\"#FF0000\" android:id=\"@+id/progressspie\" /&gt;&lt;/LinearLayout&gt; 重点我们来看一下我们自己定义的me.happyhls.androiddemo.view.ProgressPie： 首先我们需要申明命名空间，在AndroidStudio中的推荐写法为，将其设为res-auto，即： xmlns:progresspie=”http://schemas.android.com/apk/res-auto&quot; 这样就可以自动找到我们的属性设置，需要注意的是，上面是当前的ADT或者AS中的推荐写法。 以前，我们一般是这样写的： xmlns:progress=”http://schemas.android.com/apk/res/me.happyhls.view.ProgressPie 但现在最好不要这样写，如果按照以前那样写上自己的包名的话，可以能出现错误，尤其是我们要作为Library提供的时候。参考：http://stackoverflow.com/questions/10398416/using-activities-from-library-projects 其他的地方则是我们比较经常使用的，不需要多说，主要来看看代码里面的内容： ProgressPie.java一：初始化-&gt;构造函数构造函数是我们首先需要写好的，默认的View其中有3个构造函数： 123456789101112public View(Context context) &#123;&#125;public View(Context context, AttributeSet attrs) &#123; this(context, attrs, 0);&#125;public View(Context context, AttributeSet attrs, int defStyleAttr) &#123; this(context); TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.View,defStyleAttr, 0); ...&#125; 这里面的3个构造函数都有其不同的应用场景，为了使得我们的自定义View更加规范易用，我们同样需要书写类似的3个构造函数，在编写之前，我们需要首先搞明白，这3个构造函数分别应用在什么场景里面呢？自己思考是想不明白的，我们先去看看Button的源代码： 12345678910111213141516171819202122232425public class Button extends TextView &#123; public Button(Context context) &#123; this(context, null); &#125; public Button(Context context, AttributeSet attrs) &#123; this(context, attrs, com.android.internal.R.attr.buttonStyle); &#125; public Button(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; @Override public void onInitializeAccessibilityEvent(AccessibilityEvent event) &#123; super.onInitializeAccessibilityEvent(event); event.setClassName(Button.class.getName()); &#125; @Override public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) &#123; super.onInitializeAccessibilityNodeInfo(info); info.setClassName(Button.class.getName()); &#125;&#125; 从上我们可以看出： 所有的构造函数最终都是通过public Button(Context context, AttributeSet attrs, int defStyle){}初始化Button。 如果通过代码创建Button，那么会调用构造器public Button(Context context) {}(来源：View.java源代码注释)，但本质上仍然通过public Button(Context context, AttributeSet attrs, int defStyle) {}实例化，但其中传入的参数attrs为null，defStyle为com.android.internal.R.attr.buttonStyle。 如果通过XML创建Button，那么此时会调用构造器public Button(Context context, AttributeSet attrs) {}，但本质上仍然通过public Button(Context context, AttributeSet attrs, int defStyle) {}实例化，但其中传入的参数attrs为attrs，defStyle为com.android.internal.R.attr.buttonStyle。 public Button(Context context, AttributeSet attrs, int defStyle) {}什么时候调用？不太清楚，但Button所有的初始化最终都是通过该构造器，并调用父类TextView对应的构造器实现。 综上所示，要搞明白，还需要好好看看TextView对应的构造器实现。 TextView的源代码如下，来分析一下public TextView(Context context, AttributeSet attrs, int defStyle)的源代码。 {https://github.com/happyhls/platform\\_frameworks\\_base/blob/master/core/java/android/widget/TextView.java} 1、调用父类的构造函数 1super(context, attrs, defStyle); 2、为了简化逻辑设计，从系统主题中获取默认的主题，使用设置的attrs及com.android.internal.R.styleable.TextAppearance设置默认属性。 1234567891011121314151617final Resources.Theme theme = context.getTheme(); /\\* \\* Look the appearance up without checking first if it exists because \\* almost every TextView has one and it greatly simplifies the logic \\* to be able to parse the appearance first and then let specific tags \\* for this View override it. */TypedArray a = theme.obtainStyledAttributes( attrs, com.android.internal.R.styleable.TextViewAppearance, defStyle, 0);TypedArray appearance = null;int ap = a.getResourceId( com.android.internal.R.styleable.TextViewAppearance_textAppearance, -1);a.recycle();if (ap != -1) &#123; appearance = theme.obtainStyledAttributes( ap, com.android.internal.R.styleable.TextAppearance);&#125; 3、使用attrs，并从主题中获取com.android.internal.R.styleable.TextView的属性设置： 12345678a = theme.obtainStyledAttributes( attrs, com.android.internal.R.styleable.TextView, defStyle, 0);int n = a.getIndexCount();for (int i = 0; i &lt; n; i++) &#123; int attr = a.getIndex(i); ...&#125; 4、使用attrs，获取View中定义的focusable,clickable属性值： a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.View, defStyle, 0); 可以看出，在TextView中根据用户在XML中设定的属性和系统的默认属性，依次设置TextView的各个属性值。 有一点我们需要想到的是，TextView的设计比较复杂，是因为在Android当中，TextView是大量控件的父类，换句话说，很多的控件都是基于TextView来实现的，比如说： Known Direct Subclasses Button, CheckedTextView, Chronometer, DigitalClock, EditText, RowHeaderView, TextClock Known Indirect Subclasses AutoCompleteTextView, CheckBox, CompoundButton, ExtractEditText, MultiAutoCompleteTextView, RadioButton, SearchEditText, Switch, SwitchCompat,ToggleButton 那我们的代码改怎么写呢？如果不会，那么就模仿，所以，我们模仿TextView，同样声明3个构造函数，在含有3个参数的构造函数中具体的初试话所有需要初始化的属性，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public ProgressPie(Context context) &#123; this(context, null);&#125;public ProgressPie(Context context, AttributeSet attrs) &#123; this(context, attrs, 0);&#125;public ProgressPie(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray typedArray = context.getTheme().obtainStyledAttributes(attrs, R.styleable.ProgressPie, 0, 0); try &#123; mMax = typedArray.getInteger(R.styleable.ProgressPie_max, 100); mProgress = typedArray.getInteger(R.styleable.ProgressPie_progress, 0); if (mProgress &gt; mMax) &#123; mProgress = mMax; &#125; else if (mProgress &lt; 0) &#123; mProgress = 0; &#125; mShowText = typedArray.getBoolean(R.styleable.ProgressPie_showText, false); if (mShowText) &#123; mTextSize = typedArray.getDimensionPixelSize(R.styleable.ProgressPie_textSize, 20); mTextColor = typedArray.getColor(R.styleable.ProgressPie_textColor, Color.BLACK); mTextPosition = typedArray.getInteger(R.styleable.ProgressPie\\_textPosition, TEXT\\_POSITION_MIDDLE); &#125; mColor = typedArray.getColor(R.styleable.ProgressPie_color, Color.BLUE); mShowBorder = typedArray.getBoolean(R.styleable.ProgressPie_showBorder, true); if (mShowBorder) &#123; mBorderColor = typedArray.getColor(R.styleable.ProgressPie_borderColor, Color.GRAY); &#125; &#125; finally &#123; typedArray.recycle(); &#125; init();&#125;private void init() &#123; mTextPaint = new TextPaint(Paint.ANTI\\_ALIAS\\_FLAG); mTextPaint.setColor(mTextColor); mTextPaint.setTextSize(mTextSize); mPiePaint = new Paint(Paint.ANTI\\_ALIAS\\_FLAG); mPiePaint.setColor(mColor);&#125; 其实整体来说，并不复杂，简单的讲，首先获取XML中的配置的属性，并进行设置，最后初始化了我们所需要的Paint画笔。需要注意的是TypeArray使用完成之后，记得要回收。 直接在XML中定义&gt;style定义&gt;由defStyleAttr和defStyleRes指定的默认值&gt;直接在Theme中指定的值 //参考自http://www.cnblogs.com/angeldevil/p/3479431.html 二：测量-&gt;onMeasure123456789101112131415161718192021222324252627@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; Log.i(TAG, \"onMeasure\"); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int width, height; if (widthMode == MeasureSpec.EXACTLY) &#123; width = widthSize; &#125; else &#123; CharSequence charSequence = String.valueOf(mMax); width = getTextWidth(charSequence, mTextPaint) &lt;&lt; 1; &#125; height = width; if (width &gt; 0) &#123; this.width = width; this.height = height; rectF.set(0f, 0f, width, height); &#125; setMeasuredDimension(height, width);&#125; 在我们的饼形图当中，我们要设定的饼是一个圆形，那么其大小该怎么确定呢？ 最小情况(wrap_content)：首先是一个圆形，如果要显示数字的话，那么最小的饼只要能够覆盖数字的空间就可以。同时，因为我们设计了3种数字的显示方式：靠左，靠右，居中，因此我们可以保证圆的半径为数字所占空间的大小，那么就可以保证在所有的情况下，都能够正常显示 最大的情况(match_parent)/XML指定控件大小：其实这两种情况下，我们都可以因为是使用到该饼形图的地方已经为我们指定好了大小：如果是XML指定大小的情况，那不用多说，如果是match_parent，那么这个时候其实大小是由容器剩下的空间决定好了的。因此在这些情况下，我们只要采用给定的尺寸就可以。 首先说明一下MeasureSpec这个类： 该类封装了从Layout parent传递给child的Layout参数。MeasureSpec都包含了width和height属性，由size和mode构成。 对于Mode，总共有3中类型，由MeasureSpec的最高两位来表示(32位)： UNSPECIFIED(0b00)：没有指定 EXACTLY(0b01)：Layout parent中已经定义了child元素的具体尺寸，不管child所需要的或者设置的尺寸是多少，其最终都使用父控件所指定的大小。 AT_MOST(0b11)：子元素可以任意获得所需要的大小。 setMeasuredDimension 我们可以注意到，在onMeasure()方法的最后，我们调用了View中的setMeasuredDimension方法，需要注意的是，该方法是onMeasure中必须调用的，用来保存我们设置的尺寸大小。如果没有调用该方法的话，会抛出异常。 还有，其中我们使用getTextWidth()方法来获取数字所占用的屏幕大小。我暂时知道的有两种思路 (int)FloatMath.ceil(Layout.getDesiredWidth(charSequence, textPaint)); //Return how wide a layout must be in order to display the specified text slice with one line per paragraph. mTextPaint.getTextBounds(text, 0, text.length(), mBounds); //Return in bounds (allocated by the caller) the smallest rectangle that encloses all of the characters, with an implied origin at (0,0).int textWidth = mBounds.width(); 两种办法都可以。 三、画图-&gt;onDraw前面我们已经看完了，一个自定义View如何进行初始化和确定尺寸的，现在则看看到底是如何来画图的。 1234567891011121314151617181920212223242526272829protected void onDraw(Canvas canvas) &#123; Log.i(TAG, \"onDraw\"); super.onDraw(canvas); mPiePaint.setColor(mColor); mPiePaint.setStyle(Paint.Style.FILL); canvas.drawArc(rectF, 180, 360*getProgress()/getMax(), true, mPiePaint ); if (mShowBorder) &#123; mPiePaint.setColor(mBorderColor); mPiePaint.setStyle(Paint.Style.STROKE); canvas.drawArc(rectF, 180, 360*getProgress()/getMax(), true, mPiePaint ); &#125; if ( mShowText ) &#123; String text = String.valueOf(getProgress()); mTextPaint.getTextBounds(text, 0, text.length(), mBounds); int textWidth = mBounds.width(); int textHeight = mBounds.height(); switch (mTextPosition) &#123; case TEXT\\_POSITION\\_LEFT: canvas.drawText(text, width/2 - textWidth, height/2 + textHeight/2, mTextPaint); break; case TEXT\\_POSITION\\_MIDDLE: canvas.drawText(text, width/2 - textWidth/2, height/2 + textHeight/2, mTextPaint); break; case TEXT\\_POSITION\\_RIGHT: canvas.drawText(text, width/2, height/2 + textHeight/2, mTextPaint); break; &#125; &#125;&#125; onDraw方法是我们必须要实现的一个方法，说简单一点，该方法就是用来画图的，怎么画呢？ 在onDraw方法中有一个参数Canvas，Canvas即画板，在该画板上画图，则会直接显示在界面上。我们来看看我们具体是怎么画的图。 我们首先调用了super.onDraw(canvas)：其实分析到这里，我们可以知道，View的onDraw(Canvas canvas)方法中，什么工作也没有做，因此这段代码可以省去。 在canvas画扇形，需要注意的是，我们同时利用mPiePaint来画扇形和边界，因此此时我们应该先将画笔设置的Style设置为Paint.Style.FILL。 判断是否需要画边界，则画出边界 判断是否需要画文字，如果需要，则画出文字。 四、触摸事件-&gt;onTouchEvent12345678910111213141516171819@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mUpdatingThread = new UpdatingThread(); mUpdatingThread.start();; break; case MotionEvent.ACTION_UP: if(mUpdatingThread!=null &amp;&amp; mUpdatingThread.isAlive()) &#123; mUpdatingThread.finish();; mUpdatingThread.interrupt();; &#125; break; default: return true; &#125; return true;&#125; 触摸事件，我们只需要实现onTouchEvent就可以，需要注意的是，其中的返回值，如果返回true，那么说明此事件已经被View处理，不需要再分发，如果为false，则说明此事件还需要被其他的View处理。 在View的文档中提到，如果说我们要处理点击事件的话，最好的方法不是覆写onTouchEvent方法，而是覆写performClick()方法，可以获得以下的好处： obeying click sound preferences dispatching OnClickListener calls handling [ACTION_CLICK](http://developer.android.com/reference/android/view/accessibility/AccessibilityNodeInfo.html#ACTION_CLICK) when accessibility features are enabled 我们这里要处理一直按下的状态，当按下的时候，数字每1s加一，当松手的时候停止，因此我们设计的逻辑是，当按下的时候，启动一个线程处理，松手的时候，停止该线程即可。 1234567891011121314151617181920212223242526private class UpdatingThread extends Thread &#123; private volatile boolean isRunning = true; @Override public void run() &#123; while (!Thread.interrupted() &amp;&amp;isRunning) &#123; if (mProgress &lt; mMax) &#123; ProgressPie.this.post(new Runnable() &#123; @Override public void run() &#123; ProgressPie.this.setProgress(++mProgress); &#125; &#125;); &#125; try &#123; Thread.sleep(1000); &#125; catch (Exception e) &#123; //e.printStackTrace();; &#125; &#125; &#125; public void finish() &#123; isRunning = false; &#125;&#125; 需要注意的是，为了访问UI线程的空间，我们使用了View的post(Runnable runnable)方法。 好了，各个部分就是这样，具体的详细代码可以参考： https://github.com/happyhls/AndroidDemo/blob/master/app/src/main/java/me/happyhls/androiddemo/view/ProgressPie.java","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"http://yoursite.com/categories/Android/View/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"自定义View","slug":"自定义View","permalink":"http://yoursite.com/tags/自定义View/"},{"name":"onMeasure","slug":"onMeasure","permalink":"http://yoursite.com/tags/onMeasure/"}]},{"title":"App Components : Intents and Intent Filters (译)","slug":"android-documents-intents-and-intentfilters","date":"2014-11-29T07:44:53.000Z","updated":"2018-10-03T15:28:06.804Z","comments":true,"path":"2014/11/29/android-documents-intents-and-intentfilters/","link":"","permalink":"http://yoursite.com/2014/11/29/android-documents-intents-and-intentfilters/","excerpt":"","text":"API Guides:http://developer.android.com/guide/components/intents-filters.html Intent是一种消息组件，用来从一个app component向另外一个app component请求一个动作。在系统内部Intent的传递流程如下： 虽然在components中有着灵活变化的通信方式，但有3种最基本的用法： 启动activity 启动service 发布broadcast Intent的类型主要有两种： 显式的Intent(Explicit intents)：显式Intent会通过名字（完整的类名）指定要启动的组建。因为在在自己的程序中，我们知道具体的要启动的activity或者service的类名，所以一般程序内部会使用这种方式来启动。 隐式的Intent(Implicit intents)：不会指定具体的要启动的类名，但会定义一种相对通用的action请求以允许其他的程序来处理。 如果使用显示的Intent的话，那么系统会立刻启用Intent指定的系统组件；但如果使用隐式的Intent，Android系统会从系统中查找程序的manifest文件中定义的与intent filters相匹配的intent。如果系统找到一个，那么就会启动相应的component，并传入相应的Intent；如果同时匹配了多个intent，系统会弹出一个dialog，让用户选择一个执行。 Intent filter是在应用程序的manifest文件中的一段表达式，用来表示该系统组件所接收消息的类型。比如说，可以我们可以为activity声明一个intent-filter来允许其他的应用程序直接调用该的activity。因此，如果说一个activity没有设置任何的intent-filter，那么该acitivy只会接收显示intent. 注意：为了保证我们的应用程序的安全，要使用显式intent来启动Service，并且不要为Service声明任何的intent-filter对象。如果我们使用隐士intent来启动service的话是无法保证其安全性的，因为我们无法确定service该如何相应这个intent，而且用户也无法知道哪个service被启动了。从Android5.0(API 21)开始，如果我们通过隐士的intent来调用bindService()的时候，系统会抛出一个异常。 构建一个IntentIntent包含了必要的信息来让Android系统判断需要启动哪个系统组件(比如一个准确的系统组件的name或者是组件的category)，还有一个额外的信息用来保证启动的系统组件可以优雅的处理好接收到的请求(比如action或者data)。 Intent一般包含以下的信息： Component name： 要启动的组件名称，该项可选，但如果需要使用显式Intent除外。如果没有Component name，那么该intent就是一个隐式intent，由系统来根据附加在该intent上的其他信息，比如action,data,category等，决定哪个系统组件来接收这个intent。如果所以，如果说我们需要在应用程序内部启动特定的系统组件，那么我们就应该指定Component name。 注意：当启动Service的时候，我们必须总是指定component name。要不然的话，我们无法确定会由哪个Service来处理这个intent，并且用户这不会知道哪个Service被启动了。 Intent中的该部分内容是一个ComponentName对象，我们可以使用完整名称的类名(包括包名)来制定目标组件。比如：com.example.ExampleActivity。我们可以通过 setComponent(), setClass(),setClassName(), 或者 Intent的构造器来设置组件名称。 Action： 一个用于指定所要执行的通用动作的字符串(比如view或者pick)。在broadcast的使用情景中，这对应着正在发生并且需要报告的action。Action很大部分定下了intent后面的结构是如何构成的，尤其是在data和extras中包含了什么样的信息。 我们可以在我们的应用程序内部指定我们自己的intents需要使用的actions(或者供其他的程序调用我们应用程序内部的系统组件)，但是我们一般情况下还是使用Intent类或者其他的framework类定义的Action常量。这里有一些常用的用来启动activity的actions： ACTION_VIEW：如果我们要启动一应用程序来展示信息，比如要展示一个照片可以启动gallery应用程序，或者在map的应用程序中展示地址信息。 ACTION_SEND：还有另外一个名称“share” intent，我们如果有一些消息要在应用程序之间共享。 可以通过查看Intent类来查看共多的通用actions的常量。其他的一些actions可能在Android框架层的其他部分定义，比如Settings中定义了一些启动Settings中特定界面的actions。 我们可以使用[setAction()](http://developer.android.com/reference/android/content/Intent.html#setAction(java.lang.String))或者[Intent](http://developer.android.com/reference/android/content/Intent.html)的构造函数来指定action。 如果我们要定义我们自己的action，那么一定不要忘记包含自己的包名作为前缀，比如： static final String ACTION_TIMETRAVEL = “com.example.action.TIMETRAVEL”; Data： 我们所需要处理的数据的MIME格式所对应的URI(一个Uri对象)。数据的类型由intent中的Action属性确定。比如如果一个action是 [ACTION_EDIT](http://developer.android.com/reference/android/content/Intent.html#ACTION_EDIT)，那么数据应该包含我们要编辑的文档的URI。 当创建一个intent的时候，除了指定URI之外，指定数据的格式(MIME类型)也是特别重要的。比如，即使URI格式是一样的，但一个能够显示照片的程序，并不能播放一段媒体音乐。所以，如果为我们的数据指定MIME类型，就能够帮助Android系统更好的找到接收处理该Intent的系统组件。然后，有的时候，MIME的类型是从URI中继承来的-尤其是当数据是content:URI，这意味着数据是保存在设备当中，并且由ContentProvider控制的，这时候数据的MIME类型系统是可以探测到的。 如果仅仅需要设置数据的URI，调用setData())。仅仅设置MIME类型，调用setType())，如果两者都要设定，调用[setDataAndType()](http://developer.android.com/reference/android/content/Intent.html#setDataAndType(android.net.Uri, java.lang.String))。 注意：如果我们要同时设置URI和MIME类型的话，不要调用[setData()](http://developer.android.com/reference/android/content/Intent.html#setData(android.net.Uri))以及`setType())，因此调用setData()或者setType()的时候会将另一个设置为null。这个时候一定要调用setDataAndType().` Category: 一个包含了额外的其他用来指定处理此intent的系统组件类型的字符串。一个intent可以包含任意数量的itnent。但大多数intent并不需要包含一个category。这里展示一些常用的CATEGORY。 CATEGORY_BROWSABLE：目标Activity允许被web浏览器调用来通过一个链接，比如image或者e-mail来展示数据。 CATEGORY_LAUNCHER：该Activity为应用程序的初始化activity，并且会在系统的Launcher中展示出来。 其他的可以参考Intent的类来看下其他的categories。 我们可以通过addCategory()来添加Category。 上面所描述的属性，包括Component name，Action，data(Uri,MIME type)，Category定义了一个intent的典型特征。通过上面的信息，Android系统能够找到要启动的系统组件。 然而，一个intent可以携带的信息并不仅仅只有上面所列出的，还有其他的信息，但并不会对查找对应的component产生影响。 Extras：Key-Value对。可以承载一些额外的信息，比如data URIs。 通过putExtra()方法来添加。或者也可以创建一个Bundle对象来包含这些信息，然后把这个Bundle放进Intent中去。 Intent类为标准数据类型指定了一些经常使用的EXTRA_*常量。但我们可以为自己的程序制定声明自己的数据。没用过 static final String EXTRA_GIGAWATTS = “com.example.EXTRA_GIGAWATTS”; Flags：可以用来展示如何启动一个activity(比如activity应该输入哪个task)，对应的activity启动之后，如何处理(比如是否要让其在最近的activities中显示)。详细的可以参考setFlag()方法。 如何使用显示Intent使用显示的Intent，必须要指定Component Name，其他的属性都可以不设置，比如：12345// Executed in an Activity, so 'this' is the Context// The fileUrl is a string URL, such as \"http://www.example.com/image.png\"Intent downloadIntent = new Intent(this, DownloadService.class);downloadIntent.setData(Uri.parse(fileUrl));startService(downloadIntent); 如何使用隐式Intent12345678910// Create the text message with a stringIntent sendIntent = new Intent();sendIntent.setAction(Intent.ACTION_SEND);sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage);sendIntent.setType(HTTP.PLAIN\\_TEXT\\_TYPE); // \"text/plain\" MIME type// Verify that the intent will resolve to an activityif (sendIntent.resolveActivity(getPackageManager()) != null) &#123; startActivity(sendIntent);&#125; 强制显示应用程序选择器有的时候，我们需要应用程序必须弹出应用程序的选择界面来供用户选择，可以按照下面的方法： 12345678910111213Intent sendIntent = new Intent(Intent.ACTION_SEND);...// Always use string resources for UI text.// This says something like \"Share this photo with\"String title = getResources().getString(R.string.chooser_title);// Create intent to show the chooser dialogIntent chooser = Intent.createChooser(sendIntent, title);// Verify the original intent will resolve to at least one activityif (sendIntent.resolveActivity(getPackageManager()) != null) &#123; startActivity(chooser);&#125; 区别在于，这里使用Intent.createChoose(Intent,String)的方法包装了原有的Inent。 接收隐式Intent如果需要接收一个隐式的Intent，那么需要在程序的menifest file中配置对应的，每个intent-filter都需要指定接收的intent的action，data，category。如果一个Intent的数据与我们的intent-filter相匹配的话，那么系统就会调用相应的Intent 系统会根据此配置将其发送到相应的位置。 注意，显式intent不会关心intent-filter中设置的内容，因为其本身已经制定Component Name，不需要额外的信息来查找要启动的系统组件。 每一个系统组件都应该指定与其所能做的工作相对应的intent-filter。比如，在gallery的一个activity可能会有两个filters：一个用来查看图片，一个用来编辑图片。当该activity启动的时候，会根据intent的内容来决定要如何处理。 每一个intent filter都是通过应用程序中的manifest中，对应的系统组件之内的元素来定义的。在其中我们可以为其指定action元素，或者更多。 ：定义了intent接收到 action类型，在name属性中。该属性必须是一个action字符串，而不是类的常量。 ：定义了接收的数据类型，使用一个或者更多的属性来识别data URI的不同片段，比如scheme，host，port，path以及MIME类型。 ：定义了intent接收的category类型，在name属性中。同action一样，比如为字符串。 需要注意的是：为了能够使得隐式Intent能够通过 startActivity()) and startActivityForResult()) 启动组件，比如要在其中的cagegory中添加CATEGORTY_DEFAULT，否则的话，该组件不会被系统识别。 1234567&lt;activity android:name=\"ShareActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.SEND\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:mimeType=\"text/plain\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 当然，如果我们需要，可以在一个intent-filter当中指定多个&lt;action&gt;, &lt;data&gt;, or [&lt;category&gt;](http://developer.android.com/guide/topics/manifest/category-element.html)，但如果我们这样做的话，只有在这里面的信息全部匹配的时候，对应的component才会被系统调用。 如果我们我们需要处理多种类型的intents，但仅仅是指定的action,data,category组合，那么我们需要创建多个intent-filter。 一个隐式的inent要看和filter是否匹配，会一次匹配上面的3个元素。 注意：为了避免不小心运行了其他的应用程序的Service，我们始终要记住使用显式Intent启动Service，并不要为Service设置任何intent-filter。 笔记：对于activities，intent-filter必须在manifest文件中声明。但broadcast receivers所使用的intent-filter可以通过调用 [registerReceiver()](http://developer.android.com/reference/android/content/Context.html#registerReceiver(android.content.BroadcastReceiver, android.content.IntentFilter, java.lang.String, android.os.Handler)). [unregisterReceiver()](http://developer.android.com/reference/android/content/Context.html#unregisterReceiver(android.content.BroadcastReceiver))来实现。 限制component的访问权限使用intent filter并不是一个安全的方法来避免其他的应用程序来启动我们的系统组件。虽然intent filters限制了一个系统组件仅仅会相应设置的一种或者几种对应的隐式intent，但其他的应用程序如果开发者知道你的系统组件的component names的话，仍然可以启动。因此为了保证仅仅我们自己的程序能够启动相应的组件，我们应该为相应的component设置exported标签为false。 例子12345678910111213141516171819202122232425&lt;activity android:name=\"MainActivity\"&gt; &lt;!\\-\\- This activity is the main entry, should appear in app launcher --&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name=\"ShareActivity\"&gt; &lt;!\\-\\- This activity handles \"SEND\" actions with text data --&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.SEND\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:mimeType=\"text/plain\"/&gt; &lt;/intent-filter&gt; &lt;!\\-\\- This activity also handles \"SEND\" and \"SEND_MULTIPLE\" with media data --&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.SEND\"/&gt; &lt;action android:name=\"android.intent.action.SEND_MULTIPLE\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:mimeType=\"application/vnd.google.panorama360+jpg\"/&gt; &lt;data android:mimeType=\"image/*\"/&gt; &lt;data android:mimeType=\"video/*\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; Using a Pending IntentPendingIntent是对Intent的封装。使用PendingIntent的主要目的之一在于保证其他的应用程序能够获得对应的权限，就好像这个intent是从我们自己的程序中自己的进程中调用的一样。 PendingIntent主要的使用于： Notification中，用户点击Notification，然后系统的NotificationManager运行这个Intent App Widget。当用户点击桌面上的小控件的时候，桌面程序执行的Intent。 Alarm。以后在某个特定时间去执行的Intent，比如Android的AlarmManager在固定时间去执行的这个Intent。 由于在系统中，大量的PendingIntent在设计的时候其目的是相同的，因此必须为了不同的PendingIntent中的不同的组件类型设置不同的PendingIntent。有以下3中调用。 [PendingIntent.getActivity()](http://developer.android.com/reference/android/app/PendingIntent.html#getActivity(android.content.Context, int, android.content.Intent, int)) for an [Intent](http://developer.android.com/reference/android/content/Intent.html) that starts an [Activity](http://developer.android.com/reference/android/app/Activity.html). [PendingIntent.getService()](http://developer.android.com/reference/android/app/PendingIntent.html#getService(android.content.Context, int, android.content.Intent, int)) for an [Intent](http://developer.android.com/reference/android/content/Intent.html) that starts a [Service](http://developer.android.com/reference/android/app/Service.html). [PendingIntent.getBroadcast()](http://developer.android.com/reference/android/app/PendingIntent.html#getBroadcast(android.content.Context, int, android.content.Intent, int)) for a [Intent](http://developer.android.com/reference/android/content/Intent.html) that starts an [BroadcastReceiver](http://developer.android.com/reference/android/content/BroadcastReceiver.html). 根据API Guide的文档，除非应用程序是在接受来自其他的app的PendingIntents，那么以上的方法应该是使用的所有的方法。 Intent Resolution注意下data的识别原则： 每个intent-filter可以包含0个或者多个data元素，比如说： &lt;intent-filter&gt; &lt;data android:mimeType=&quot;video/mpeg&quot; android:scheme=&quot;http&quot; ... /&gt; &lt;data android:mimeType=&quot;audio/mpeg&quot; android:scheme=&quot;http&quot; ... /&gt; ... &lt;/intent-filter&gt; 每一个元素都可以确定一个URI结构和数据类型(MIME media type)。有几个分开的属性，scheme，host，port，path。 ://:/content://com.example.project:200/folder/subfolder/etc 每一个属性都是可选的，但是遵循以下的线性规则： 如果scheme没有确定，那么host会被忽略。 如果host没有确定，那么port会被忽略。 如果scheme和host都没有被设定，path会被忽略。 在对URI验证的时候，是按照以下的思路进行： 如果filter仅仅确定了scheme，那么所有有用同样的scheme的URIs会被match 如果确定了scheme和authority，但是没有path；那么所有的URIs会比对schme和authority，忽略path 如果scheme，authority，path都确定了，那么只有所有的全部一样的时候才会被确定。 Note: A path specification can contain a wildcard asterisk (*) to require only a partial match of the path name. 如果在intent-filter中同时设定了URI和MIME类型，那么会按照以下的规则判断： 如果一个intent既不包含URI，也不包含MIME，那么仅仅会通过没有指定URI或者MIME的filter。 如果一个intent包含URI，但不包含MIME（既不单独指定，也无法从URI中获取），那么仅仅会通过指定了URI并且match，而MIME又没有配置的filter。 如果一个intent包含了MIME类型，但是不包含URI，那么仅仅会通过包含了MIME并且match，而且不包含URI的filter 如果一个intent即包含URI，也包含MIME（可以单独设定，也可以是从URI中获取），那么MIME部分会判断是不是符合，对于URI部分，如果URI match 或者 在filter不识别URI的时候，URI包含content:或者file:，那么会认为match。换句话说，一个filter仅支持MIME类型的时候，组件是默认支持content:以及file:的。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"App Components","slug":"Android/App-Components","permalink":"http://yoursite.com/categories/Android/App-Components/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Intent","slug":"Intent","permalink":"http://yoursite.com/tags/Intent/"},{"name":"Intent-filters","slug":"Intent-filters","permalink":"http://yoursite.com/tags/Intent-filters/"}]},{"title":"Android中Activity四种启动模式和taskAffinity属性详解 （转载）","slug":"android-differences-between-activity-start-mode-and-task-affinity","date":"2014-11-29T07:34:39.000Z","updated":"2018-10-03T16:12:52.546Z","comments":true,"path":"2014/11/29/android-differences-between-activity-start-mode-and-task-affinity/","link":"","permalink":"http://yoursite.com/2014/11/29/android-differences-between-activity-start-mode-and-task-affinity/","excerpt":"","text":"转自http://blog.csdn.net/zhangjg_blog/article/details/10923643 感谢原作者。 在android应用开发中，打造良好的用户体验是非常重要的。而在用户体验中，界面的引导和跳转是值得深入研究的重要内容。在开发中，与界面跳转联系比较紧密的概念是Task（任务）和Back Stack（回退栈）。activity的启动模式会影响Task和Back Stack的状态，进而影响用户体验。除了启动模式之外，Intent类中定义的一些标志（以FLAG_ACTIVITY_开头）也会影响Task和Back Stack的状态。在这篇文章中主要对四种启动模式进行分析和验证，其中涉及到activity的一个重要属性taskAffinity和Intent中的标志之一FLAG_ACTIVITY_NEW_TASK。关于Intent中其他标志位的具体用法会在另一篇文章中介绍。 Task是一个存在于Framework层的概念，容易与它混淆的有Application（应用）和Process（进程）。在开始介绍Activity的启动模式的使用之前，首先对这些概念做一个简单的说明和区分。 一 Application，Task和Process的区别与联系。application翻译成中文时一般称为“应用”或“应用程序”，在android中，总体来说一个应用就是一组组件的集合。众所周知，android是在应用层组件化程度非常高的系统，android开发的第一课就是学习android的四大组件。当我们写完了多个组件，并且在manifest文件中注册了这些组件之后，把这些组件和组件使用到的资源打包成apk，我们就可以说完成了一个application。application和组件的关系可以在manifest文件中清晰地体现出来。如下所示：123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;manifest android:versionCode=\"1\" android:versionName=\"1\" xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.android.myapp\"&gt; &lt;application android:label=\"@string/app_name\"&gt; &lt;activity android:name=\".MyActivity\" android:label=\"@string/app_nam\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;receiver android:name=\".MyReceiver\"/&gt; &lt;provider android:name=\".MyProvider\"/&gt; &lt;service android:name=\".MyService\"/&gt; &lt;/application&gt; &lt;/manifest&gt; 由此可见，application是由四大组件组成的。在app安装时，系统会读取manifest的信息，将所有的组件解析出来，以便在运行时对组件进行实例化和调度。 而task是在程序运行时，只针对activity的概念。说白了，task是一组相互关联的activity的集合，它是存在于framework层的一个概念，控制界面的跳转和返回。这个task存在于一个称为back stack的数据结构中，也就是说，framework是以栈的形式管理用户开启的activity。这个栈的基本行为是，当用户在多个activity之间跳转时，执行压栈操作，当用户按返回键时，执行出栈操作。举例来说，如果应用程序中存在A,B,C三个activity，当用户在Launcher或Home Screen点击应用程序图标时，启动主Activity A，接着A开启B，B开启C，这时栈中有三个Activity，并且这三个Activity默认在同一个任务（task）中，当用户按返回时，弹出C，栈中只剩A和B，再按返回键，弹出B，栈中只剩A，再继续按返回键，弹出A，任务被移除。如下图所示： task是可以跨应用的，这正是task存在的一个重要原因。有的Activity，虽然不在同一个app中，但为了保持用户操作的连贯性，把他们放在同一个任务中。例如，在我们的应用中的一个Activity A中点击发送邮件，会启动邮件程序的一个Activity B来发送邮件，这两个activity是存在于不同app中的，但是被系统放在一个任务中，这样当发送完邮件后，用户按back键返回，可以返回到原来的Activity A中，这样就确保了用户体验。 说完了application和task，最后介绍process。process一般翻译成进程，进程是操作系统内核中的一个概念，表示直接受内核调度的执行单位。在应用程序的角度看，我们用java编写的应用程序，运行在dalvik虚拟机中，可以认为一个运行中的dalvik虚拟机实例占有一个进程，所以，在默认情况下，一个应用程序的所有组件运行在同一个进程中。但是这种情况也有例外，即，应用程序中的不同组件可以运行在不同的进程中。只需要在manifest中用process属性指定组件所运行的进程的名字。如下所示： 123&lt;activity android:name=\".MyActivity\" android:label=\"@string/app_nam\" android:process=\":remote\"&gt; &lt;/activity&gt; 这样的话这个activity会运行在一个独立的进程中。 二 Activity四种启动模式详解activity有四种启动模式，分别为standard，singleTop，singleTask，singleInstance。如果要使用这四种启动模式，必须在manifest文件中标签中的launchMode属性中配置，如： 12345&lt;activity android:name=\".app.InterstitialMessageActivity\" android:label=\"@string/interstitial_label\" android:theme=\"@style/Theme.Dialog\" android:launchMode=\"singleTask\" &lt;/activity&gt; 同样，在Intent类中定义了很多与Activity启动或调度有关的标志，标签中有一些属性，这些标志，属性和四种启动模式联合使用，会在很大程度上改变activity的行为，进而会改变task和back stask的状态。关于Intent中的标志和标签中有一些属性会在本文后面介绍，在这一节中，先介绍activity的四种启动模式。 standard 标准启动模式，也是activity的默认启动模式。在这种模式下启动的activity可以被多次实例化，即在同一个任务中可以存在多个activity的实例，每个实例都会处理一个Intent对象。如果Activity A的启动模式为standard，并且A已经启动，在A中再次启动Activity A，即调用startActivity（new Intent（this，A.class）），会在A的上面再次启动一个A的实例，即当前的桟中的状态为A–&gt;A。 singleTop 如果一个以singleTop模式启动的activity的实例已经存在于任务桟的桟顶，那么再启动这个Activity时，不会创建新的实例，而是重用位于栈顶的那个实例，并且会调用该实例的onNewIntent()方法将Intent对象传递到这个实例中。举例来说，如果A的启动模式为singleTop，并且A的一个实例已经存在于栈顶中，那么再调用startActivity（new Intent（this，A.class））启动A时，不会再次创建A的实例，而是重用原来的实例，并且调用原来实例的onNewIntent()方法。这是任务桟中还是这有一个A的实例。 如果以singleTop模式启动的activity的一个实例已经存在与任务桟中，但是不在桟顶，那么它的行为和standard模式相同，也会创建多个实例。 singleTask 谷歌的官方文档上称，如果一个activity的启动模式为singleTask，那么系统总会在一个新任务的最底部（root）启动这个activity，并且被这个activity启动的其他activity会和该activity同时存在于这个新任务中。如果系统中已经存在这样的一个activity则会重用这个实例，并且调用他的onNewIntent()方法。即，这样的一个activity在系统中只会存在一个实例。 其实官方文档中的这种说法并不准确，启动模式为singleTask的activity并不会总是开启一个新的任务。详情请参考 解开Android应用程序组件Activity的”singleTask”之谜，在本文后面也会通过示例来进行验证。 singleInstance 总是在新的任务中开启，并且这个新的任务中有且只有这一个实例，也就是说被该实例启动的其他activity会自动运行于另一个任务中。当再次启动该activity的实例时，会重用已存在的任务和实例。并且会调用这个实例的onNewIntent()方法，将Intent实例传递到该实例中。和singleTask相同，同一时刻在系统中只会存在一个这样的Activity实例。 三 实例验证singleTask启动模式上面将activity的四种启动模式就基本介绍完了。为了加深对启动模式的了解，下面会通过一个简单的例子进行验证。由以上的介绍可知，standard和singleTop这两种启动模式行为比较简单，所以在下面的例子中，会对singleTask和singleInstance着重介绍。 验证启动singleTask模式的activity时是否会创建新的任务以下为验证示例AndroidTaskTest。这个实例中有三个Activity，分别为：MainActivity，SecondActivity和ThirdActivity。以下为这个示例的manifest文件。 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.jg.zhang.androidtasktest\" android:versionCode=\"1\" android:versionName=\"1.0\" &gt; &lt;uses-sdk android:minSdkVersion=\"10\" android:targetSdkVersion=\"17\" /&gt; &lt;application android:icon=\"@drawable/ic\\_launcher\" android:label=\"@string/app\\_name\"&gt; &lt;activity android:label=\"@string/app_name\" android:name=\"com.jg.zhang.androidtasktest.MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!--android:taskAffinity=\"com.jg.zhang.androidtasktest.second\" android:alwaysRetainTaskState=\"true\" android:allowBackup=\"true\" --&gt; &lt;activity android:name=\"com.jg.zhang.androidtasktest.SecondActivity\" android:launchMode=\"singleTask\"&gt; &lt;intent-filter &gt; &lt;action android:name=\"com.jg.zhang.androidtasktest.SecondActivity\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\"com.jg.zhang.androidtasktest.ThirdActivity\" android:label=\"@string/app_name\" &gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; 由此可见，MainActivity和ThirdActivity都是标准的启动模式，而SecondActivity的启动模式为singleTask。 以下为这三个Activity的界面，很简单，在MainActivity中点击按钮启动SecondActivity，在SecondActivity中点击按钮启动ThirdActivity。 以下为这三个activity的主要代码： MainActivity MainActivity 12345678910111213141516171819202122public class MainActivity extends Activity &#123; private static final String ACTIVITY_NAME = \"MainActivity\"; private static final String LOG_TAG = \"xxxx\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.button1).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(MainActivity.this, SecondActivity.class); startActivity(intent); &#125; &#125;); int taskId = getTaskId(); Log.i(LOG\\_TAG, ACTIVITY\\_NAME +\"所在的任务的id为: \" + taskId); &#125; SecondActivity1234567891011121314151617181920public class SecondActivity extends Activity &#123; private static final String ACTIVITY_NAME = \"SecondActivity\"; private static final String LOG_TAG = \"xxxx\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); findViewById(R.id.button2).setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(SecondActivity.this, ThirdActivity.class); startActivity(intent); &#125; &#125;); int taskId = getTaskId(); Log.i(LOG\\_TAG, ACTIVITY\\_NAME +\"所在的任务的id为: \" + taskId); &#125; ThirdActivity123456789101112public class ThirdActivity extends Activity &#123; private static final String ACTIVITY_NAME = \"ThirdActivity\"; private static final String LOG_TAG = \"xxxx\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_third); int taskId = getTaskId(); Log.i(LOG\\_TAG, ACTIVITY\\_NAME +\"所在的任务的id为: \" + taskId); &#125; 以上三个activity只列出了onCreate（）方法中的内容，实现的逻辑为在MainActivity中点击按钮启动SecondActivity，在SecondActivity中点击按钮启动ThirdActivity。并且在onCreate方法中会以log的形式打印出当前activity所属的任务（Task）的Id。 现在执行以下操作，运行该示例，并且点击MainActivity界面中的按钮，开启SecondActivity。在该示例中SecondActivity的启动模式为singleTask。按照官方文档的说法，SecondActivity会在一个新的任务中开启。但是查看打印出的log，发现MainActivity和SecondActivity所在的任务的Id相同。 在命令行中执行以下命令 adb shell dumpsys activity ， 有以下输出： TaskRecord{412ded08 #8 A com.jg.zhang.androidtasktest} Run #2: ActivityRecord{412c91e8 com.jg.zhang.androidtasktest/.SecondActivity} Run #1: ActivityRecord{412c08a0 com.jg.zhang.androidtasktest/.MainActivity} 所以，和官方文档表述的不同，MainActivity和SecondActivity是启动在同一个任务中的。其实，把启动模式设置为singleTask，framework在启动该activity时只会把它标示为可在一个新任务中启动，至于是否在一个新任务中启动，还要受其他条件的限制。现在在SecondActivity增加一个taskAffinity属性，如下所示：12345678&lt;activity android:name=\"com.jg.zhang.androidtasktest.SecondActivity\" android:launchMode=\"singleTask\" android:taskAffinity=\"com.jg.zhang.androidtasktest.second\"&gt; &lt;intent-filter &gt; &lt;action android:name=\"com.jg.zhang.androidtasktest.SecondActivity\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 重新运行该示例，执行相同的操作，即：点击MainActivity界面中的按钮，开启SecondActivity，并且点击SecondActivity中的按钮，启动ThirdActivity，log中输出的内容为： 在命令行中执行adb shell dumpsys activity命令，有以下输出： TaskRecord{411e6a88 #6 A com.jg.zhang.androidtasktest.second} Run #3: ActivityRecord{411c8ea0 com.jg.zhang.androidtasktest/.ThirdActivity} Run #2: ActivityRecord{412bc870 com.jg.zhang.androidtasktest/.SecondActivity}TaskRecord{412ece18 #5 A com.jg.zhang.androidtasktest} Run #1: ActivityRecord{412924c0 com.jg.zhang.androidtasktest/.MainActivity} 由此可见，MainActivity和SecondActivity运行在不同的任务中了，并且被SecondActivity启动的ThirdActivity和SecondActivity运行在同一个任务中。这种现象的具体解释可以参考解开Android应用程序组件Activity的”singleTask”之谜。 在这里便引出了manifest文件中的一个重要属性，taskAffinity。在官方文档中可以得到关于taskAffinity的以下信息 taskAffinity表示当前activity具有亲和力的一个任务（翻译不是很准确，原句为The task that the activity has an affinity for.），大致可以这样理解，这个 taskAffinity表示一个任务，这个任务就是当前activity所在的任务。 在概念上，具有相同的affinity的activity（即设置了相同taskAffinity属性的activity）属于同一个任务。 一个任务的affinity决定于这个任务的根activity（root activity）的taskAffinity。 这个属性决定两件事：当activity被re-parent时，它可以被re-paren哪个任务中；当activity以FLAG_ACTIVITY_NEW_TASK标志启动时，它会被启动到哪个任务中。（这个比较 难以理解，请结合中的属性allowTaskReparenting和Intent中的标志 FLAG_ACTIVITY_NEW_TASK加以理解） 默认情况下，一个应用中的所有activity具有相同的taskAffinity，即应用程序的包名。我们可以通过设置不同的taskAffinity属性给应用中的activity分组，也可以把不同的 应用中的activity的taskAffinity设置成相同的值。 为一个activity的taskAffinity设置一个空字符串，表明这个activity不属于任何task。 这就可以解释上面示例中的现象了，由第5条可知，MainActivity和SecondActivity具有不同的taskAffinity，MainActivity的taskAffinity为com.jg.zhang.androidtasktest，SecondActivity的taskAffinity为com.jg.zhang.androidtasktest.second,根据上面第4条，taskAffinity可以影响当activity以FLAG_ACTIVITY_NEW_TASK标志启动时，它会被启动到哪个任务中。这句话的意思是，当新启动的activity（SecondActivity）是以FLAG_ACTIVITY_NEW_TASK标志启动时（可以认为FLAG_ACTIVITY_NEW_TASK和singleTask作用相同，当启动模式为singleTask时，framework会将它的启动标志设为FLAG_ACTIVITY_NEW_TASK），framework会检索是否已经存在了一个affinity为com.jg.zhang.androidtasktest.second的任务（即一个TaskRecord对象） 如果存在这样的一个任务，则检查在这个任务中是否已经有了一个SecondActivity的实例 如果已经存在一个SecondActivity的实例，则会重用这个任务和任务中的SecondActivity实例，将这个任务调到前台，清除位于SecondActivity上面的所有Activity，显示SecondActivity，并调用SecondActivity的onNewIntent（）； 如果不存在一个SecondActivity的实例，会在这个任务中创建SecondActivity的实例，并调用onCreate()方法 如果不存在这样的一个任务，会创建一个新的affinity为com.jg.zhang.androidtasktest.second的任务，并且将SecondActivity启动到这个新的任务中 上面讨论的是设置taskAffinity属性的情况，如果SecondActivity只设置启动模式为singleTask，而不设置taskAffinity，即三个Activity的taskAffinity相同，都为应用的包名，那么SecondActivity是不会开启一个新任务的，framework中的判定过程如下： 在MainActivity启动SecondActivity时，发现启动模式为singleTask，那么设定他的启动标志为FLAG_ACTIVITY_NEW_TASK 然后获得SecondActivity的taskAffinity，即为包名com.jg.zhang.androidtasktest 检查是否已经存在一个affinity为com.jg.zhang.androidtasktest的任务，这个任务是存在的，就是MainActivity所在的任务，这个任务是在启动MainActivity时开启的 既然已经存在这个任务，就检索在这个任务中是否存在一个SecondActivity的实例，发现不存在 在这个已有的任务中启动一个SecondActivity的实例 为了作一个清楚的比较，列出SecondActivity启动模式设为singleTask，并且taskAffinity设为com.jg.zhang.androidtasktest.second时的启动过程 在MainActivity启动SecondActivity时，发现启动模式为singleTask，那么设定他的启动标志为FLAG_ACTIVITY_NEW_TASK 然后获得SecondActivity的taskAffinity，即com.jg.zhang.androidtasktest.second 检查是否已经存在一个affinity为com.jg.zhang.androidtasktest.second的任务，这个任务是不存在的 创建一个新的affinity为com.jg.zhang.androidtasktest.second的任务，并且将SecondActivity启动到这个新的任务中 其实framework中对任务和activity‘的调度是很复杂的，尤其是把启动模式设为singleTask或者以FLAG_ACTIVITY_NEW_TASK标志启动时。所以，在使用singleTask和FLAG_ACTIVITY_NEW_TASK时，要仔细测试应用程序。这也是官方文档上的建议。 实例验证将两个不同app中的不同的singleTask模式的Activity的taskAffinity设成相同官方文档中提到，可以把不同的 应用中的activity的taskAffinity设置成相同的值，这样的话这两个activity虽然不在同一应用中，却会在运行时分配到同一任务中，下面对此进行验证，在这里，会使用上面的示例AndroidTaskTest，并创建一个新的示例AndroidTaskTest1。AndroidTaskTest1由两个activity组成，分别为MianActivity和OtherActivity，在MianActivity中点击按钮会启动OtherActivity，该程序的界面和上一个类似，代码也类似，再此仅列出清单文件。 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.jg.zhang.androidtasktest1\" android:versionCode=\"1\" android:versionName=\"1.0\" &gt; &lt;uses-sdk android:minSdkVersion=\"9\" android:targetSdkVersion=\"17\" /&gt; &lt;application android:allowBackup=\"true\" android:icon=\"@drawable/ic\\_launcher\" android:label=\"@string/app\\_name\" android:theme=\"@style/AppTheme\" &gt; &lt;activity android:name=\"com.jg.zhang.androidtasktest1.MainActivity\" android:label=\"com.jg.zhang.androidtasktest1.MainActivity\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\"com.jg.zhang.androidtasktest1.OtherActivity\" android:label=\"com.jg.zhang.androidtasktest1.OtherActivity\" android:taskAffinity=\"com.jg.zhang.androidtasktest.second\" android:launchMode=\"singleTask\"&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; 可以看到OtherActivity的启动模式被设置为singleTask，并且taskAffinity属性被设置为com.jg.zhang.androidtasktest.second，这和AndroidTaskTest应用中的SecondActivity相同。现在将这两个应用安装在设备上。执行以下操作： 启动AndroidTaskTest应用，在它的MianActivity中点击按钮开启SecondActivity，由上面的介绍可知secondActivity是运行在一个新任务中的，这个任务就是com.jg.zhang.androidtasktest.second。 然后按Home键回到Launcher，启动AndroidTaskTest1，在启动AndroidTaskTest1的入口Activity（MianActivity）时，会自动启动新的任务，那么现在一共有三个任务，AndroidTaskTest的MianActivity和SecondActivity分别占用一个任务，AndroidTaskTest1的MianActivity也占用一个任务。 在AndroidTaskTest1的MianActivity中点击按钮启动OtherActivity，那么这个OtherActivity是在哪个任务中呢？ 下面执行adb shell dumpsys activity命令，发现有以下输出： 1234567891011121314151617181920TaskRecord&#123;412370c0 #4 A com.jg.zhang.androidtasktest.second&#125; Intent &#123; cmp=com.jg.zhang.androidtasktest/.SecondActivity &#125; Hist #4: ActivityRecord&#123;412f5ba0 com.jg.zhang.androidtasktest1/.OtherActivity&#125; Intent &#123; flg=0x400000 cmp=com.jg.zhang.androidtasktest1/.OtherActivity &#125; ProcessRecord&#123;412adb28 479:com.jg.zhang.androidtasktest1/10044&#125; Hist #3: ActivityRecord&#123;4125c880 com.jg.zhang.androidtasktest/.SecondActivity&#125; Intent &#123; cmp=com.jg.zhang.androidtasktest/.SecondActivity &#125; ProcessRecord&#123;41218e48 463:com.jg.zhang.androidtasktest/10043&#125;TaskRecord&#123;412f0f60 #5 A com.jg.zhang.androidtasktest1&#125; Intent &#123; act=android.intent.action.MAIN cat=\\[android.intent.category.LAUNCHER\\] flg=0x10200000 cmp=com.jg.zhang.androidtasktest1/.MainActivity &#125; Hist #2: ActivityRecord&#123;413045a8 com.jg.zhang.androidtasktest1/.MainActivity&#125; Intent &#123; act=android.intent.action.MAIN cat=\\[android.intent.category.LAUNCHER\\] flg=0x10200000 cmp=com.jg.zhang.androidtasktest1/.MainActivity &#125; ProcessRecord&#123;412adb28 479:com.jg.zhang.androidtasktest1/10044&#125; TaskRecord&#123;412c5928 #3 A com.jg.zhang.androidtasktest&#125; Intent &#123; act=android.intent.action.MAIN cat=\\[android.intent.category.LAUNCHER\\] flg=0x10200000 cmp=com.jg.zhang.androidtasktest/.MainActivity &#125; Hist #0: ActivityRecord&#123;41250850 com.jg.zhang.androidtasktest/.MainActivity&#125; Intent &#123; act=android.intent.action.MAIN cat=\\[android.intent.category.LAUNCHER\\] flg=0x10200000 cmp=com.jg.zhang.androidtasktest/.MainActivity &#125; ProcessRecord&#123;41218e48 463:com.jg.zhang.androidtasktest/10043&#125; 在执行上述操作时，打印出的Log为： 所以由此可见，AndroidTaskTest的SecondActivity和AndroidTaskTest1的OtherActivity是在同一任务中的。由上面adb shell dumpsys activity命令的输出结果（蓝色字体）还可以看出，AndroidTaskTest和AndroidTaskTest1这两个应用程序会开启两个进程，他们的所有组件分别运行在独立的进程中，其中AndroidTaskTest所在进程的进程号为10043，AndroidTaskTest1所在进程的进程号为10044。com.jg.zhang.androidtasktest.second任务中的两个activity属于不同的应用，并且运行在不同的进程中，这也说明了一个问题：任务（Task）不仅可以跨应用（Application），还可以跨进程（Process）。 实例验证singleTask的另一意义：在同一个任务中具有唯一性谷歌官方文档中提到，singleTask模式的activity总会在一个新的任务中开启。上面已经验证了这种说法不确切，singleTask模式只意味着“可以在一个新的任务中开启”，至于是不是真的会在新任务中开启，在framework中还有其他条件的限制。由上面的介绍可知，这个条件为：是否已经存在了一个由他的taskAffinity属性指定的任务。这一点具有迷惑性，我们在看到singleTask这个单词的时候，会直观的想到它的本意：single in task。即，在同一个任务中，只会有一个该activity的实例。现在让我们进行验证： 为了验证这种情况，需要修改一下上面用到的AndroidTaskTest示例。增加一个FourthActivity，并且MianActivity，SecondActivity，ThirdActivity和FourthActivity这四个activity都不设置taskAffinity属性，并且将SecondActivity启动模式设为singleTask，这样这四个activity会在同一个任务中开启。他们的开启流程是这样的：MianActivity开启SecondActivity，SecondActivity开启ThirdActivity，ThirdActivity开启FourthActivity，FourthActivity开启SecondActivity。代码和软件界面就不列出了，只列出清单文件 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.jg.zhang.androidtasktest\" android:versionCode=\"1\" android:versionName=\"1.0\" &gt; &lt;uses-sdk android:minSdkVersion=\"10\" android:targetSdkVersion=\"17\" /&gt; &lt;application android:allowBackup=\"true\" android:icon=\"@drawable/ic_launcher\" android:label=\"androidtasktest\"&gt; &lt;activity android:name=\"com.jg.zhang.androidtasktest.MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\"com.jg.zhang.androidtasktest.SecondActivity\" android:launchMode=\"singleTask\"/&gt; &lt;activity android:name=\"com.jg.zhang.androidtasktest.ThirdActivity\"/&gt; &lt;activity android:name=\"com.jg.zhang.androidtasktest.FourthActivity\"/&gt; &lt;/application&gt; &lt;/manifest&gt; 现在从MianActivity一直启动到FourthActivity，打印出的系统Log为： 由此可见这四个activity都是在同一个任务中的。再次执行adb shell dumpsys activity命令加以验证： 12345TaskRecord&#123;412e9458 #6 A com.jg.zhang.androidtasktest&#125; Run #4: ActivityRecord&#123;412e12e8 com.jg.zhang.androidtasktest/.FourthActivity&#125; Run #3: ActivityRecord&#123;412a9e30 com.jg.zhang.androidtasktest/.ThirdActivity&#125; Run #2: ActivityRecord&#123;412a4dd8 com.jg.zhang.androidtasktest/.SecondActivity&#125; Run #1: ActivityRecord&#123;4122fae0 com.jg.zhang.androidtasktest/.MainActivity&#125; 同样可以说明目前这四个activity都运行在affinity为com.jg.zhang.androidtasktest的任务中，即栈中的状态为MainActivity –&gt; SecondActivity –&gt; ThirdActivity –&gt; FourthActivity。 下面执行在FourthActivity中点击按钮启动SecondActivity的操作，注意，SecondActivity的启动模式为singleTask，那么现在栈中的情况如何呢？再次执行adb shell dumpsys activity命令，有以下输出： 123TaskRecord&#123;412e9458 #6 A com.jg.zhang.androidtasktest&#125; Run #2: ActivityRecord&#123;412a4dd8 com.jg.zhang.androidtasktest/.SecondActivity&#125; Run #1: ActivityRecord&#123;4122fae0 com.jg.zhang.androidtasktest/.MainActivity&#125; 这时栈中的状态为MainActivity –&gt; SecondActivity。确实确保了在任务中是唯一的，并且清除了同一任务中它上面的所有Activity。 那么这个SecondActivity的实例是重用的上次已有的实例还是重新启动了一个实例呢？可以观察系统Log， 发现系统Log没有改变，还是上面的四条Log。打印Log的语句是在各个Activity中的onCreate方法中执行的，没有打印出新的Log，说明SecondActivity的onCreate的方法没有重新执行，也就是说是重用的上次已经启动的实例，而不是销毁重建。 经过上面的验证，可以得出如下的结论：在启动一个singleTask的Activity实例时，如果系统中已经存在这样一个实例，就会将这个实例调度到任务栈的栈顶，并清除它当前所在任务中位于它上面的所有的activity。 四 实例验证singleInstance的行为根据上面的讲解，并且参考谷歌官方文档，singleInstance的特点可以归结为以下三条： 以singleInstance模式启动的Activity具有全局唯一性，即整个系统中只会存在一个这样的实例 以singleInstance模式启动的Activity具有独占性，即它会独自占用一个任务，被他开启的任何activity都会运行在其他任务中（官方文档上的描述为，singleInstance模式的Activity不允许其他Activity和它共存在一个任务中） 被singleInstance模式的Activity开启的其他activity，能够开启一个新任务，但不一定开启新的任务，也可能在已有的一个任务中开启 下面对这三个特点分别验证，所使用的示例同样为AndroidTaskTest，只不过会进行一些修改，下面列出它的清单文件： 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.jg.zhang.androidtasktest\" android:versionCode=\"1\" android:versionName=\"1.0\" &gt; &lt;uses-sdk android:minSdkVersion=\"10\" android:targetSdkVersion=\"17\" /&gt; &lt;application android:allowBackup=\"true\" android:icon=\"@drawable/ic_launcher\" android:label=\"androidtasktest\"&gt; &lt;activity android:name=\"com.jg.zhang.androidtasktest.MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\"com.jg.zhang.androidtasktest.SecondActivity\" android:launchMode=\"singleInstance\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.jg.zhang.androidtasktest.ACTION_MY\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\"com.jg.zhang.androidtasktest.ThirdActivity\"/&gt; &lt;/application&gt; &lt;/manifest&gt; 由上面的清单文件可以知道，该应用包括三个activity，分别为MianActivity，SecondActivity，ThirdActivity，其中SecondActivity启动模式设置为singleInstance。MianActivity可以开启SecondActivity，SecondActivity可以开启ThirdActivity。 并且为了可以在其他应用中开启SecondActivity，为SecondActivity设置了一个IntentFilter，这样就可以在其他应用中使用隐式Intent开启SecondActivity。 为了更好的验证singleInstance的全局唯一性，还需要其他一个应用，对上面的AndroidTaskTest1进行一些修改即可。AndroidTaskTest1只需要一个MianActivity，在MainActivity中点击按钮会开启AndroidTaskTest应用中的SecondActivity。开启AndroidTaskTest应用中的SecondActivity的代码如下： 1234567891011121314/** * 该方法在布局中按钮的android:onClick属性中指定 * android:onClick=\"launchOtherActivity\" * @param v */ public void launchOtherActivity(View v)&#123; Intent intent = new Intent(); //以下Action为\"com.jg.zhang.androidtasktest.ACTION_MY\" //即AndroidTaskTest应用中SecondActivity的action intent.setAction(\"com.jg.zhang.androidtasktest.ACTION_MY\"); startActivity(intent); &#125; 下面开始验证第一个特点：以singleInstance模式启动的Activity具有全局唯一性，即整个系统中只会存在一个这样的实例 执行如下操作：安装AndroidTaskTest应用，点击MainActivity中的按钮，开启SecondActivity，可以看到如下log输出： 执行adb shell dumpsys activity命令，有以下输出： 1234TaskRecord&#123;411189e0 #9 A com.jg.zhang.androidtasktest&#125; Run #2: ActivityRecord&#123;4129af80 com.jg.zhang.androidtasktest/.SecondActivity&#125;TaskRecord&#123;41305528 #8 A com.jg.zhang.androidtasktest&#125; Run #1: ActivityRecord&#123;41296e60 com.jg.zhang.androidtasktest/.MainActivity&#125; 以上可以说明，singleInstance模式的Activity总是会在新的任务中运行(前提是系统中还不存在这样的一个实例) 。 下面验证它的全局唯一性，执行以下操作：安装另一个应用AndroidTaskTest1，在开启的MainActivity中点击按钮开启AndroidTaskTest应用中的SecondActivity。看到打印出一条新的日志： 执行adb shell dumpsys activity命令，有以下输出： 123456TaskRecord&#123;411189e0 #9 A com.jg.zhang.androidtasktest&#125; Run #3: ActivityRecord&#123;4129af80 com.jg.zhang.androidtasktest/.SecondActivity&#125;TaskRecord&#123;412dc788 #12 A com.jg.zhang.androidtasktest1&#125; Run #2: ActivityRecord&#123;4121c628 com.jg.zhang.androidtasktest1/.MainActivity&#125;TaskRecord&#123;41305528 #8 A com.jg.zhang.androidtasktest&#125; Run #1: ActivityRecord&#123;41296e com.jg.zhang.androidtasktest/.MainActivity&#125; 由红色字体可以得知，开启的SecondActivity就是上次创建的编号为4129af80的SecondActivity，并且Log中没有再次输出关于SecondActivity的信息，说明SecondActivity并没有重新创建。由此可以得出结论：以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。 下面开始验证第二个特点：以singleInstance模式启动的Activity具有独占性，即它会独自占用一个任务，被他开启的任何activity都会运行在其他任务中 重新安装AndroidTaskTest应用，点击MainActivity中的按钮，开启SecondActivity，在SecondActivity中点击按钮，开启ThirdActivity。可以看到有如下Log输出： 执行adb shell dumpsys activity命令，有以下输出： 123456TaskRecord&#123;412a95b8 #15 A com.jg.zhang.androidtasktest&#125; Run #3: ActivityRecord&#123;411f9318 com.jg.zhang.androidtasktest/.ThirdActivity&#125;TaskRecord&#123;41353a68 #16 A com.jg.zhang.androidtasktest&#125; Run #2: ActivityRecord&#123;413537c8 com.jg.zhang.androidtasktest/.SecondActivity&#125;TaskRecord&#123;412a95b8 #15 A com.jg.zhang.androidtasktest&#125; Run #1: ActivityRecord&#123;4123a0c8 com.jg.zhang.androidtasktest/.MainActivity&#125; SecondActivity所在的任务为16，被SecondActivity启动的ThirdActivity所在的任务为15，这就说明以singleInstance模式启动的Activity具有独占性，即它会独自占用一个任务，被他开启的任何activity都会运行在其他任务中。 下面开始验证第三个特点：被singleInstance模式的Activity开启的其他activity，能够在新的任务中启动，但不一定开启新的任务，也可能在已有的一个任务中开启 有上面对第二个特点的验证可以看到，被SecondActivity启动的ThirdActivity并没有运行在一个新开启的任务中，而是和MainActivity运行在了同一个已有的任务中，那么在什么情况下ThirdActivity才会启动一个新的任务呢？ 现在对程序的清单文件做以下修改，为ThirdActivity增加一个属性taskAffinity： 12&lt;activity android:name=\"com.jg.zhang.androidtasktest.ThirdActivity\" android:taskAffinity=\"com.jg.zhang.androidtasktest.second\"/&gt; 重新安装AndroidTaskTest应用，执行和上一步中同样的操作：点击MainActivity中的按钮，开启SecondActivity，在SecondActivity中点击按钮，开启ThirdActivity。可以看到有如下输出： 执行adb shell dumpsys activity命令，有以下输出： 123456TaskRecord&#123;413551b0 #20 A com.jg.zhang.androidtasktest.second&#125; Run #3: ActivityRecord&#123;412de9c0 com.jg.zhang.androidtasktest/.ThirdActivity&#125;TaskRecord&#123;4134b268 #19 A com.jg.zhang.androidtasktest&#125; Run #2: ActivityRecord&#123;412a36a0 com.jg.zhang.androidtasktest/.SecondActivity&#125;TaskRecord&#123;413131e8 #18 A com.jg.zhang.androidtasktest&#125; Run #1: ActivityRecord&#123;41271e10 com.jg.zhang.androidtasktest/.MainActivity&#125; 可见，被SecondActivity启动的ThirdActivity启动在了一个新的任务中，即在启动ThirdActivity时创建了一个新任务。这就说明被singleInstance模式的Activity A在开启另一activity B时，能够开启一个新任务，但是是不是真的开启新任务，还要受其他条件的限制，这个条件是：当前系统中是不是已经有了一个activity B的taskAffinity属性指定的任务。 其实这种行为和singleTask启动时的情况相同。在Activity的启动模式设置为singleTask时，启动时系统会为它加上FLAG_ACTIVITY_NEW_TASK标志，而被singleInstance模式的Activity开启的activity，启动时系统也会为它加上FLAG_ACTIVITY_NEW_TASK标志，所以他们启动时的情况是相同的，上面再验证singleTask时已经阐述过，现在重新说明一下： 由于ThirdActivity是被启动模式为singleInstance类型的Activity（即SecondActivity）启动的，framework会为它它加上FLAG_ACTIVITY_NEW_TASK标志，这时 framework会检索是否已经存在了一个affinity为com.jg.zhang.androidtasktest.second（即ThirdActivity的taskAffinity属性）的任务， 如果存在这样的一个任务，则检查在这个任务中是否已经有了一个ThirdActivity的实例， 如果已经存在一个ThirdActivity的实例，则会重用这个任务和任务中的ThirdActivity实例，将这个任务调到前台，清除位于ThirdActivity上面的所有Activity，显示ThirdActivity，并调用ThirdActivity的onNewIntent（）。 如果不存在一个ThirdActivity的实例，会在这个任务中创建ThirdActivity的实例，并调用onCreate()方法 如果不存在这样的一个任务，会创建一个新的affinity为com.jg.zhang.androidtasktest.second的任务，并且将ThirdActivity启动到这个新的任务中 如果ThirdActivity不设置taskAffinity，即ThirdActivity和MainActivity的taskAffinity相同，都为应用的包名，那么ThirdActivity是不会开启一个新任务的，framework中的判定过程如下： 在SecondActivity启动ThirdActivity时，因为SecondActivity是singleInstance的，所以设定ThirdActivity的启动标志为FLAG_ACTIVITY_NEW_TASK 然后获得ThirdActivity的taskAffinity，即为包名com.jg.zhang.androidtasktest 检查是否已经存在一个affinity为com.jg.zhang.androidtasktest的任务，这个任务是存在的，就是MainActivity所在的任务，这个任务是在启动MainActivity时开启的 既然已经存在这个任务，就检索在这个任务中是否存在一个ThirdActivity的实例，发现不存在 在这个已有的任务中启动一个SecondActivity的实例 为了作一个清楚的比较，列出ThirdActivity的taskAffinity属性设为com.jg.zhang.androidtasktest.second时的启动过程 在SecondActivity启动ThirdActivity时，因为SecondActivity是singleInstance的，那么设定ThirdActivity的启动标志为FLAG_ACTIVITY_NEW_TASK 然后获得ThirdActivity的taskAffinity，即为com.jg.zhang.androidtasktest.second 检查是否已经存在一个affinity为com.jg.zhang.androidtasktest.second的任务，这个任务是不存在的 创建一个新的affinity为com.jg.zhang.androidtasktest.second的任务，并且将ThirdActivity启动到这个新的任务 到此singleInstance也介绍完了。 五 本文小结由上述可知，Task是Android Framework中的一个概念，Task是由一系列相关的Activity组成的，是一组相关Activity的集合。Task是以栈的形式来管理的。 我们在操作软件的过程中，一定会涉及界面的跳转。其实在对界面进行跳转时，Android Framework既能在同一个任务中对Activity进行调度，也能以Task为单位进行整体调度。在启动模式为standard或singleTop时，一般是在同一个任务中对Activity进行调度，而在启动模式为singleTask或singleInstance是，一般会对Task进行整体调度。 对Task进行整体调度包括以下操作： 按Home键，将之前的任务切换到后台 长按Home键，会显示出最近执行过的任务列表 在Launcher或HomeScreen点击app图标，开启一个新任务，或者是将已有的任务调度到前台 启动singleTask模式的Activity时，会在系统中搜寻是否已经存在一个合适的任务，若存在，则会将这个任务调度到前台以重用这个任务。如果这个任务中已经存在一个要启动的Activity的实例，则清除这个实例之上的所有Activity，将这个实例显示给用户。如果这个已存在的任务中不存在一个要启动的Activity的实例，则在这个任务的顶端启动一个实例。若这个任务不存在，则会启动一个新的任务，在这个新的任务中启动这个singleTask模式的Activity的一个实例。 启动singleInstance的Activity时，会在系统中搜寻是否已经存在一个这个Activity的实例，如果存在，会将这个实例所在的任务调度到前台，重用这个Activity的实例（该任务中只有这一个Activity），如果不存在，会开启一个新任务，并在这个新任务中启动这个singleInstance模式的Activity的一个实例。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"launchMode","slug":"launchMode","permalink":"http://yoursite.com/tags/launchMode/"},{"name":"Task","slug":"Task","permalink":"http://yoursite.com/tags/Task/"}]},{"title":"Volley与Picasso的对比","slug":"android-volley-picasso-comparation","date":"2014-11-27T08:37:38.000Z","updated":"2018-10-03T16:12:52.605Z","comments":true,"path":"2014/11/27/android-volley-picasso-comparation/","link":"","permalink":"http://yoursite.com/2014/11/27/android-volley-picasso-comparation/","excerpt":"","text":"想写一篇文章来对比一下Volley以及Picasso，有人或许会说了，Volley和Picasso的服务对象都不同，Picasso是专注于图片的下载以及处理，而Volley则适应于任何轻量的网络请求。是的，的确如此，那我们不如就图片下载缓存这个应用场景展开来，来对比分析Volley和Picasso的相同之处与不同之处。 首先我们先来看一下Volley和Picasso的整体框图。 Volley： Picasso： 其中Volley是官方给出的整体框架图，而Picasso是我自己根据源代码抽离出来的，可能有些地方不是那么准确，请大家指教。先说一下从上面两张框架图对比，发现的其中的不同之处： 对请求对象的封装不同： 在Volley中，请求会直接封装在Reqeust当中，包括目标的网址/回调的接口等等信息，直接提交给CacheDispatcher即可。 在Picasso中，一个请求会依次封装成ReqeustCreator，Reqeust，Action等不同状态，其中ReqeustCreator是用于创建Reqeust，在ReqeustCreator中可以设置图片的地址，大小，是否居中，是否旋转，图片的后处理等等参数，通过ReqeustCreator中拥有一个RequestBuilder对象；当用户调用into(Target)方法的时候，通过RequestBuilder中的build()方法，会构造出Reqeust，然后构造出对应的Action方法，提交至Dispatcher队列进行处理。 Dispatcher不同： 在Volley中，Dispatcher包括CacheDispatcher和NetworkDispatcher两部分，其中CacheDispatcher只有一个线程，而NetworkDispatcher默认会有4个线程在执行。 在Picasso当中，所有的任务的分发都是通过一个Dispatcher，即DispatcherThread工作线程来完成。 消息的传递方式不同： 当添加任务的时候： Volley是通过阻塞队列实现，所有的Dispatcher(包括CacheDispatcher和NetworkDispatcher)。 Picasso添加任务是通过Handler，将Action作为消息的Message中的object的进行传递。 当任务结束，发送消息的时候： Volley是通过Handler实现，但不会在消息中传递具体的任务，而是负责发送消息，并使用handler.post()方法将要执行的代码发送到主线程上执行。 Picasso是将任务的包装类BitmapHunter作为Message的object来进行传递。 Cache MemoryCache Volley中，对于普通的任务，并没有设定MemoryCache，我理解的这是因为Volley的设计初衷是用于那些轻量级的网络访问，一般不会占用太大内存，所有不需要再使用MemoryCache，使用DiskBasedCache，性能也能满足。而服务于图片的ImageLoader，其中明确要求我们实现一个MemoryCache以供使用。 Picasso由于其设计服务对象就是图片，因此其本身自带的Cache就是MemoryCache DiskCache Volley中默认实现的Cache就是DiskBasedCache，根据网络请求结果根据情况保存在Cache当中。 Picasso其本身并不支持DiskCache，但根据我在StackOverflow查到的结果，有网友说，其DiskCache依赖于其网络库，默认的为Square自己的OKHttp，okhttp内部已经实现有网络Cache，未考察(参考：stackoverflow)。 支持的请求来源不同： Volley仅支持从网络上访问图片或者其他的资源。 Picasso支持从网络，File，Resource，Asserts中加载图片。 支持的请求对象不同： Volley支持图片，Json，String等等各种各样的网络请求，而且可以很容易的扩展自己的实现。 Picasso仅仅支持图片。 任务优先级的支持： Volley支持任务的优先级 Picasso没有任务的优先级这一说 图片后续处理的支持： Volley不支持通过注册函数的方式实现图片的后处理，仅仅可以在收到请求完成的回调之后，自己进行图片的后处理。 Picasso可以通过注册Transformer的形式，对获取的图片进行后续处理，完成之后再通知完成动作。参考：Picasso的使用：使用Transformation，下载后预处理图片并显示 任务的暂停： Volley不支持 Picasso支持，通过调用Picasso中的pauseTag(Object tag)实现 说完不同的，再来看看Volley和Picasso在设计的时候都考虑到的地方，这也是在我们需要设计自己的图形缓存库的时候，更加需要注意到的地方： 主线程仅负责任务的添加和完成时的回调，其他的任务又其他线程负责处理 老生常谈了，主线程不能做太多的事情，否则ANR有好看的。 允许多个任务同时进行处理 多个线程是优化效率的一种特别有效的手段，比如多个任务同时进行的时候，可以同时下载，提高效率。 根据不同的网络情况，按需调整或者重新设置同时工作线程数目： Volley和Picasso当中，都根据网络状态的不同，规定了不同的同时进行的网络请求数目，既能充分利用网络，又不至于榨干系统网络请求资源。 这个地方是我之前理解有错误，在默认情况下，Picasso是可以根据网络的不同设置不同的网络请求并发数目，但实际上Volley中并不存在这个功能，其默认newRequestQueue生成的ReqeustQueue其指定的并发数目为4，因此如果有需要，需要自己手动编写一层封装，以实现根据网络状态设置工作线程数目的目的。感谢千醉z。 要有Cache 分为MemoryCache和DiskCache，MemoryCache不多说了，对于图片来说，必须要有的，要不频繁解码，容易OOM不说，解码消耗的大量时间，用户体验也会很差。 支持批量任务的添加、删除、暂定 比如当一个Activity退出的时候，总要有办法能够同时取消该Activity对应的所有的网络请求的。 避免OOM 同一个时刻，仅仅允许一张图片进行解码操作，这个Picasso是从Volley中学来的。 大体上就想到这些，总体上，如果我们的需求仅仅需要处理图片，那么Picasso在功能上可以说远远要优于Volley，是我们的第一选择，但如果我们图片的需求并不是特别强烈，同时还在网络上传输一些数据，那么Volley可能更加适合。如果大家有别的看法，一起讨论。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Picasso","slug":"Android/Picasso","permalink":"http://yoursite.com/categories/Android/Picasso/"},{"name":"Volley","slug":"Android/Picasso/Volley","permalink":"http://yoursite.com/categories/Android/Picasso/Volley/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Picasso","slug":"Picasso","permalink":"http://yoursite.com/tags/Picasso/"},{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/tags/Volley/"},{"name":"对比","slug":"对比","permalink":"http://yoursite.com/tags/对比/"}]},{"title":"Picasso源代码分析：5、Picasso架构分析","slug":"picasso-source-code-5-architecture","date":"2014-11-27T02:43:38.000Z","updated":"2018-10-03T16:12:52.534Z","comments":true,"path":"2014/11/27/picasso-source-code-5-architecture/","link":"","permalink":"http://yoursite.com/2014/11/27/picasso-source-code-5-architecture/","excerpt":"","text":"在之前Volley的学习当中，我们始终跟随者Volley的架构图进行分析，了解到Volley整体上分为3层线程，UI线程负责将Reqeust添加到ReqeustQueue当中，CacheDispatcher负责将从DiskCache中获取Response，如果Cache Hit，则直接分发结果至UI线程，如果Cache Miss，那么就将Reqeust添加至NetworkQueue当中，然后NetworkDispatcher则从队列中获取任务病执行，最后在UI线程中将结果分发。详细的可以参看：《Volley源代码学习总结》。 那么Picasso呢？这段时间我们学习Picasso，发现去文档、注释确实要远远逊色于Volley，说实话Picasso的代码风格个人也并不是很喜欢。但不能否认，Picasso是一个设计的十分细致的工具库。那整体框架是怎么样的呢？我根据这几天的学习以及个人的理解，按照Volley的架构图风格，给Picasso画了一张架构图。 大体一看，感觉和Volley很相近，但其实两者有很多细微上的不同，这里我们先不多说，后面会写一篇文章来对比Picasso和Volley。 我们来仔细看一下这张图，我来用文字再描述一边其整体的设计： 我们以一个任务的执行流程来描述一下Picasso的工作流程流程，最初的分析可以参考《Picasso源代码分析：1、跟随代码的角度，当我们添加了一个任务，到底发生了什么？》，其中不同的线程所做的工作，我会用上图中对应的颜色进行标注： Picasso.with(Context).load(“http://www.baidu.com/img/bdlogo.png&quot;).into(imageview); 初始化Picasso，实例化其唯一的对象。 根据传入的Url、File、resource Id，构建ReqeustCreator对象 根据ReqeustCreator构建Request对象，同时根据Reqeust属性，尝试从Cache中访问数据 Cache Hit，则通过回调，设置Target或者ImageView，完成该Reqeust 如果Cache Miss，那么则构建相应的Action，并提交到DispatcherThread当中。 Dispatcher中的Handler接收到相应的Message，调用dispatcher.performSubmit(action)进行处理。 创建BitmapHunter对象，并提交到PicassoExecutorService线程池 再次检查Memory Cache中已经有缓存，如果Hit，则读取缓存中的Bitmap 如果Cache miss，则交给Action对应的ReqeustHandler进行处理，比如网络请求，或者从File读取图片 返回结果之后，通知Dispatcher中的Handler处理结果。 DispatcherThread中将BitmapHunter的结果打包(batch)，最快200ms打包一次。通知主线程HANDLER进行处理 主线程HANDLER接收打包的BitmapHunter，对最后的结果进行分发。 我觉得应该从Picasso中学习到的设计图形缓存库的几个注意的地方： 异步执行：包括任务的调度分发，任务的执行。 结果的分发：所有的任务其结果通过主线程进行分发。 避免内存泄漏：在Dispatcher中，使用WeakHashMap保存当前任务。 避免OOM：同一时刻，仅允许一张图片进行解码，进行Transformation。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Picasso","slug":"Android/Picasso","permalink":"http://yoursite.com/categories/Android/Picasso/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Picasso","slug":"Picasso","permalink":"http://yoursite.com/tags/Picasso/"},{"name":"架构","slug":"架构","permalink":"http://yoursite.com/tags/架构/"}]},{"title":"Picasso源代码分析：4、任务的分发 Dispatcher","slug":"picasso-source-code-4-dispatcher","date":"2014-11-26T09:15:43.000Z","updated":"2018-10-03T16:12:52.533Z","comments":true,"path":"2014/11/26/picasso-source-code-4-dispatcher/","link":"","permalink":"http://yoursite.com/2014/11/26/picasso-source-code-4-dispatcher/","excerpt":"","text":"Picasso的源代码分析已经到了第4届，之前我们依次分析了Picasso，ReqeustCreaor，BitmapHunter，Picasso是Picasso框架的入口，同时也负责初始化各种工作的子线程，工作的实例；RequestCreator则是对任务的描述；而BitmapHunter则是一个具体的工作的线程，接受Picasso中配置好的调度池的调度同时负责知道对应的ReqeustHandler去执行数据请求，并将结果解析为图片，还可以进行一些图片的处理(Transformation)。但之前我们的分析中一直没有考虑到的一点是，在Picasso当中，任务到底是怎么调度的？任务到底怎么添加进来？添加进来之后都做了哪些工作？任务失败之后重试策略如何(Picasso目前还没有看到类似Volley那种明显的RetryPolicy)？所以，接下来，我们要分析Dispatcher。Github Dispatcher首先，在Dispatcher中定义了很多的事件，如下： static final int REQUEST_SUBMIT = 1; static final int REQUEST_CANCEL = 2; static final int REQUEST_GCED = 3; static final int HUNTER_COMPLETE = 4; static final int HUNTER_RETRY = 5; static final int HUNTER_DECODE_FAILED = 6; static final int HUNTER_DELAY_NEXT_BATCH = 7; static final int HUNTER_BATCH_COMPLETE = 8; static final int NETWORK_STATE_CHANGE = 9; static final int AIRPLANE_MODE_CHANGE = 10; static final int TAG_PAUSE = 11; static final int TAG_RESUME = 12; static final int REQUEST_BATCH_RESUME = 13; 当Picasso.java中调用submit等方法的时候，会从Handler中获取相应的Message并发送给hanlder进行处理。因此我们首先要提出疑问： handler工作在哪个线程成？ handler收到Message之后，其处理过程是怎么样？ 先不着急，按照代码的顺序接着往下分析： 构造函数： Dispatcher(Context context, ExecutorService service, Handler mainThreadHandler, Downloader downloader, Cache cache, Stats stats) { //任务分发线程，继承自ThreadHandler this.dispatcherThread = new DispatcherThread(); this.dispatcherThread.start(); this.context = context; this.service = service; //注意这个地方使用了LinkedHashMap，肯定要其特殊的考虑，暂时还不清楚。 this.hunterMap = new LinkedHashMap&lt;String, BitmapHunter&gt;(); //此处使用了两个WeakHashMap，也就说，一旦外部放弃对对应的Ojbect的引用的话，该Entry就会在GC时被回收。 this.failedActions = new WeakHashMap&lt;Object, Action&gt;(); this.pausedActions = new WeakHashMap&lt;Object, Action&gt;(); //暂停的任务集合 this.pausedTags = new HashSet(); //这里就是处理分发任务的Handler，查看源代码可以知道，DispatcherHandler工作在dispatcherThread的线程之上。 this.handler = new DispatcherHandler(dispatcherThread.getLooper(), this); this.downloader = downloader; //保留主线程的Handler的引用 this.mainThreadHandler = mainThreadHandler; this.cache = cache; this.stats = stats; //一个列表，用来保存BitmapHunter的batch，但还不清楚为什么要限制size为4？ this.batch = new ArrayList(4); //是否为飞行模式 this.airplaneMode = Utils.isAirplaneModeOn(this.context); //是否拥有检测网络状态变化的权限 this.scansNetworkChanges = hasPermission(context, Manifest.permission.ACCESS_NETWORK_STATE); //注册网络状态的广播接收 this.receiver = new NetworkBroadcastReceiver(this); receiver.register(); } 在代码中我添加了注释，同时这个时候，我们就可以解释上面提到的第一个问题，handler是工作在哪个线程之上的？当然是dispatcherThread。 那DispatcherThread是怎么样的呢？ static class DispatcherThread extends HandlerThread { DispatcherThread() { super(Utils.THREAD_PREFIX + DISPATCHER_THREAD_NAME, THREAD_PRIORITY_BACKGROUND); }} 哈哈，更简单，其实就是一个HandlerThread，只是设置了Thread Name和优先级为BACKGROUND而已。 shutdown()方法，关闭Dispatcher void shutdown() { // Shutdown the thread pool only if it is the one created by Picasso. // 关闭Picasso创建的线程池 if (service instanceof PicassoExecutorService) { service.shutdown(); } // 关闭downlaoder downloader.shutdown(); // 退出dispatcherThread dispatcherThread.quit(); // Unregister network broadcast receiver on the main thread. // 在主线程上注销receiver，注意和上面的Dispatcher构造函数区分，在构造函数中，没有特别说明需要在主线程上调用receiver.register()， Picasso.HANDLER.post(new Runnable() { @Override public void run() { receiver.unregister(); } }); } 有一个地方我们可以注意到的是，在构造函数中，广播接收器没有说明需要在主线程上运行，但关闭的时候，取消注册是在主线程上运行的，我们知道，广播的onReceive方法是在主线程上运行，但是广播的注册和取消注册，也必须要在主线程上进行吗？这个问题以后需要再讨论一下。 接下来我们去看看再Dispatcher中的Handler到底是如何处理各种消息的。 //Dispacher的处理函数private static class DispatcherHandler extends Handler { private final Dispatcher dispatcher; // 根据Dispatcher中调用的构造函数DispatcherHandler(dispatcherThread.getLooper(), this)可以看出， // 该Handler其实是工作在DispatcherThread之上的。 public DispatcherHandler(Looper looper, Dispatcher dispatcher) { super(looper); this.dispatcher = dispatcher; } // 根据不同的Message，调用dispatcher中对应的不同的方法。 @Override public void handleMessage(final Message msg) { switch (msg.what) { case REQUEST_SUBMIT: { //Action提交之后，会调用dispatcher.performSubmit(action)函数。 Action action = (Action) msg.obj; dispatcher.performSubmit(action); break; } case REQUEST_CANCEL: { Action action = (Action) msg.obj; dispatcher.performCancel(action); break; } case TAG_PAUSE: { Object tag = msg.obj; dispatcher.performPauseTag(tag); break; } case TAG_RESUME: { Object tag = msg.obj; dispatcher.performResumeTag(tag); break; } case HUNTER_COMPLETE: { BitmapHunter hunter = (BitmapHunter) msg.obj; dispatcher.performComplete(hunter); break; } case HUNTER_RETRY: { BitmapHunter hunter = (BitmapHunter) msg.obj; dispatcher.performRetry(hunter); break; } case HUNTER_DECODE_FAILED: { BitmapHunter hunter = (BitmapHunter) msg.obj; dispatcher.performError(hunter, false); break; } case HUNTER_DELAY_NEXT_BATCH: { dispatcher.performBatchComplete(); break; } case NETWORK_STATE_CHANGE: { NetworkInfo info = (NetworkInfo) msg.obj; dispatcher.performNetworkStateChange(info); break; } case AIRPLANE_MODE_CHANGE: { dispatcher.performAirplaneModeChange(msg.arg1 == AIRPLANE_MODE_ON); break; } default: Picasso.HANDLER.post(new Runnable() { @Override public void run() { throw new AssertionError(“Unknown handler message received: “ + msg.what); } }); } }} 其实很简单，构造函数中，将Handler与DispatcherThread绑定在一起，所有的消息都在DispatcherThread中进行处理。那么Dispatcher具体是怎么处理各种请求的呢？这可是Picasso怎么去处理一个任务的核心内容，我们来看一下依次的处理函数： performSubmit(Action action, boolean dismissFailed) //执行提交的actionvoid performSubmit(Action action, boolean dismissFailed) { //如果pausedTags包含了对应的action if (pausedTags.contains(action.getTag())) { //那么将action放入到pausedActions当中(我擦，还有暂停功能) pausedActions.put(action.getTarget(), action); if (action.getPicasso().loggingEnabled) { log(OWNER_DISPATCHER, VERB_PAUSED, action.request.logId(), “because tag ‘“ + action.getTag() + “‘ is paused”); } return; } // 看看该任务是否已经添加过。 BitmapHunter hunter = hunterMap.get(action.getKey()); if (hunter != null) { hunter.attach(action); return; } //服务终止。。。 if (service.isShutdown()) { if (action.getPicasso().loggingEnabled) { log(OWNER_DISPATCHER, VERB_IGNORED, action.request.logId(), “because shut down”); } return; } //根据任务的uri，找到真正可以执行该任务的对应的Handler，重新封装为一个BitmapHunter hunter = forRequest(action.getPicasso(), this, cache, stats, action); //提交任务，并且获取一个future hunter.future = service.submit(hunter); //将提交过的任务放入hunterMap当中 hunterMap.put(action.getKey(), hunter); //忽略失败标志。 if (dismissFailed) { failedActions.remove(action.getTarget()); } if (action.getPicasso().loggingEnabled) { log(OWNER_DISPATCHER, VERB_ENQUEUED, action.request.logId()); }} 我画了一个流程图 简单的理解，就是根据Action创建BitmapHunter，前面我们已经看过，BitmapHunter为一个线程，因此将该线程提交到PicassoExecutorService中执行，获取对应的future，这样即可。 performCancel(Action action) performCancel的逻辑和performSubmit思路大体上相同的，只是其逆序而已，因此我们直接在代码中分析其业务逻辑来看看。 void performCancel(Action action) { // 获取对应的key String key = action.getKey(); // 从hunterMap中获取对应的BitmapHunter BitmapHunter hunter = hunterMap.get(key); // 如果hunter存在，则调用hunter.detach(action)和hunter.cancel()删除任务 if (hunter != null) { // 将对应的action从hunter当中删除 hunter.detach(action); // 如果返回true，那么以为这已经没有对应的actions，并且future也通过cancel()函数取消掉了 if (hunter.cancel()) { // 该BitmapHunter不会用到了，删除 hunterMap.remove(key); if (action.getPicasso().loggingEnabled) { log(OWNER_DISPATCHER, VERB_CANCELED, action.getRequest().logId()); } } } // 如果暂停的pasusedTags中还有对应的action if (pausedTags.contains(action.getTag())) { // 从队列中删除 pausedActions.remove(action.getTarget()); if (action.getPicasso().loggingEnabled) { log(OWNER_DISPATCHER, VERB_CANCELED, action.getRequest().logId(), “because paused request got canceled”); } } // 从失败列表中删除对应的action Action remove = failedActions.remove(action.getTarget()); if (remove != null &amp;&amp; remove.getPicasso().loggingEnabled) { log(OWNER_DISPATCHER, VERB_CANCELED, remove.getRequest().logId(), “from replaying”); }} 上面是performCancel(Action action)的代码，其逻辑也比较简单，就是各种队列中删除对应的action信息。 performPauseTag(Object tag) void performPauseTag(Object tag) { // Trying to pause a tag that is already paused. // 如果返回true，说明添加成功，set已经修改，如果false，说明该tag已经在pasuedTags中，也就是说，任务已经暂停过了。 if (!pausedTags.add(tag)) { return; } // Go through all active hunters and detach/pause the requests // that have the paused tag. // 遍历全部正在执行的hunter们，如果BitmapHunter对应的Action有相应的pausedTag，那么就暂定对应的BitmapHunter for (Iterator it = hunterMap.values().iterator(); it.hasNext();) { BitmapHunter hunter = it.next(); boolean loggingEnabled = hunter.getPicasso().loggingEnabled; // 获取hunter对应的action，已经后来detached的actions。 Action single = hunter.getAction(); List&lt;Action&gt; joined = hunter.getActions(); // 如果joined不为空，并且有元素，那么说明该BitmapHunter拥有多个Action同时附件在上面 boolean hasMultiple = joined != null &amp;&amp; !joined.isEmpty(); // Hunter has no requests, bail early. 此处说明BitmapHunter没有请求。 if (single == null &amp;&amp; !hasMultiple) { continue; } // 如果下面判断为真，说明需要暂停对应的Action if (single != null &amp;&amp; single.getTag().equals(tag)) { // 从hunter中detach该Action hunter.detach(single); // 将该Action放入pausedActions队列当中 pausedActions.put(single.getTarget(), single); if (loggingEnabled) { log(OWNER\\_DISPATCHER, VERB\\_PAUSED, single.request.logId(), &quot;because tag &apos;&quot; + tag + &quot;&apos; was paused&quot;); } } // 如果BitmapHunter还有附加的其他的Actions，那么还需要依次检查他们。 if (hasMultiple) { for (int i = joined.size() - 1; i &gt;= 0; i--) { Action action = joined.get(i); if (!action.getTag().equals(tag)) { continue; } hunter.detach(action); pausedActions.put(action.getTarget(), action); if (loggingEnabled) { log(OWNER\\_DISPATCHER, VERB\\_PAUSED, action.request.logId(), &quot;because tag &apos;&quot; + tag + &quot;&apos; was paused&quot;); } } } // Check if the hunter can be cancelled in case all its requests // had the tag being paused here. if (hunter.cancel()) { it.remove(); if (loggingEnabled) { log(OWNER\\_DISPATCHER, VERB\\_CANCELED, getLogIdsForHunter(hunter), &quot;all actions paused&quot;); } } }} 有个地方比较有意思，需要仔细考虑的：此处的tag并不是之前我们说的cacheKey，cacheKey一般是根据图片的网址或者大小而设定的，一般用于缓存等情况；而此处的tag则一般是用来暂定恢复任务，那什么时候要暂定或者恢复任务呢？ 我进入一个Activity，要使用Picasso显示一个图片，但我希望在Activity退出的时候，该图片只是暂停，因为我后面很快还要用到，那这个时候就应该使用恢复和暂停，那Tag呢？这种情况下使用Activity的名字作为tag就完全可以。 performResumeTag(Object tag) void performResumeTag(Object tag) { // Trying to resume a tag that is not paused. // 尝试恢复tag对应的暂停的请求 if (!pausedTags.remove(tag)) { return; } // 将同一个tag对应的Action放在一个List当中 List batch = null; for (Iterator i = pausedActions.values().iterator(); i.hasNext();) { Action action = i.next(); if (action.getTag().equals(tag)) { if (batch == null) { batch = new ArrayList(); } batch.add(action); i.remove(); } } if (batch != null) { // 通知主线程进行处理 mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(REQUEST_BATCH_RESUME, batch)); }} 执行恢复任务的处理函数，其实这段代码比较简单，就做了两件事情： 从pausedActions中找到所有的tag对应的Action，将其放入到batch的List当中。 该batch通过主线程的Handler发送到主线程上去处理。 这个和其他的就明显不一样啊，其他的任务处理函数，一般在DispatcherThread线程上就处理完成了，那这个为什么要发送到主线程上去处理呢？还是先去看看再主线程的HANDLER上，接收到这个Message之后，到底做了什么工作？相关的代码片段： case REQUEST_BATCH_RESUME: //请求被恢复了，还不太懂其业务逻辑。 @SuppressWarnings(“unchecked”) List batch = (List) msg.obj; for (int i = 0, n = batch.size(); i &lt; n; i++) { Action action = batch.get(i); action.picasso.resumeAction(action); } break; 之前的时候还不清楚这个是怎么的逻辑，现在清晰一些，其实是在主线程上，依次通过Picasso中的resumeAction(action)函数将其唤醒。那resumeAction(action)又做了什么工作呢？ 在Picasso中我们有分析过这段代码的作用，我们现在再回过头来看一下。 void resumeAction(Action action) { Bitmap bitmap = null; if (!action.skipCache) { bitmap = quickMemoryCacheCheck(action.getKey()); } if (bitmap != null) { // Resumed action is cached, complete immediately. deliverAction(bitmap, MEMORY, action); if (loggingEnabled) { log(OWNER_MAIN, VERB_COMPLETED, action.request.logId(), “from “ + MEMORY); } } else { // Re-submit the action to the executor. enqueueAndSubmit(action); if (loggingEnabled) { log(OWNER_MAIN, VERB_RESUMED, action.request.logId()); } }} 现在看就简单明了，同样的两步工作： 尝试从Cache中获取Bitmap，如果有，则直接通过deliverAction(bitmap, MEMORY, action)派发相应。 如果没有，那么说明需要重新执行请求，将action添加到队列当中，并提交。 performRetry(BitmapHunter hunter) void performRetry(BitmapHunter hunter) { if (hunter.isCancelled()) return; if (service.isShutdown()) { performError(hunter, false); return; } // 检查网络状态 NetworkInfo networkInfo = null; if (scansNetworkChanges) { ConnectivityManager connectivityManager = getService(context, CONNECTIVITY_SERVICE); networkInfo = connectivityManager.getActiveNetworkInfo(); } // 是否有网络连接 boolean hasConnectivity = networkInfo != null &amp;&amp; networkInfo.isConnected(); // 根据当前的网络状态和BitmapHunter的重试次数，来判断是否需要重试 boolean shouldRetryHunter = hunter.shouldRetry(airplaneMode, networkInfo); // BitmapHunter中保存的Action对应的RequestHandler是否支持重试？ boolean supportsReplay = hunter.supportsReplay(); if (!shouldRetryHunter) { // Mark for replay only if we observe network info changes and support replay. // 如果BitmapHunter的重试次数已经用完，还是要根据当前的网络状态看看是否还让其重新尝试 boolean willReplay = scansNetworkChanges &amp;&amp; supportsReplay; // 通知执行performError performError(hunter, willReplay); // 如果网络状态变化，并且RequestHandler支持重试，那么就重新尝试 if (willReplay) { // 标记以重新尝试 ，调用markForReplay(hunter)，实际上是将对应的Action放入到failedActions当中。 markForReplay(hunter); } return; } // If we don’t scan for network changes (missing permission) or if we have connectivity, retry. // 此时对于BitmapHunter来说，支持网络重试，如果受权限限制无法检查网络状态，或者是网络连接，那么直接重试。 if (!scansNetworkChanges || hasConnectivity) { if (hunter.getPicasso().loggingEnabled) { log(OWNER_DISPATCHER, VERB_RETRYING, getLogIdsForHunter(hunter)); } // 向service提交该hunter。 hunter.future = service.submit(hunter); return; } performError(hunter, supportsReplay); // 如果支持重试，调用markForReplay(hunter)，实际上是将对应的Action放入到failedActions当中。 if (supportsReplay) { markForReplay(hunter); }} 这里面主要做了以下的事情： 检查对应的BtimapHunter是否还有重试机会，如果有，那么如果网络又畅通，则直接将对应的BitmapHunter提交到service当中 如果BitmapHunter没有重试机会，已经用完了，那么就检查下对应的Handler是否支持重试，如果可以的话，则将其放入到failedActions队列当中。 performComplete(BitmapHunter hunter) &amp;&amp; performBatchComplete() 当BitmapHunter执行完成之后，会给Dispatcher的Handler发送Message，Handler的处理函数会调用performComplete(BitmapHunter hunter)函数进行处理。其代码如下： void performComplete(BitmapHunter hunter) { // 是否要跳过Memory Cache if (!hunter.shouldSkipMemoryCache()) { // 不跳过的话，则将hunter的key和结果放入Cache当中Result为对应的图像 cache.set(hunter.getKey(), hunter.getResult()); } // 从hunterMap中删除该hunter hunterMap.remove(hunter.getKey()); // 打包，看说明是将hunter放到batch的list当中，并检查如果没有HUNTER_DELAY_NEXT_BATCH，则200ms之后，发送该Message // handler处理该Message，其实实际上直接调用performBatchComplete() batch(hunter); if (hunter.getPicasso().loggingEnabled) { log(OWNER_DISPATCHER, VERB_BATCHED, getLogIdsForHunter(hunter), “for completion”); }} void performBatchComplete() { // 打包处理，同时取出batch所有的BitmapHunter，并发送给主线程Handler进行处理。 List copy = new ArrayList(batch); batch.clear(); mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy)); logBatch(copy);} Picasso对BitmapHunter执行的任务结果的分发采用了打包的机制进行处理，换句话说，所有的BitmapHunter执行完成之后，会调用performComplete(BitmapHunter hunter)，在该方法中，Picasso将hunter放入batch列表中，然后在Handler中的Messages中是否有HUNTER_DELAY_NEXT_BATCH等待执行，如果没有，那么则等200ms之后再分发，而此时hunter已经加入到batch当中。200ms之后，Handler接收到HUNTER_DELAY_NEXT_BATCH的Message，则将batch中所有的BitmapHunter的结果一起进行处理。 我们接着看看主线程的HANDLER接收到HUNTER_BATCH_COMPLETE的消息的时候，是如何处理的： case HUNTER_BATCH_COMPLETE: { //此处应该是和Volley一样，打包处理的图形库，因为这些图片可能地址以及大小都是一样的所有打包在一起进行处理。 @SuppressWarnings(“unchecked”) List batch = (List) msg.obj; //noinspection ForLoopReplaceableByForEach //依次进行分发 for (int i = 0, n = batch.size(); i &lt; n; i++) { BitmapHunter hunter = batch.get(i); hunter.picasso.complete(hunter); } break; 其实就是依次调用了Picasso.complete(BitmapHunter)方法，继续查看，则是调用了Action的 void complete(Bitmap result, Picasso.LoadedFrom from); 好了，到现在位置，Dispatcher我们也学习完毕了，下一篇文章中，会对Picasso的整体框架做一个梳理。 Tips： Volley的访问如果不成功的话，是有惩罚系数的，但Picasso默认现在看可能只是设置了RETRY_DELAY=500;BATCH_DELAY=200;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Picasso","slug":"Android/Picasso","permalink":"http://yoursite.com/categories/Android/Picasso/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Picasso","slug":"Picasso","permalink":"http://yoursite.com/tags/Picasso/"},{"name":"Dispatcher","slug":"Dispatcher","permalink":"http://yoursite.com/tags/Dispatcher/"}]},{"title":"Picasso源代码分析：3、BitmapHunter","slug":"picasso-source-code-2-bitmap-hunter","date":"2014-11-25T11:19:47.000Z","updated":"2018-10-03T14:50:47.518Z","comments":true,"path":"2014/11/25/picasso-source-code-2-bitmap-hunter/","link":"","permalink":"http://yoursite.com/2014/11/25/picasso-source-code-2-bitmap-hunter/","excerpt":"","text":"前两篇文章当中，我们依次分析了根据数据的流程，即我们调用的代码 Picasso.with(Context).load(imageUrl).into(ImageView) 依次分析了Picasso.java和ReqeustCreator.java的源代码，其中对Reqeust，Action，Target等等也有了一定的了解，接下来干嘛呢？ 其实到现在为止，我们分析的，都是任务的创建和提交，提交到队列之后干嘛呢？在ReqeustCreator当中有一个同步的请求方法Bitmap get()方法，在该方法中，最后的代码依次是创建了一个BitmapHunter，然后调用了其中的hunt()方法，因此我们可以大体猜出，该类应该是负责执行具体的请求的类。我们先不去管具体的任务是怎么样调度的，先来分析一下这个类。BitmapHunter.java BitmapHunter首先看到，该类实现了Runnable接口，也就是说，在正常的情况下，其中的run()方法应该是程序的主要入口，Executor或者Thread调用该线程，并执行其中的run方法。我们依次来分析。 静态变量： //一个全局锁，用来保证在同一个时刻只有一张图片在解码。为了减少内存消耗，哈哈，原来这个地方是直接从Volley那里学来的，我说怎么一个样子。 private static final Object DECODE_LOCK = new Object(); private static final ThreadLocal NAME_BUILDER = new ThreadLocal() { @Override protected StringBuilder initialValue() { return new StringBuilder(Utils.THREAD_PREFIX); } }; private static final AtomicInteger SEQUENCE_GENERATOR = new AtomicInteger(); private static final RequestHandler ERRORING_HANDLER = new RequestHandler() { @Override public boolean canHandleRequest(Request data) { return true; } @Override public Result load(Request data) throws IOException { throw new IllegalStateException(&quot;Unrecognized type of request: &quot; + data); } }; 在BitmapHunter当中也有一个全局锁，DECODE_LOCK，用来保证任何时刻最多只有一个图片正在解码，作者说这是从Volley中学来的。 NAME_BUILDER，是一个ThreadLocal，ThreadLocal大约是Thread Local Variable的意思，也就是说，在每个线程中，都有唯一的一个NAME_BUILDER的副本，等以后用的时候再去分析。 SEQUENCE_GENERATOR：序列号生成器，原子变量，确保多线程中能够正确的生成需要的序列号。 ERRORING_HANDLER：一个默认的用来处理错误的HANDLER，默认的实现办法是抛出异常。 成员变量： 类中的成员变量我们先不看，等用的时候再哎看看是怎么定以的就可以。 run方法： @Override public void run() { try { //更新线程名称 updateThreadName(data); if (picasso.loggingEnabled) { log(OWNER\\_HUNTER, VERB\\_EXECUTING, getLogIdsForHunter(this)); } result = hunt(); if (result == null) { //如果没有获取到结果，那么就分发失败消息 dispatcher.dispatchFailed(this); } else { //派发成功消息 dispatcher.dispatchComplete(this); } } catch (Downloader.ResponseException e) { exception = e; dispatcher.dispatchFailed(this); } catch (IOException e) { exception = e; dispatcher.dispatchRetry(this); } catch (OutOfMemoryError e) { StringWriter writer = new StringWriter(); stats.createSnapshot().dump(new PrintWriter(writer)); exception = new RuntimeException(writer.toString(), e); dispatcher.dispatchFailed(this); } catch (Exception e) { exception = e; dispatcher.dispatchFailed(this); } finally { Thread.currentThread().setName(Utils.THREAD_IDLE_NAME); }} 也比较简单明了，就不画原理图了，看看run()方法中都做了什么事情？ 更新线程名称 调用hunt()方法获取请求结果。 根据结果result派发dispatcher.dispatchFailed(this);或者dispatcher.dispatchComplete(this); 所以重点还是在Bitmap hunt()方法当中 Bitmap hunt() throws IOException { Bitmap bitmap = null; //如果不跳过MemoryCache，那么则尝试从MemoryCache获取 if (!skipMemoryCache) { bitmap = cache.get(key); if (bitmap != null) { stats.dispatchCacheHit(); loadedFrom = MEMORY; if (picasso.loggingEnabled) { log(OWNER_HUNTER, VERB_DECODED, data.logId(), “from cache”); } return bitmap; } } data.loadFromLocalCacheOnly = (retryCount == 0); RequestHandler.Result result = requestHandler.load(data); if (result != null) { bitmap = result.getBitmap(); //从枚举类获取信息，是从Network，Disk，还是Memory中获取到的数据 loadedFrom = result.getLoadedFrom(); //是否需要旋转 exifRotation = result.getExifOrientation(); } if (bitmap != null) { if (picasso.loggingEnabled) { log(OWNER_HUNTER, VERB_DECODED, data.logId()); } //(错误理解！)派发数据—-&gt;奇怪，是什么先派发Decoded完成，再派发Transformed，如果需要Transformed，那么Decoded是否是重复工作了呢？ //实际上，并不是派发数据，而是通知统计线程，完成该图片的下载和解码。 stats.dispatchBitmapDecoded(bitmap); //此处则是需要旋转图片，或者是其他的自定义的图片滤镜 if (data.needsTransformation() || exifRotation != 0) { synchronized (DECODE_LOCK) { if (data.needsMatrixTransform() || exifRotation != 0) { bitmap = transformResult(data, bitmap, exifRotation); if (picasso.loggingEnabled) { log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId()); } } if (data.hasCustomTransformations()) { bitmap = applyCustomTransformations(data.transformations, bitmap); if (picasso.loggingEnabled) { log(OWNER_HUNTER, VERB_TRANSFORMED, data.logId(), “from custom transformations”); } } } if (bitmap != null) { stats.dispatchBitmapTransformed(bitmap); } } } return bitmap;} 可以看出，其实hunt()方法主要进行了以下的工作： 判断是否跳过MemoryCache，如果不跳过，那么就尝试从MemoryCache中获取数据。 然后调用Reqeust对应的ReqeustHandler去下载数据并解码为Bitmap 通知统计线程更新统计信息 如果需要Transformation或者旋转，那么则依次调用Transformation还有旋转 需要注意的是，此处同样是对Bitmap进行操作，因此也会消耗大量的内存空间，所以Picasso也是使用了同样一个锁DECODE_LOCK来保证同一个时刻仅仅有一个图片正在处理。 之前文章《Picasso的使用：使用Transformation，下载后预处理图片并显示》中，我们在ReqeustCreator中添加了一个自定义的Transformation，就在这个阶段会被调用。 void attach(Action action) 将action合并到当前实例当中，实际上我理解的就是Volley的ImageLoader里面的BatchedImageReqeust一样，将多个同样地址的请求打包在一起进行处理。其代码如下： void attach(Action action) { boolean loggingEnabled = picasso.loggingEnabled; Request request = action.request; if (this.action == null) { this.action = action; if (loggingEnabled) { if (actions == null || actions.isEmpty()) { log(OWNER_HUNTER, VERB_JOINED, request.logId(), “to empty hunter”); } else { log(OWNER_HUNTER, VERB_JOINED, request.logId(), getLogIdsForHunter(this, “to “)); } } return; } if (actions == null) { actions = new ArrayList(3); } actions.add(action); if (loggingEnabled) { log(OWNER_HUNTER, VERB_JOINED, request.logId(), getLogIdsForHunter(this, “to “)); } //更新优先级 Priority actionPriority = action.getPriority(); if (actionPriority.ordinal() &gt; priority.ordinal()) { priority = actionPriority; }} 其代码比较简单，主要包括两部分的功能： 将action添加到成员变量actions当中 修正优先级。以actions当中优先级最高的作为整个BitmapHunter的优先级。 BitmapHunter大体的思路就是这样，下面会继续分析ReqeustHandler以及Delivery的相关代码。","categories":[{"name":"Picasso","slug":"Picasso","permalink":"http://yoursite.com/categories/Picasso/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Picasso","slug":"Picasso","permalink":"http://yoursite.com/tags/Picasso/"},{"name":"BitmapHunter","slug":"BitmapHunter","permalink":"http://yoursite.com/tags/BitmapHunter/"}]},{"title":"Picasso源代码分析：2、ReqeustCreator","slug":"picasso-source-code-2-requestcreator","date":"2014-11-25T08:10:25.000Z","updated":"2018-10-03T14:50:34.108Z","comments":true,"path":"2014/11/25/picasso-source-code-2-requestcreator/","link":"","permalink":"http://yoursite.com/2014/11/25/picasso-source-code-2-requestcreator/","excerpt":"","text":"在Volley当中，我们很清晰的能够看到，建立请求，都会放在Reqeust当中，当结果的反馈是通过ResponseDelivery调用对应的Response反馈。Picasso和Volley相比，更加专注在图形，但应该也是遵循类似的逻辑。那我们今天就来分析一下，在不同的执行阶段，一个请求封装成的RequestCreator、Request、Target、Action。 RequestCreatorRequestCreator用来做什么？用来构建一个图片下载的Request，那它是如何组织的呢？ 静态变量 private static int nextId = 0; 有一个静态的用来获取ReqeustId()的方法，代码如下： private static int getRequestId() { if (isMain()) { return nextId++; } final CountDownLatch latch = new CountDownLatch(1); final AtomicInteger id = new AtomicInteger(); Picasso.HANDLER.post(new Runnable() { @Override public void run() { id.set(getRequestId()); latch.countDown(); } }); try { latch.await(); } catch (InterruptedException e) { sneakyRethrow(e); } return id.get(); } 此处是设置该Reqeust的Id，有两种情况： 如果是在主线程上调用：则直接将返回nextId，并自增–&gt;貌似不是线程安全的 如果是在其他的线程上调用，那么通过handler发送给主线程，在主线程中同样从这里取一个nextId,然后自增，然后再设置给AtomicInteger。使用了CountDownLatch来在其他线程中等待主线程设置Id。 有个问题：这个线程是不是线程安全的？ 我认为这个方法并不是线程安全的，其所做的工作只是保证所有的nextId的分配都在主线程上进行，但并没有保证不会同时有两个线程去请求获取ReqeustId()。 不对，这个应该是线程安全的，因为这个方法在返回nextId之前，保证调用是来自主线程。换句话说，只有在主线程调用getRequestId()的时候，才会去生成并返回reqeustId，既然都在一个线程上进行的，那肯定是线程安全的。 类成员变量： private final Picasso picasso; //注意，其实在Reqeust.Builder是保存了所有的与图片显示相关的信息，包括图片的URL或者ResourceId，宽度，长度，是否旋转裁剪等等。 private final Request.Builder data; private boolean skipMemoryCache; private boolean noFade; private boolean deferred; private boolean setPlaceholder = true; private int placeholderResId; private int errorResId; private Drawable placeholderDrawable; private Drawable errorDrawable; private Object tag; 成员变量中，则是保存了一Picasso对象的引用，还有一个Reqeust.Builder来保存图片的相关的信息等等，具体用的时候就会明白。 构造函数： RequestCreator(Picasso picasso, Uri uri, int resourceId) { if (picasso.shutdown) { throw new IllegalStateException( “Picasso instance already shut down. Cannot submit new requests.”); } this.picasso = picasso; this.data = new Request.Builder(uri, resourceId); } 注意，构造函数的访问限定符是package。 在ReqeustCreator当中有大量的getter\\setter函数，我们这里先不去分析，分析几个关键的点： public Bitmap get() throws IOException; /** * Synchronously fulfill this request. Must not be called from the main thread. * 同步填充request，必须从主线程以外的线程上调用。 * * Note: The result of this operation is not cached in memory because the underlying * {@link Cache} implementation is not guaranteed to be thread-safe. * 该操作的结果并不会在内存中cache，因为底层的{@link Cache}实现并不保证是线程安全的。 */public Bitmap get() throws IOException { long started = System.nanoTime(); checkNotMain(); if (deferred) { throw new IllegalStateException(“Fit cannot be used with get.”); } if (!data.hasImage()) { return null; } //创建Request Request finalData = createRequest(started); //根据Reqeust，创建CacheKey String key = createKey(finalData, new StringBuilder()); //获取对应的Action Action action = new GetAction(picasso, finalData, skipMemoryCache, key, tag); //首先创建一个BitmapHunter，并调用其中的hunt()方法。 return forRequest(picasso, picasso.dispatcher, picasso.cache, picasso.stats, action).hunt();} 该方法的作用：同步填充一个请求，必须在主线程上调用，且不会写入Cache。其具体的方法是： 首先检查是否工作在主线程，然后检查是否已经设置请求的地址Uri或者Resource Id 然后创建一个Reqeust 根据创建的Reqeust创建CacheKy 再创建一个具体的Action 调用forReqeust()方法构造一个BitmapHunter，并调用其中的hunt()方法。 整体上理解起来很简单，创建Request，创建具体的Action，然后生成BitmapHunter，然后调用BitmapHunter.hunt()方法。但我们这个时候还没有看到具体都做了哪些工作，继续去看看forRequest都做了哪些事情。 static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats, Action action) { Request request = action.getRequest(); List requestHandlers = picasso.getRequestHandlers(); // Index-based loop to avoid allocating an iterator. //noinspection ForLoopReplaceableByForEach for (int i = 0, count = requestHandlers.size(); i &lt; count; i++) { RequestHandler requestHandler = requestHandlers.get(i); if (requestHandler.canHandleRequest(request)) { return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler); } } //此处是没有找到可以处理该请求的reqeustHandler return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);} 其实，forReqeust就做了一件事情，就是根据Request的类型，找到一个能处理这个Reqeust请求的BitmapHunter，然后生成BitmapHunter并返回。 BitmapHunter.hunt()方法，顾名思义了，这个方法就是用来执行具体的数据请求，并解码图片，然后返回的操作。这个我们先比较一下，BtimapHunter后面回过来继续分析。 还需要注意的是：正如注释当中所描述的，该方法是一个同步的填充请求的方法，而且工作在主线程上，稍不注意就会造成系统卡顿和ANR，所以我们应该尽量避免使用，而且在整个Picasso当中，我们也可以看到，Picasso保留了该接口，但并没有真正的使用它。 看完了上面同步的填充请求的方法，当然有对应的异步方法： public void fetch() /** * Asynchronously fulfills the request without a {@link ImageView} or {@link Target}. This is * useful when you want to warm up the cache with an image. * 跟上面的get()方法相对应的，这是一个异步的处理方法的请求。该方法是线程安全的，可以从任何方法进行调用。 * * Note: It is safe to invoke this method from any thread. */public void fetch() { long started = System.nanoTime(); if (deferred) { throw new IllegalStateException(“Fit cannot be used with fetch.”); } if (data.hasImage()) { // Fetch requests have lower priority by default. if (!data.hasPriority()) { data.priority(Priority.LOW); } Request request = createRequest(started); String key = createKey(request, new StringBuilder()); Action action = new FetchAction(picasso, request, skipMemoryCache, key, tag); picasso.submit(action); }} 异步的方法与同步的方法接近，都需要创建对应的Reqeust，cacheKey，Action，但异步方法和同步方法的区别在于： 两者的Action不同，同步方法直接创建了一个GetAction，而异步的方法fetch()则是创建了一个FetchAction，这两个Action有什么区别？其实两者都是简单的继承了Action父类，但不同的在于，FetchAction中添加了一个变量target，该变量在此处的实际值是ReqeustCreator的tag变量。 同步方法get()会直接访问请求，而异步方法则将action提交到picasso就结束了，我们之前有看过picasso.submit(Action action)函数，忘了？没事，再来看一下。 void submit(Action action) { dispatcher.dispatchSubmit(action);} 到这里就明白了，原来异步方法创建了对应的action之后，就直接提交给Dispatcher了。 但这依然不是我们常用的方法，接下来我们继续来看看ReqeustCreator中的into()方法，根据我们的经验，这个应该是常用的了吧。 into()总共有5个方法签名，分别是： into(Target target) into(RemoteViews remoteViews, int viewId, int notificationId,Notification notification) into(RemoteViews remoteViews, int viewId, int[] appWidgetIds) into(ImageView target) into(ImageView target, Callback callback) 其中我们最常用的是into(Target target)和into(ImageView target)。我们首先来看看这两个方法： into(Target target)源代码： public void into(Target target) { long started = System.nanoTime(); checkMain(); if (target == null) { throw new IllegalArgumentException(“Target must not be null.”); } if (deferred) { throw new IllegalStateException(“Fit cannot be used with a Target.”); } //如果请求没有设置图片属性，即既没有设置uri，也没有设置resourceId的时候，会取消该request if (!data.hasImage()) { picasso.cancelRequest(target); target.onPrepareLoad(setPlaceholder ? getPlaceholderDrawable() : null); return; } //创建一个请求 Request request = createRequest(started); String requestKey = createKey(request); //如果设置不要跳过MemoryCache，那么就从MemoryCache中取回数据 if (!skipMemoryCache) { //尝试从cache中获取图片 Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey); //如果cache hit，那么则取消相应的请求，并从Memory返回图片 if (bitmap != null) { picasso.cancelRequest(target); target.onBitmapLoaded(bitmap, MEMORY); return; } } //到此，图片没有cache hit，需要访问网络获取图片。 //设置默认显示的图片 target.onPrepareLoad(setPlaceholder ? getPlaceholderDrawable() : null); //根据需要获取的图片的相关信息，创建一个Action Action action = new TargetAction(picasso, target, request, skipMemoryCache, errorResId, errorDrawable, requestKey, tag); //将action添加到队列并提交。 picasso.enqueueAndSubmit(action);} 一看，是不是很熟悉，和刚刚的那个异步执行Reqeust的方法fetch()的思路基本上是一样的嘛： 首先判断是否工作在主线程上 (这一点和fetch()方法不同，fetch()方法不限制必须要在主线程上执行) 检查输入的合法性：包括target、deferred、data.hashImage()即是否Uri或者resourceId已经设置 创建Request、CacheKey 尝试从Cache中获取图片，如果Cache Hit，那么立刻返回结果。 如果Cache失败或者不需要Cache，则显示默认图片，然后创建Action 提交Action到dispatcher，同时将action放进Picasso中的targetToAction的Map中(需要注意，targetToAction是一个WeakReference，如果外部没有代码保持引用的话就会被GC回收掉)。 这样看来，也没有什么难题，等等，Target到底是什么呢？我们知道这个应该和我们要设定的控件有关系，但到底是做什么的呢？我们还没有看明白。 Target接口： public interface Target { void onBitmapLoaded(Bitmap bitmap, LoadedFrom from); void onBitmapFailed(Drawable errorDrawable); void onPrepareLoad(Drawable placeHolderDrawable);} 该接口是Picasso为了实现对于任意的图形控制接口都能实现加载，而设计的一个接口，为什么这么说？我们界面中需要设置一张图片，系统只为设置图片保留了接口，但无法直接访问对应的ImageView控件，或者对应的根本就不是ImageView控件，那我们怎么办？难道就没有办法去设置图片了吗？当然不是，因为系统保留的接口，所以我们只需要重新写一个类包含该控件，并实现Target接口，在onBitmapLoaded方法中实现设置图片的逻辑即可。 此外，作者的注释还提到， Objects implementing this class must have a working implementation of {@link Object#equals(Object)} and {@link Object#hashCode()} for proper storage internally. Instances of this interface will also be compared to determine if view recycling is occurring. It is recommended that you add this interface directly on to a custom view type when using in an adapter to ensure correct recycling behavior. 个人的理解是，首先，如果需要使用Target，那么我们一定要实现hashCode()和equals()方法。因为该接口也会用来判断该View是否正在被垃圾回收。在我们使用自定义View的时候，比如Adapter中使用的时候，最好封装一个Target对象，以获得更好的垃圾回收效果。 在ReqeustCreator类中的into(Target target)方法中，作者也在注释当中为我们列举了两个使用的范例： //实现一个View:public class ProfileView extends FrameLayout implements Target { @Override public void onBitmapLoaded(Bitmap bitmap, LoadedFrom from) { setBackgroundDrawable(new BitmapDrawable(bitmap)); } @Override public void onBitmapFailed() { setBackgroundResource(R.drawable.profile_error); } @Override public void onPrepareLoad(Drawable placeHolderDrawable) { frame.setBackgroundDrawable(placeHolderDrawable); }} //在一个adapter当中实现一个holderpublic class ViewHolder implements Target { public FrameLayout frame; public TextView name; @Override public void onBitmapLoaded(Bitmap bitmap, LoadedFrom from) { frame.setBackgroundDrawable(new BitmapDrawable(bitmap)); } @Override public void onBitmapFailed() { frame.setBackgroundResource(R.drawable.profile_error); } @Override public void onPrepareLoad(Drawable placeHolderDrawable) { frame.setBackgroundDrawable(placeHolderDrawable); }} 所以，我们可以记住一条了，在Adapter中使用Picasso的时候，最好将我们的ViewHolder实现Target，不过此外还要记住，作者也特别建议我们在实现Target的时候，覆写equals()和hashCode()方法。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Picasso","slug":"Android/Picasso","permalink":"http://yoursite.com/categories/Android/Picasso/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Picasso","slug":"Picasso","permalink":"http://yoursite.com/tags/Picasso/"},{"name":"RequestCreator","slug":"RequestCreator","permalink":"http://yoursite.com/tags/RequestCreator/"}]},{"title":"Picasso源代码分析：2、Picasso.java","slug":"picasso-source-code-2-picasso-entrance","date":"2014-11-25T02:09:46.000Z","updated":"2018-10-03T14:50:14.685Z","comments":true,"path":"2014/11/25/picasso-source-code-2-picasso-entrance/","link":"","permalink":"http://yoursite.com/2014/11/25/picasso-source-code-2-picasso-entrance/","excerpt":"","text":"在之前的文章《Picasso源代码分析：1、跟随代码的角度，当我们添加了一个任务，到底发生了什么？》中，我们通过我们最常使用的代码 Picasso.with(Context).load(“http://www.baidu.com/img/bdlogo.png&quot;).into(imageview); 分析了这段代码是如何工作的。我们通过分析发现，该段代码依次创建了一个Picasso对象，一个ReqeustCreator对象，一个Request对象和一个ImageViewAction对象。要继续深入的理解Picasso的工作原理，我们需要首先来分析这些类到底是做什么实用的？ PicassoPicasso是整个Picasso的入口，作者添加了如下的注释： /** * Image downloading, transformation, and caching manager. * * Use {@link #with(android.content.Context)} for the global singleton instance or construct your * own instance with {@link Builder}. */ 简单的说，Picasso是一个图像(Image)的下载，处理和缓存的管理器。对比我们之前学习的Volley，在Volley中也有一个Volley.java的工具类，该类的代码位于com.android.volley.toolbox当中，而非com.android.volley，也就是说，在Volley当中，Volley类并不是其核心类，其维护所有队列以及线程的类是ReqeustQueue，Volley类是一个方便大家使用的对Volley的代码的封装而已。那么我们这时候要思考了，Picasso类对于Picasso而言，是核心的用于维护所有的队列即调度线程的类？还是同Volley.java一样，只是为了方便使用，对其代码的一个封装？ 依次来分析Picasso的结构： 首先，Picasso定义了两个接口 Listener /** Callbacks for Picasso events. /public interface Listener { /\\* * Invoked when an image has failed to load. This is useful for reporting image failures to a * remote analytics service, for example. */ void onImageLoadFailed(Picasso picasso, Uri uri, Exception exception);} 该接口的用途是在图片加载失败的时候调用，注释上说，该接口会在分析失败原因的时候比较有用。 ReqeustTransformer /** * A transformer that is called immediately before every request is submitted. This can be used to * modify any information about a request. * * For example, if you use a CDN you can change the hostname for the image based on the current * location of the user in order to get faster download speeds. * * NOTE: This is a beta feature. The API is subject to change in a backwards incompatible * way at any time. /public interface RequestTransformer { /\\* * Transform a request before it is submitted to be processed. * * @return The original request or a new request to replace it. Must not be null. */ Request transformRequest(Request request); /** A {@link RequestTransformer} which returns the original request. */ RequestTransformer IDENTITY = new RequestTransformer() { @Override public Request transformRequest(Request request) { return request; } };} 这个接口RequestTransformer这个接口我们比较熟悉一些了，该接口是用来做一些请求的预处理，比如，有两台图片服务器，a.happyhls.me/b.happyhls.me，本来所有的访问地址都是a.happyhls.me的，但是要在切换到b.happyhls.me，那么我们就可以直接通过该接口进行处理。当然Reqeust还包含了很多其他的信息，我们后面会慢慢看到。只要是Request的相关信息，我们都可以通过这个接口进行修改。 在ReqeustTransformer当中，还定义了一个默认的实现，INDETITY，该接口实际上是直接返回未修改的Reqeust。 Priority public enum Priority { LOW, NORMAL, HIGH} Picasso中一个定了3中优先级：LOW、NORMAL、HIGH HANDLER 还定义了一个静态变量HANDLER，其定义如下： static final Handler HANDLER = new Handler(Looper.getMainLooper()) { @Override public void handleMessage(Message msg) { switch (msg.what) { case HUNTER_BATCH_COMPLETE: { //此处应该是和Volley一样，打包处理的图形库，因为这些图片可能地址以及大小都是一样的所有打包在一起进行处理。 @SuppressWarnings(“unchecked”) List batch = (List) msg.obj; //noinspection ForLoopReplaceableByForEach //依次进行分发 for (int i = 0, n = batch.size(); i &lt; n; i++) { BitmapHunter hunter = batch.get(i); hunter.picasso.complete(hunter); } break; } case REQUEST_GCED: { //此处根据意思应该是请求被GC掉了 Action action = (Action) msg.obj; if (action.getPicasso().loggingEnabled) { log(OWNER_MAIN, VERB_CANCELED, action.request.logId(), “target got garbage collected”); } //那么就取消相应的处理已经被GC对应的请求 action.picasso.cancelExistingRequest(action.getTarget()); break; } case REQUEST_BATCH_RESUME: //请求被恢复了，还不太懂其业务逻辑。 @SuppressWarnings(“unchecked”) List batch = (List) msg.obj; for (int i = 0, n = batch.size(); i &lt; n; i++) { Action action = batch.get(i); action.picasso.resumeAction(action); } break; default: throw new AssertionError(“Unknown handler message received: “ + msg.what); } }}; 我们需要明确以下几点： 该handler即HANDLER是工作在主线程(Looper,getMainLooper())之上的。换句说，其中所有的Message的处理过程都是在主线程上，因此我们不能在其中执行消耗时间过长的任务。 其中更定义了3个消息，还不清楚该HANDLER是谁在给他发送消息，但根据字面上的意思，我们可以如下理解： HUNTER_BATCH_COMPLETE： BATCH是打包的意思，按照字面的理解是，当前打包的任务已经完成了，所以在主线程上依次分发结果。我们看到，在代码中，首先获取了List batch，然后依次对batch中每一个BitmapHunter调用hunter.picasso.complete(hunter)方法。 void complete(BitmapHunter hunter) { Action single = hunter.getAction(); List joined = hunter.getActions(); boolean hasMultiple = joined != null &amp;&amp; !joined.isEmpty(); boolean shouldDeliver = single != null || hasMultiple; if (!shouldDeliver) { return; } Uri uri = hunter.getData().uri; Exception exception = hunter.getException(); Bitmap result = hunter.getResult(); LoadedFrom from = hunter.getLoadedFrom(); if (single != null) { deliverAction(result, from, single); } if (hasMultiple) { //noinspection ForLoopReplaceableByForEach for (int i = 0, n = joined.size(); i &lt; n; i++) { Action join = joined.get(i); deliverAction(result, from, join); } } if (listener != null &amp;&amp; exception != null) { listener.onImageLoadFailed(this, uri, exception); }} complete(BitmapHunter hunter)方法主要做了以下的事情： 获取通过getAction()和getActions()获取对应的action，当前还不清楚这分别代表着什么 然后判断是否需要分发结果(shouldDeliver)，是否有多个结果等待分发 获取result并通过deliverAction(result, from, single);分发结果 如果有多个结果需要分发，则实例获取对应的Action，并通过deliverAction(result, from, single);进行结果分发 如果出错，则回调出错的类的对应方法listener.onImageLoadFailed(this, uri, exception);。 继续跟着代码往下分析，代码是调用的deliverAction(Bitmap result, LoadedFrom from, Action action)方法进行结果分发，那这个方法到底有做了什么工作呢？ private void deliverAction(Bitmap result, LoadedFrom from, Action action) { if (action.isCancelled()) { return; } if (!action.willReplay()) { targetToAction.remove(action.getTarget()); } if (result != null) { if (from == null) { throw new AssertionError(&quot;LoadedFrom cannot be null.&quot;); } action.complete(result, from); if (loggingEnabled) { log(OWNER\\_MAIN, VERB\\_COMPLETED, action.request.logId(), &quot;from &quot; + from); } } else { action.error(); if (loggingEnabled) { log(OWNER\\_MAIN, VERB\\_ERRORED, action.request.logId()); } }} 可以发现，这里面和Volley也有一些相同的地方：首先都会判断对应的Action(Volley是对应的Request)是否已经取消，然后再判断结果是否正确，最后调用action对应的complete()方法，我们先分析Picasso，后面再去具体看看Action.complete()方法做了哪些工作。 REQUEST_GCED 请求被GC掉了，但不清楚两个问题： 为什么被GC掉了？难道请求不应该是强引用吗？ 如何判断被GC掉，并且给主线程发送消息呢？ -&gt; 此处可参考CleanupThread 当接收到该类型的Message的时候，处理的方法比较简单，就是获取对应的Action，然后如果取消该Action对应的请求即可。 private void cancelExistingRequest(Object target) { //检查是否工作在主线程 checkMain(); //获取target对应的Action，并从列表中删除 Action action = targetToAction.remove(target); //如果action存在，那么就执行取消操作，并调用dispatcher取消对应的action if (action != null) { //调用action的cancel函数，实际上是设置cancel标志 action.cancel(); //实际上是通过dispatcher绑定的handler发送到相应的线程上去处理。 dispatcher.dispatchCancel(action); } //如果target是一个ImageView的话，取消那些之前添加的，需要延时处理的请求。 if (target instanceof ImageView) { ImageView targetImageView = (ImageView) target; DeferredRequestCreator deferredRequestCreator = targetToDeferredRequestCreator.remove(targetImageView); if (deferredRequestCreator != null) { deferredRequestCreator.cancel(); } }} 代码以上，主要做了以下的工作：检查是否工作在主线程上，然后从toDo队列当中对应对应的action，再然后通过调用dispatcher.dispatcherCancel(action)来取消对应的任务。 REQUEST_BATCH_RESUME 此处应该是打包的请求重新恢复执行，所以要求在主线程上依次恢复其对应的Action。代码如下： void resumeAction(Action action) { Bitmap bitmap = null; if (!action.skipCache) { bitmap = quickMemoryCacheCheck(action.getKey()); } if (bitmap != null) { // Resumed action is cached, complete immediately. deliverAction(bitmap, MEMORY, action); if (loggingEnabled) { log(OWNER\\_MAIN, VERB\\_COMPLETED, action.request.logId(), &quot;from &quot; + MEMORY); } } else { // Re-submit the action to the executor. enqueueAndSubmit(action); if (loggingEnabled) { log(OWNER\\_MAIN, VERB\\_RESUMED, action.request.logId()); } }} 其中的工作依次是： 检查是否可以从Memory Cache中获取数据，如果可以则尝试读取 如果成功，则调用deliverAction(bitmap, MEMORY, action)分发结果。 如果不成功，则将action加入队列并提交。 到这里，我们就大体明白了工作在主线程上的HANDLER到底要做哪些事情？主要就是，处理HUNTER_BATCH_COMPLETE操作完成；处理REQUEST_GCED事件；处理REQUEST_BATCH_RESUME事件。发现了没有？HANDLER应该是主要处理那些BATCH的请求，也就是可以合并在一起进行处理的请求；那这样看来，如果Action是独立的，应该不从这里进行结果分发的，是不是呢？后面慢慢分析。 类成员变量： 依次来看看Picasso都定义了哪些类成员变量： static Picasso singleton = null; private final Listener listener; //前面提到过，Listener是出错的时候的问题回调，其中有onImageLoadFailed()方法。 private final RequestTransformer requestTransformer; //这个则是前面定义的，用来预先处理请求使用。 private final CleanupThread cleanupThread; //这个是一个清理线程，具体做的工作后面慢慢分析。 private final List requestHandlers; //请求处理的ReqeustHandler集合，由于Picasso可以处理各种各样的请求，比如Uri，File，resourceId等等，因此各自需要不同的Handler去处理。 final Context context; final Dispatcher dispatcher; //任务分发的上下文，前面的文章有提到过，后面慢慢分析。 final Cache cache; //Cache final Stats stats; //Stats final Map&lt;Object, Action&gt; targetToAction; //这里保存的是Target对应的Action，Picasso中既可以处理ImageView，也可以根据我们的需要包装成Target，当结果返回时，调用Target对应的方法即可。 final Map&lt;ImageView, DeferredRequestCreator&gt; targetToDeferredRequestCreator; //给定的ImageView对应的延时执行的请求 DeferredRequestCreator。 final ReferenceQueue referenceQueue; //ReferenceQueue，这个还不清楚是做什么的。 boolean indicatorsEnabled; //还不清楚做什么的。 volatile boolean loggingEnabled; //是否允许Log boolean shutdown; //停止Picasso服务标志。 构造函数： Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener, RequestTransformer requestTransformer, List extraRequestHandlers, Stats stats, boolean indicatorsEnabled, boolean loggingEnabled) { this.context = context; this.dispatcher = dispatcher; this.cache = cache; this.listener = listener; this.requestTransformer = requestTransformer; //Picasso内置了总共7种处理器 int builtInHandlers = 7; // Adjust this as internal handlers are added or removed. int extraCount = (extraRequestHandlers != null ? extraRequestHandlers.size() : 0); List&lt;RequestHandler&gt; allRequestHandlers = new ArrayList&lt;RequestHandler&gt;(builtInHandlers + extraCount); // ResourceRequestHandler needs to be the first in the list to avoid // forcing other RequestHandlers to perform null checks on request.uri // to cover the (request.resourceId != 0) case. // ResourceRequestHandler必须放于队列的队首，以避免其他的ReqeustHandler会检查reqeust.uri是否为null来覆盖掉reqeust.resourceId!=0 allRequestHandlers.add(new ResourceRequestHandler(context)); if (extraRequestHandlers != null) { allRequestHandlers.addAll(extraRequestHandlers); } allRequestHandlers.add(new ContactsPhotoRequestHandler(context)); allRequestHandlers.add(new MediaStoreRequestHandler(context)); allRequestHandlers.add(new ContentStreamRequestHandler(context)); allRequestHandlers.add(new AssetRequestHandler(context)); allRequestHandlers.add(new FileRequestHandler(context)); allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats)); //将所有的handler变为unmodifiedaleList requestHandlers = Collections.unmodifiableList(allRequestHandlers); this.stats = stats; //此处用了WeakHashMap来保存，避免OOM this.targetToAction = new WeakHashMap&lt;Object, Action&gt;(); //此处用了WeakHashMap来保存，避免OOM this.targetToDeferredRequestCreator = new WeakHashMap&lt;ImageView, DeferredRequestCreator&gt;(); this.indicatorsEnabled = indicatorsEnabled; this.loggingEnabled = loggingEnabled; this.referenceQueue = new ReferenceQueue&lt;Object&gt;(); this.cleanupThread = new CleanupThread(referenceQueue, HANDLER); this.cleanupThread.start(); } 如上是构造函数，比较简单，主要是变量的赋值，我觉得需要注意的有以下几点： ReqeustHandler 默认添加了7个ReqeustHandler，根据名字可以基本上明白其处理的请求类型。 所有的添加完成之后，生成unmodifiableList。 两个Map，targetToAction和targetToDeferredRequestCreator： 两个Map都是WeakHashMap，WeakHashMap的特点是，当如果Map之外没有引用，而且遇到GC的时候，那么其中的元素就会被当作垃圾回收。所以我们后面要特别注意这两个map–targetToAction以及targetToDeferredRequestCreator的处理。 enqueueAndSubmit &amp;&amp; submit 任务的提交 //将action添加到队列，并提交void enqueueAndSubmit(Action action) { Object target = action.getTarget(); if (target != null &amp;&amp; targetToAction.get(target) != action) { // This will also check we are on the main thread. // 此处说明，比如同一个ImageView，已经更换了图片，所以要取消当前的请求，提交新的请求。（这在ListView中是进场的） cancelExistingRequest(target); targetToAction.put(target, action); } submit(action);} //提交actionvoid submit(Action action) { dispatcher.dispatchSubmit(action);} 此处的代码作用是：将Action添加到队列当中，并且提交到dispatcher。我们可以发现，其具体的原理是 从Action中获取Target(ImageView也是一种Target) 然后将Target放入到targetToAction当中(targetToAction是WeakHashMap) 将Action提交到dispatcher当中 CleanupThread private static class CleanupThread extends Thread { private final ReferenceQueue&lt;?&gt; referenceQueue; private final Handler handler; CleanupThread(ReferenceQueue&lt;?&gt; referenceQueue, Handler handler) { this.referenceQueue = referenceQueue; this.handler = handler; setDaemon(true); setName(THREAD_PREFIX + “refQueue”); } @Override public void run() { Process.setThreadPriority(THREAD_PRIORITY_BACKGROUND); while (true) { try { RequestWeakReference&lt;?&gt; remove = (RequestWeakReference&lt;?&gt;) referenceQueue.remove(); handler.sendMessage(handler.obtainMessage(REQUEST_GCED, remove.action)); } catch (InterruptedException e) { break; } catch (final Exception e) { handler.post(new Runnable() { @Override public void run() { throw new RuntimeException(e); } }); break; } } } void shutdown() { interrupt(); }} 这是清理线程的代码，先提出几个问题： 为什么需要这个清理线程？按照Volley的思路，不应该是在任务删除或者完成的时候清理吗？ 清理线程每次是从referenceQueue中取出一个RequestWeakReference，这是一个阻塞线程，清理线程会一直等待队列中的元素，当取到元素的时候，就将其发送给handler(从调用关系上可以看出，此HANDLER即运行在主线程上的HANDLER)进行处理，如本文前面所描述的。 所以大胆猜测，应该是在Action取消或者完成的时候，就会放入到RequestWeakReference当中，然后清理线程会在后台默默的等待，当发现有元素需要清理的时候，就会发送给主线程执行清理工作。 Picasso.Builder() 我们来看一下，我们默认调用的构造者，为我们初始化的Picasso是怎么样的？ /** Create the {@link Picasso} instance. 创建Picasso的实例 */public Picasso build() { Context context = this.context; if (downloader == null) { downloader = Utils.createDefaultDownloader(context); } if (cache == null) { cache = new LruCache(context); } if (service == null) { service = new PicassoExecutorService(); } if (transformer == null) { transformer = RequestTransformer.IDENTITY; } Stats stats = new Stats(cache); Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats); return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats, indicatorsEnabled, loggingEnabled);} 其中： downloader = Utils.createDefaultDownloader(context); 其代码如果存在suqare的OKHttp库的话，就使用OKHttp，否则则使用HttpURLConnection cache = new LruCache(context); service = new PicassoExecutorService(); transformer = RequestTransformer.IDENTITY; Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats); 在Picasso.java的最后，还有一个枚举类 LoadedFrom public enum LoadedFrom { MEMORY(Color.GREEN), DISK(Color.YELLOW), NETWORK(Color.RED); final int debugColor; private LoadedFrom(int debugColor) { this.debugColor = debugColor; }} 用来表示加载的来源，是MEMORY？还是DISK？还是NETWORK？","categories":[{"name":"Picasso","slug":"Picasso","permalink":"http://yoursite.com/categories/Picasso/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Picasso","slug":"Picasso","permalink":"http://yoursite.com/tags/Picasso/"}]},{"title":"Picasso源代码分析：1、跟随代码的角度，当我们添加了一个任务，到底发生了什么？","slug":"picasso-source-code-1-what-happened-after-a-task-submitted","date":"2014-11-25T00:11:02.000Z","updated":"2018-10-03T16:12:52.520Z","comments":true,"path":"2014/11/25/picasso-source-code-1-what-happened-after-a-task-submitted/","link":"","permalink":"http://yoursite.com/2014/11/25/picasso-source-code-1-what-happened-after-a-task-submitted/","excerpt":"","text":"Volley是一个轻量级的网络库，而Picasso是一个轻量级的图片缓存库。我们在分析代码的时候，发现Picasso的源代码远远没有Volley那么清晰，该怎么办？还是跟着代码走，看看当我们将一个任务添加到Picasso的时候，在Picasso内部，到底都做了哪些工作？ 一个典型的用法： Picasso.with(Context).load(“http://www.baidu.com/img/bdlogo.png&quot;).into(imageview); 如上，这段代码就是通过Picasso，将地址http://www.baidu.com/img/bdlogo.png的代码下载下来，然后填充到ImageView当中。那我们就依次分析这几个代码，看看具体都有哪些工作？ Picasso.with(Context): public static Picasso with(Context context) { if (singleton == null) { synchronized (Picasso.class) { if (singleton == null) { singleton = new Builder(context).build(); } } } return singleton;} 该段代码为Picasso的初始化代码，有以下特征： 一个典型的单例模式 使用的是延时初始化来保证Picasso只有在使用到的时候，才会初始化对象 使用同步代码块的办法来保证多个线程中同时请求的时候，能够保证只创建唯一的单例对象。 同步对象为类对象，保证同步范围整个JVM中。 使用构造者模式，通过Builder类构建了一个默认配置的Picasso的对象。看看默认构造都使用了什么参数： /** Create the {@link Picasso} instance. 创建Picasso的实例 */public Picasso build() { Context context = this.context; if (downloader == null) { downloader = Utils.createDefaultDownloader(context); } if (cache == null) { cache = new LruCache(context); } if (service == null) { service = new PicassoExecutorService(); } if (transformer == null) { transformer = RequestTransformer.IDENTITY; } Stats stats = new Stats(cache); Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats); return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats, indicatorsEnabled, loggingEnabled);} 默认初始化了以下的参数： Downloader DownLoader就是下载用的工具类，在Picasso当中，如果OKHttp可以使用的话，就会默认使用OKHttp，如果无法使用的话，就会使用UrlConnectionDownloader(默认使用HttpURLConnection实现)。 Cache 默认实现为LruCache，就是使用LinkedHashMap实现的一个Cache类，注意的一个地方就是，在其他的地方，我们一般默认的是限制的capacity，但是这个地方我们是限制的总共使用的内存空间。因此LruCache在实现的时候，其实简单理解就是将LinkedHashMap封装，然后基于LinkedHashMap的方法实现Cache的方法，在Cache的set()方法的时候，会不断计算当前还可以使用的空间大小，要是超出范围，则删除之前保存的数据。 ExecutorService 默认的实现为PicassoExecutorService，该类也比较简单，其实就是ThreadPoolExecutor，在其功能的基础上继续封装，在其中有一个比较细心的功能就是，Picasso通过PicassoExecutorService设置线程数量，来调整在2G/3G/4G/WiFi不同网络情况下的不同表现。 RequestTransformer ReqeustTransformer是一个接口，用来预处理Reqeust，在之前写的《Picasso的使用：使用Transformation，下载后预处理图片并显示》中写过，可以用来将请求进行预先处理，比如改个域名啥的。 Stats 主要是一些统计信息，比如cache hit/miss，总共下载的文件大小，下载过的图片数量，转换的图片数量等等。 Dispatcher Picasso当中，分发任务的线程，这是我们以后要重点研究的一个类，先标记一下，这个Dispatcher主要做了以下的事情： 启动了一个DispatcherThread线程 初始化了一个用来处理消息的DispatcherHandler，注意，根据Dispatcher中默认配置，该Handler所有数据的处理是在DispatcherThread之上。 初始化并注册了一个网络状态广播接收器。 好了，看完Picasso.with(Context)，接下来就是load方法： load(String url): Picasso.with(Context).load(“http://www.baidu.com/img/bdlogo.png&quot;).into(imageview); load(String url)其实是一个load(Uri uri)方法的一个封装，load(Uri uri)的方法原形如下： public RequestCreator load(Uri uri) { return new RequestCreator(this, uri, 0);} 很明显，到这里，我们可以这样推断，Picasso通过调用load(Uri uri)，返回了一个传入Picasso对象和要访问的网址或路径的Uri的ReqeustCreator。所以，我们首先要看看ReqeustCreator方法都做了什么工作。 RequestCreator(this, uri, 0) RequestCreator(Picasso picasso, Uri uri, int resourceId) { if (picasso.shutdown) { throw new IllegalStateException( “Picasso instance already shut down. Cannot submit new requests.”); } this.picasso = picasso; this.data = new Request.Builder(uri, resourceId);} 可以看到，该构造函数的工作过程是：首先检查picasso是否在工作，如果在工作，那么则设置启动的picasso对象，并通过建造者模式，调用Builder去构造Reqeust.Builder(注意，此时我们传入的resourceId为0，根据我们之前的理解，Uri和resourceId在一个任务中只有一个生效。)，并赋值给data变量，继续查看代码： public Builder(Uri uri) { setUri(uri);} /** Start building a request using the specified resource ID. */public Builder(int resourceId) { setResourceId(resourceId);} Builder(Uri uri, int resourceId) { this.uri = uri; this.resourceId = resourceId;} 可以发现，其构造函数仅仅是简单的根据传入的参数设置相应的变量而已，并没有其他的工作。那接下来如何呢？别着急，刚刚我们的那行代码还差最后一句into(ImageView). Picasso.with(Context).load(“http://www.baidu.com/img/bdlogo.png&quot;).into(imageview); 因此，我们接下来去探究ReqeustCreator的into(ImgeView)方法。 into(ImageView imageview)实际上调用的是into(ImageView imageview, Callback callback)方法，我们查看其源代码： /** * Asynchronously fulfills the request into the specified {@link ImageView} and invokes the * target {@link Callback} if it’s not {@code null}. * * Note: The {@link Callback} param is a strong reference and will prevent your * {@link android.app.Activity} or {@link android.app.Fragment} from being garbage collected. If * you use this method, it is strongly recommended you invoke an adjacent * {@link Picasso#cancelRequest(android.widget.ImageView)} call to prevent temporary leaking. */public void into(ImageView target, Callback callback) { long started = System.nanoTime(); checkMain(); if (target == null) { throw new IllegalArgumentException(“Target must not be null.”); } if (!data.hasImage()) { picasso.cancelRequest(target); if (setPlaceholder) { setPlaceholder(target, getPlaceholderDrawable()); } return; } if (deferred) { if (data.hasSize()) { throw new IllegalStateException(“Fit cannot be used with resize.”); } int width = target.getWidth(); int height = target.getHeight(); if (width == 0 || height == 0) { if (setPlaceholder) { setPlaceholder(target, getPlaceholderDrawable()); } picasso.defer(target, new DeferredRequestCreator(this, target, callback)); return; } data.resize(width, height); } Request request = createRequest(started); String requestKey = createKey(request); if (!skipMemoryCache) { Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey); if (bitmap != null) { picasso.cancelRequest(target); setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled); if (picasso.loggingEnabled) { log(OWNER_MAIN, VERB_COMPLETED, request.plainId(), “from “ + MEMORY); } if (callback != null) { callback.onSuccess(); } return; } } if (setPlaceholder) { setPlaceholder(target, getPlaceholderDrawable()); } Action action = new ImageViewAction(picasso, target, request, skipMemoryCache, noFade, errorResId, errorDrawable, requestKey, tag, callback); picasso.enqueueAndSubmit(action);} 发现这里面做的工作果然很多，我们画一个原理图来细细的分析。 图画的很大，这样大家看的清晰，在文字上梳理一遍，into函数到底做了什么事情？ 首先检查当前是否工作在主线程，如果不是在主线程上的话，直接抛出异常退出。为什么要在主线程上工作？我的理解是，因为在这里面我们需要设置ImageView默认显示的图片，但除了这个原因，有没有考虑说对Picasso队列线程同步的问题？现在还没有看到。 然后判断data.hasImage()，这里面这个函数命名比较迷惑人了，一开始我还以为是判断是否已经有解析好的图片，但再往下看一看源代码，原来这个代码是判断Uri和resourceId是否有设置了一个，如果没有，则说明该Reqeust没有数据源，是错误的。 如果没有Uri或者resource Id，那么则取消该请求，并设置默认的显示图片并退出。 该图片是否需要延时执行（这个属性还不太清楚在哪里配置的，不清楚是手动指定还是自动设置）。如果需要延时执行，则按照以下步骤执行。 判断是否设置过targetSize，如果已经设置过，则抛出异常退出 (不太明白为什么要检查是否已经要设置过targetSize) 然后获取target，即ImageView对应的长和宽，如果长和宽都是0，那么就设置默认的图片，并构建一个DeferredRequestCreator，放入Picasso对应的队列当中。 重新设置data即ReqeustCreator对应的targetWidth和targetHeight 创建Reqeust，生成requestKey 判断是否需要跳过MemoryCache，如果不跳过，那么就尝试获取图片，并取消对应的请求，进行回调。 如果需要设置默认的图片，则在这里进行设置 生成对应的ImageViewAction 将生成的ImageViewAction添加到队列当中。 所以into()方法实现的功能我们可以这样总结：检查配置的合法性，然后根据配置决定是放入延时队列还是立刻执行，如果立刻执行，则创建对应的请求并尝试从MemoryCache中获取，如果不成功，则生成对应的Action并提交到Picasso的队列当中。后面要做的事情，其实大体可以想到，就是Picasso的任务调度了。 好了，我们从代码 Picasso.with(Context).load(“http://www.baidu.com/img/bdlogo.png&quot;).into(imageview); 看到Picasso的工作就是这些，要明白剩下的Picasso还做了什么工作，还需要继续分析源代码。","categories":[{"name":"Picasso","slug":"Picasso","permalink":"http://yoursite.com/categories/Picasso/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Picasso","slug":"Picasso","permalink":"http://yoursite.com/tags/Picasso/"}]},{"title":"Picasso的使用：使用Transformation，下载后预处理图片并显示","slug":"picasso-advanced-process-image-with-transformation","date":"2014-11-23T15:16:14.000Z","updated":"2018-10-03T16:12:52.534Z","comments":true,"path":"2014/11/23/picasso-advanced-process-image-with-transformation/","link":"","permalink":"http://yoursite.com/2014/11/23/picasso-advanced-process-image-with-transformation/","excerpt":"","text":"在stackoverflow上闲逛的时候，发现有个哥们问了这么一个问题：Draw a line on ImageView set by Picasso 意思是他想在使用Picasso的时候，对加载的图片做一个类似的滤镜的功能，需要将图片的中间画一条横线，该怎么处理呢？ 如果熟悉Picasso的机制，当然可以很快搞定，但如果不是很熟悉呢？最好的办法当然是探索源码，从源码中分析Picasso的原理，进而看看到底是怎么样来实现这个功能。我们从以下的角度来分析： 尽可能使用Picasso线程的API，不去修改Picasso的源代码 既然是图片下载之后添加横线，那么必然对应着Picasso中图片获取完成之后，分发结果的相关代码。 我们现在还没有完全分析完Picasso的源代码，但顺着这个路子，我们依然可以发现关于结果分发的相关代码。 在我们没有特殊的需求之前，我们一般是这样简单的使用Picasso的： Picasso.with(context).load(“http://www.baidu.com/img/bdlogo.png&quot;).into(imageview); 我们依次分析 Picasso.with(context)是利用默认的构造器创建一个Picasso的对象，因此我们首先找一找Picasso的类当中，有没有相关的函数。我们来看Picasso的构造函数： Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener, RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers, Stats stats, boolean indicatorsEnabled, boolean loggingEnabled) { 从构造函数的名称，可以大体了解每一个参数是做什么使用的，这里面有一个RequestTransformer对象可能有点靠近，那我们去看看这段函数是做什么使用的。 /** * A transformer that is called immediately before every request is submitted. This can be used to * modify any information about a request. * 请求在提交之前，会立刻调用一个transformer。这个可以用来一个请求的任何信息 * * For example, if you use a CDN you can change the hostname for the image based on the current * location of the user in order to get faster download speeds. * * NOTE: This is a beta feature. The API is subject to change in a backwards incompatible * way at any time. /public interface RequestTransformer { /\\* * Transform a request before it is submitted to be processed. * * @return The original request or a new request to replace it. Must not be null. */ Request transformRequest(Request request); /** A {@link RequestTransformer} which returns the original request. / /\\* 返回原始版本的Request */ RequestTransformer IDENTITY = new RequestTransformer() { @Override public Request transformRequest(Request request) { return request; } };} 可以看出，这其实并不是对结果的一个预处理，而是对请求的预处理，也就是，如果我们有需要，那么可以在同一的在Volley中，去对输入的请求进行统一的控制，比如本来要访问的域名都是a.happyhls.me，那么我就可以通过这个都给修改为b.happyhls.me，在一个系统中可能多个版本比如v1，v2同时运行的时候，会特别有用。 既然Picasso的类中没有相关的信息，那么我们继续向下观察： Picasso.with(context).load(“http://www.baidu.com/img/bdlogo.png&quot;) 根据我们之前的学习，程序执行到这里，其实是构建了一个RequestCreator对象，因此，我们可以继续分析ReqeustCreator对象，有没有可以发现的地方。在其中我们看到 /** * Add a custom transformation to be applied to the image. * * Custom transformations will always be run after the built-in transformations. */// TODO show example of calling resize after a transform in the javadocpublic RequestCreator transform(Transformation transformation) { data.transform(transformation); return this;} 看到这里，注释很明了了，将需要设置的图片进行一次自定义的变换。作者还标记了一个//TODO，要写一个重新设置大小的例子。当然TODO嘛，肯定是没有。但既然找到地方了，那么我们就自己来写一个就可以了。观察这个方法，其实可以发现其实就是将数据在Transformation中走了一遍。 那么我们继续分析Transformation，看看其中的门道。 package com.squareup.picasso; import android.graphics.Bitmap; /** Image transformation. /public interface Transformation { /\\* * Transform the source bitmap into a new bitmap. If you create a new bitmap instance, you must * call {@link android.graphics.Bitmap#recycle()} on {@code source}. You may return the original * if no transformation is required. */ Bitmap transform(Bitmap source); /** * Returns a unique key for the transformation, used for caching purposes. If the transformation * has parameters (e.g. size, scale factor, etc) then these should be part of the key. */ String key();} 好了，这里是Transformation接口的全部代码，可以看到，Bitmap transform(Bitmap source)就是我们需要处理的地方，通过实现这个方法，可以将已经解码的图片source，根据自己的需要进行处理，并返回一个新的图片。需要注意的，处理完成，在返回之前，我们必须要通过方法{@link android.graphics.Bitmap#recycle()}将之前的资源回收掉。如果不需要的话，之前返回原始的图片就可以。 综上，我们已经根据代码路径，分析完成我们所需要做的事情，下面就是我写的例子，实现的效果也简单，就是解决上面的问题中提到的，如何在图片的中间加一条横线。上代码，Github： public class PostProcessActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_postprocess); ImageView imageview = (ImageView)findViewById(R.id.imageview); Picasso picasso = Picasso.with(getApplicationContext()); DrawLineTransformation myTransformation = new DrawLineTransformation(); picasso.load(&quot;http://www.baidu.com/img/bdlogo.png&quot;).transform(myTransformation).into(imageview); } class DrawLineTransformation implements Transformation { @Override public String key() { // TODO Auto-generated method stub return &quot;drawline&quot;; } @Override public Bitmap transform(Bitmap bitmap) { // TODO Auto-generated method stub synchronized (DrawLineTransformation.class) { if(bitmap == null) { return null; } Bitmap resultBitmap = bitmap.copy(bitmap.getConfig(), true); Canvas canvas = new Canvas(resultBitmap); Paint paint = new Paint(); paint.setColor(Color.BLUE); paint.setStrokeWidth(10); canvas.drawLine(0, resultBitmap.getHeight()/2, resultBitmap.getWidth(), resultBitmap.getHeight()/2, paint); bitmap.recycle(); return resultBitmap; } } }} 明白思路之后，代码就很简单了，我注意了几个小细节，如果不相近，请朋友们补充： 同解码一样，在处理的时候，添加同步，同一时刻仅仅处理一张图片 像作者注释中写的一样，在新的图片生成之后，要调用bitmap.recycle()方法释放之前的旧图片所占用的空间。 好了，看一下效果： 后面我们会和Volley一样，继续分析Picasso的源代码。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Picasso","slug":"Android/Picasso","permalink":"http://yoursite.com/categories/Android/Picasso/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Picasso","slug":"Picasso","permalink":"http://yoursite.com/tags/Picasso/"}]},{"title":"Android开发笔记","slug":"android-develop-notes","date":"2014-11-23T04:59:46.000Z","updated":"2018-10-03T14:34:22.560Z","comments":true,"path":"2014/11/23/android-develop-notes/","link":"","permalink":"http://yoursite.com/2014/11/23/android-develop-notes/","excerpt":"","text":"线程或者异步相关：判断是否工作在主线程上 12//From PicassoLooper.getMainLooper().getThread() == Thread.currentThread() 内存相关：获取当前设备中，我们的应用所可以使用的Heap大小：123456789101112131415//From PicassoActivityManager am = getService(context, ACTIVITY_SERVICE);boolean largeHeap = (context.getApplicationInfo().flags &amp; FLAG\\_LARGE\\_HEAP) != 0;int memoryClass = am.getMemoryClass();if (largeHeap &amp;&amp; SDK_INT &gt;= HONEYCOMB) &#123; memoryClass = ActivityManagerHoneycomb.getLargeMemoryClass(am);&#125;@TargetApi(HONEYCOMB)private static class ActivityManagerHoneycomb &#123; static int getLargeMemoryClass(ActivityManager activityManager) &#123; return activityManager.getLargeMemoryClass(); &#125;&#125; 磁盘相关：获取磁盘可用空间大小： 123//From PicassoStatFs statFs = new StatFs(dir.getAbsolutePath());long available = ((long) statFs.getBlockCount()) * statFs.getBlockSize(); 手机工作状态：是否工作在飞行模式：12345//From Picassostatic boolean isAirplaneModeOn(Context context) &#123; ContentResolver contentResolver = context.getContentResolver(); return Settings.System.getInt(contentResolver, AIRPLANE\\_MODE\\_ON, 0) != 0;&#125; 获取当前的网络状态：1234567891011121314151617181920212223242526272829303132public NetworkState getNetworkState(NetworkInfo info) &#123; switch (info.getType()) &#123; case ConnectivityManager.TYPE_WIFI: case ConnectivityManager.TYPE_WIMAX: case ConnectivityManager.TYPE_ETHERNET: return NetworkState.WIFI; case ConnectivityManager.TYPE_MOBILE: switch (info.getSubtype()) &#123; case TelephonyManager.NETWORK\\_TYPE\\_LTE: // 4G case TelephonyManager.NETWORK\\_TYPE\\_HSPAP: case TelephonyManager.NETWORK\\_TYPE\\_EHRPD: return NetworkState.MOBILE_4G; case TelephonyManager.NETWORK\\_TYPE\\_UMTS: // 3G case TelephonyManager.NETWORK\\_TYPE\\_CDMA: case TelephonyManager.NETWORK\\_TYPE\\_EVDO_0: case TelephonyManager.NETWORK\\_TYPE\\_EVDO_A: case TelephonyManager.NETWORK\\_TYPE\\_EVDO_B: return NetworkState.MOBILE_3G; case TelephonyManager.NETWORK\\_TYPE\\_GPRS: // 2G case TelephonyManager.NETWORK\\_TYPE\\_EDGE: return NetworkState.MOBILE_2G; &#125; break; default: return NetworkState.NOTCONNECTED; &#125; return NetworkState.NOTCONNECTED;&#125; ConnectivityManager connectivityManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo info = connectivityManager.getActiveNetworkInfo(); Log.i(TAG, getNetworkState(info).toString()); 当然，需要权限： 12&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS\\_NETWORK\\_STATE\"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=\"android.permission.ACCESS\\_WIFI\\_STATE\"&gt;&lt;/uses-permission&gt; 权限检查是否具有某项权限：123static boolean hasPermission(Context context, String permission) &#123; return context.checkCallingOrSelfPermission(permission) == PackageManager.PERMISSION_GRANTED;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"OOM","slug":"OOM","permalink":"http://yoursite.com/tags/OOM/"},{"name":"线程同步","slug":"线程同步","permalink":"http://yoursite.com/tags/线程同步/"}]},{"title":"Volley源代码学习总结","slug":"android-volley-5-summary","date":"2014-11-22T16:20:29.000Z","updated":"2018-10-03T16:12:52.705Z","comments":true,"path":"2014/11/23/android-volley-5-summary/","link":"","permalink":"http://yoursite.com/2014/11/23/android-volley-5-summary/","excerpt":"","text":"Volley整体框架设计 其实Volley的整体框架就是如上所示，在主线程当中，会维护一个ReqeustQueue，我们要添加的任务，都会添加到这个Reqeust队列当中；任务添加进来之后，运行于cache线程的CacheDispatcher就会取走Reqeust，然后要不从cache中获取结果，要不然发送给NetworkDispatcher；再然后就是NetworkDispatcher从其对应的队列取Request，执行操作。 我们以ImageLoader的典型用法，来分析一下其具体的工作流程： final ImageView imageView = (ImageView)findViewById(R.id.imageview);RequestQueue queue = Volley.newRequestQueue(getApplicationContext());ImageLoader imageLoader = new ImageLoader(queue, new LruBitmapCache(getApplicationContext()));imageLoader.get(“http://www.baidu.com/img/bdlogo.png&quot;, ImageLoader.getImageListener(imageView, R.drawable.ic_launcher, R.drawable.ic_launcher)); ImageLoader根据传入的Image Url和ImageListener，构建一个ImageContainer以及对应的Reqeust 尝试从MemoryCache中获取对应的图像，如果成功，则直接调用ImageListener回调方法 构建ImageContainer，并通过ImageListener通知需要设置默认的图片 根据当前正在执行的任务，查看是否有可以Batch在一起的请求，打包成为BatchImageRequest，其中包含组合在一起的Reqeust的各种信息 构建需要提交给Volley的Reqeust。 ImageLoader将步骤1中构建的Reqeust提交到ReqeustQueue。 ReqeustQueue：该Reqeust是否需要DiskCache？ 不需要：则直接将Request添加至mNetworkQueue当中。 需要：首先检查当前的需要DiskCache的任务当中是否有正在执行的与之Cache Key匹配的任务？ 存在：添加Request到对应的队列当中，等待结果。 不存在：将Request添加到mCacheQueue当中。 CacheDispatcher从队列mCacheQueue中获取优先级最高的任务 检查该任务在DiskCache中是否已经存在？ 不存在：将Request添加到mNetworkQueue当中。 存在：检查是否超过有效期 超过：将Request添加到mNetworkQueue队列当中。 没有超过：Cache Hit，检查是否需要后台刷新数据？： 不需要：通过ResponseDelivery(本质上Handler)，发送Cache Hit结果 需要：ResponseDelivery(本质上Handler)，发送Cache Hit结果，之后再将任务提交至mNetworkQueue NetworkDispatcher从队列mNetworkQueue当中获取优先级最高的任务 执行网络访问请求 判断该Reqeust是否需要Cache，若需要，则写入Cache mDelivery.postResponse(request, response);通知主线程处理结果。 ResponseDelivery中的Handler接收处理结果消息，回调处理具体任务。 这样一看，整体的流程就很清晰了。这里举例使用的是Imageloader，如果是其他的Reqeust，则是省略步骤1即可。 那Response回调是怎么保证在UI线程上执行的呢？在ReqeustQueue的构造函数中，可以配置DeliverDispatcher，而这个Dispatcher中有一个Handler，该Handler的Looper是主线程的Looper，也就是所有发送到对应的Handler的事件都会在主线程当中得到处理。这样也就是保证了Response回调都是在主线程上进行的。也就是可以直接在回调函数中设置UI控件的属性。 Volley适用的场景想起来Google IO大会上介绍Volley的PPT中，有这样一张图： 看到这张图就想起来，适用于同时发生的大量的一次性请求。 Volley不适用的场景，为什么不适用？知道了Volley应该的用处，当然其他的就是不适应的，比如说，下载一个文件？为什么不适应，那下载文件来说，其最大的特点就是，响应稍微慢点也可以，多个任务甚者可以一个一个的来；支持断点续传这是应该必须的吧；Volley接收到的数据都是保存在一个数组当中供后续解析，什么？你要下载个文件，总不能都写到数组里面去吧；Volley没有为这些做优化。 Volley对于OOM问题的处理OOM的问题，Volley处理的还是蛮细致的，当然也没有太消耗体力： 同一个时刻只解析一张图片 构建了一个简单的Byte的Pool避免Heap猛增。 。。。其他的还没想到 等Picasso分析完了再对比一下。","categories":[{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/categories/Volley/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"OOM","slug":"OOM","permalink":"http://yoursite.com/tags/OOM/"},{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/tags/Volley/"}]},{"title":"Picasso学习：Picasso的使用","slug":"picasso-how-to-use","date":"2014-11-22T04:20:31.000Z","updated":"2018-10-03T16:12:52.520Z","comments":true,"path":"2014/11/22/picasso-how-to-use/","link":"","permalink":"http://yoursite.com/2014/11/22/picasso-how-to-use/","excerpt":"","text":"前两天将Volley的源代码分析完毕，这两天再继续看看Picasso的源代码，按照习惯，还是先看看怎么使用，然后再从源代码分析其逻辑实现。 其实Picasso的使用起来和Volley相比，要简单的很多，只要一行就可以使用： Picasso.with(mContext).load(mImagePaths.get(position)).into(viewContainer.image); 很多情况下，我们都是在List或者GridView当中使用的缓存库，那这个时候又该怎么样来使用呢？来写一写 首先是界面布局 activity_main.xml： 界面中子元素的布局 list_item.xml： &lt;?xml version=”1.0” encoding=”utf-8”?&gt; 再然后我们就写一个Adapter： package me.happyhls.picassostudy; import java.util.ArrayList;import java.util.List; import com.squareup.picasso.Picasso; import android.content.Context;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.BaseAdapter;import android.widget.ImageView; public class ImageListAdapter extends BaseAdapter{ private List mImagePaths = new ArrayList&lt;&gt;(); private Context mContext = null; private LayoutInflater mLayoutInflater = null; public ImageListAdapter(Context context, List imagePaths) { mContext = context; mLayoutInflater = LayoutInflater.from(mContext); mImagePaths.addAll(imagePaths); } @Override public int getCount() { // TODO Auto-generated method stub return mImagePaths.size(); } @Override public Object getItem(int position) { // TODO Auto-generated method stub return mImagePaths.get(position); } @Override public long getItemId(int position) { // TODO Auto-generated method stub return position; } @Override public View getView(int position, View convertView, ViewGroup parent) { // TODO Auto-generated method stub ViewContainer viewContainer; if(convertView == null) { convertView = mLayoutInflater.inflate(R.layout.list_item, null); viewContainer = new ViewContainer(); viewContainer.image = (ImageView)convertView.findViewById(R.id.imageview); convertView.setTag(viewContainer); }else { viewContainer = (ViewContainer)convertView.getTag(); } Picasso.with(mContext).load(mImagePaths.get(position)).into(viewContainer.image); return convertView; } private class ViewContainer { ImageView image; } } 最后我们在Activity中，将这些配置起来： package me.happyhls.picassostudy; import java.util.ArrayList;import java.util.List; import android.app.ListActivity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem; public class MainActivity extends ListActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); List&lt;String&gt; imagePaths = new ArrayList&lt;&gt;(); imagePaths.add(&quot;http://img0.bdstatic.com/img/image/daren/taipingyangqiche.jpg&quot;); imagePaths.add(&quot;http://img.baidu.com/img/image/0ebe7571756465617070f813.jpg&quot;); imagePaths.add(&quot;http://img0.bdstatic.com/img/image/ddwefrew.jpg&quot;); imagePaths.add(&quot;http://img.baidu.com/img/image/fb31e5ada4e9ad825f4b656c6576656e32348927.jpg&quot;); imagePaths.add(&quot;http://img.baidu.com/img/image/0ebe7571756465617070f813.jpg&quot;); imagePaths.add(&quot;http://img0.bdstatic.com/img/image/daren/pocotuiguang.jpg&quot;); imagePaths.add(&quot;http://img0.bdstatic.com/img/image/daren/tuchong.jpg&quot;); ImageListAdapter adapter = new ImageListAdapter(MainActivity.this, imagePaths); getListView().setAdapter(adapter); }} 当然，最后不要忘记添加网络访问的权限： 好了，那我们来看看运行结果吧： 发现了吧，其中和Picasso相关的代码只有一个 Picasso.with(mContext).load(mImagePaths.get(position)).into(viewContainer.image); 当然，其实Picasso的功能不仅仅限于这个，还有很多其他的功能，参考： http://square.github.io/picasso/ 比如： 图片的简单变换： Picasso.with(context) .load(url) .resize(50, 50) .centerCrop() .into(imageView) 当然我们可以自己指定自己定义的图片转换器： public class CropSquareTransformation implements Transformation { @Override public Bitmap transform(Bitmap source) { int size = Math.min(source.getWidth(), source.getHeight()); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; Bitmap result = Bitmap.createBitmap(source, x, y, size, size); if (result != source) { source.recycle(); } return result; } @Override public String key() { return “square()”; }} 设置默认的图片，以及访问失败的图片： Picasso.with(context) .load(url) .placeholder(R.drawable.user_placeholder) .error(R.drawable.user_placeholder_error) .into(imageView); 加载资源图片： Picasso.with(context).load(R.drawable.landing_screen).into(imageView1);Picasso.with(context).load(new File(…)).into(imageView2); DEBUG接口： setIndicatorsEnabled(true) 好了，简单熟悉了Picasso的使用，下面我们就开始分析它的源代码。","categories":[{"name":"Picasso","slug":"Picasso","permalink":"http://yoursite.com/categories/Picasso/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Picasso","slug":"Picasso","permalink":"http://yoursite.com/tags/Picasso/"}]},{"title":"Volley源代码分析 – 4: Request实现之ImageRequest&ImageLoader","slug":"android-volley-4-imagerequest-imageloader","date":"2014-11-21T09:07:50.000Z","updated":"2018-10-03T16:12:52.618Z","comments":true,"path":"2014/11/21/android-volley-4-imagerequest-imageloader/","link":"","permalink":"http://yoursite.com/2014/11/21/android-volley-4-imagerequest-imageloader/","excerpt":"","text":"之前把Volley的源代码都分析了一边，基本上整体的思路已经清晰，现在再来分析一下一个具体的Request实现，即ImageRequest。为什么是分析ImageRequest而不是其他的JsonRequest之类。一方面是因为在Android应用开发中，图像的使用比较重要，而且需要小心处理，避免OOM的问题；另外一个原因，相比ImageRequest或者StringRequest，ImageRequest实现稍微复杂，且还有一个辅助的工具类ImageLoader。 ImageRequest/** * A canned request for getting an image at a given URL and calling * back with a decoded Bitmap. * 一个封装的request，用来从指定的URL获取图片，并且回调中返回一个解码的Bitmap /public class ImageRequest extends Request { /\\* Socket timeout in milliseconds for image requests / /\\* Socket超时时间设置 */ private static final int IMAGE_TIMEOUT_MS = 1000; /\\*\\* Default number of retries for image requests */ /\\*\\* 默认重试次数 */ private static final int IMAGE\\_MAX\\_RETRIES = 2; /\\*\\* Default backoff multiplier for image requests */ /\\*\\* Backoff系数，个人理解的是，失败的次数越多，那么下次应该拖的时间也就越长 */ private static final float IMAGE\\_BACKOFF\\_MULT = 2f; private final Response.Listener&lt;Bitmap&gt; mListener; private final Config mDecodeConfig; private final int mMaxWidth; private final int mMaxHeight; /\\*\\* Decoding lock so that we don&apos;t decode more than one image at a time (to avoid OOM&apos;s) */ /\\*\\* 锁，用来保证在同一个时刻仅仅有衣服图片用于解码，避免OOM */ private static final Object sDecodeLock = new Object(); /\\*\\* \\* Creates a new image request, decoding to a maximum specified width and \\* height. If both width and height are zero, the image will be decoded to \\* its natural size. If one of the two is nonzero, that dimension will be \\* clamped and the other one will be set to preserve the image&apos;s aspect \\* ratio. If both width and height are nonzero, the image will be decoded to \\* be fit in the rectangle of dimensions width x height while keeping its \\* aspect ratio. \\* \\* 创建一个新的image request，解码最大为现定的最大宽度和高度。如果两者都是0的话，图片会 \\* 根据其本身的大小进行解码。如果其中一个为0，那么就会根据另外一个边从尺寸进行解码。如果两者 \\* 都不是0，那么图片会在保持其比例的情况下缩放至最长的边也符合。 \\* \\* @param url URL of the image \\* @param listener Listener to receive the decoded bitmap \\* @param maxWidth Maximum width to decode this bitmap to, or zero for none \\* @param maxHeight Maximum height to decode this bitmap to, or zero for \\* none \\* @param decodeConfig Format to decode the bitmap to \\* @param errorListener Error listener, or null to ignore errors */ public ImageRequest(String url, Response.Listener&lt;Bitmap&gt; listener, int maxWidth, int maxHeight, Config decodeConfig, Response.ErrorListener errorListener) { super(Method.GET, url, errorListener); setRetryPolicy( new DefaultRetryPolicy(IMAGE\\_TIMEOUT\\_MS, IMAGE\\_MAX\\_RETRIES, IMAGE\\_BACKOFF\\_MULT)); mListener = listener; mDecodeConfig = decodeConfig; mMaxWidth = maxWidth; mMaxHeight = maxHeight; } @Override public Priority getPriority() { return Priority.LOW; } /\\*\\* \\* Scales one side of a rectangle to fit aspect ratio. \\* 根据其中的一条边求得合适的缩放比例 \\* \\* @param maxPrimary Maximum size of the primary dimension (i.e. width for \\* max width), or zero to maintain aspect ratio with secondary \\* dimension \\* @param maxSecondary Maximum size of the secondary dimension, or zero to \\* maintain aspect ratio with primary dimension \\* @param actualPrimary Actual size of the primary dimension \\* @param actualSecondary Actual size of the secondary dimension */ private static int getResizedDimension(int maxPrimary, int maxSecondary, int actualPrimary, int actualSecondary) { // If no dominant value at all, just return the actual. if (maxPrimary == 0 &amp;&amp; maxSecondary == 0) { return actualPrimary; } // If primary is unspecified, scale primary to match secondary&apos;s scaling ratio. if (maxPrimary == 0) { double ratio = (double) maxSecondary / (double) actualSecondary; return (int) (actualPrimary * ratio); } if (maxSecondary == 0) { return maxPrimary; } double ratio = (double) actualSecondary / (double) actualPrimary; int resized = maxPrimary; if (resized * ratio &gt; maxSecondary) { resized = (int) (maxSecondary / ratio); } return resized; } /\\*\\* \\* 覆写Request的parseNetworkResponse方法，用来解析网络上获取的二进制流为Bitmap图片 */ @Override protected Response&lt;Bitmap&gt; parseNetworkResponse(NetworkResponse response) { // Serialize all decode on a global lock to reduce concurrent heap usage. synchronized (sDecodeLock) { try { return doParse(response); } catch (OutOfMemoryError e) { VolleyLog.e(&quot;Caught OOM for %d byte image, url=%s&quot;, response.data.length, getUrl()); return Response.error(new ParseError(e)); } } } /\\*\\* \\* The real guts of parseNetworkResponse. Broken out for readability. \\* parseNetworkResponse的核心部分，为了易读性放在外面。 */ private Response&lt;Bitmap&gt; doParse(NetworkResponse response) { byte\\[\\] data = response.data; BitmapFactory.Options decodeOptions = new BitmapFactory.Options(); Bitmap bitmap = null; // 判断如果其长度和宽度都指定为0的话，那么就按照原来的尺寸进行解码。 if (mMaxWidth == 0 &amp;&amp; mMaxHeight == 0) { decodeOptions.inPreferredConfig = mDecodeConfig; bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions); } else { // If we have to resize this image, first get the natural bounds. // 如果我们需要对image进行缩放的话，首先通过设置inJustDecodeBounds为true，来获取图片真实的大小 decodeOptions.inJustDecodeBounds = true; BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions); int actualWidth = decodeOptions.outWidth; int actualHeight = decodeOptions.outHeight; // Then compute the dimensions we would ideally like to decode to. // 计算我们实际上要缩放的大小。 int desiredWidth = getResizedDimension(mMaxWidth, mMaxHeight, actualWidth, actualHeight); int desiredHeight = getResizedDimension(mMaxHeight, mMaxWidth, actualHeight, actualWidth); // Decode to the nearest power of two scaling factor. // 首先将图片缩放到最接近我们所需要的大小的合适的比例，该比例为2^x。 decodeOptions.inJustDecodeBounds = false; // TODO(ficus): Do we need this or is it okay since API 8 doesn&apos;t support it? // decodeOptions.inPreferQualityOverSpeed = PREFER\\_QUALITY\\_OVER_SPEED; decodeOptions.inSampleSize = findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight); Bitmap tempBitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions); // If necessary, scale down to the maximal acceptable size. // 如果需要的话，也就是还需要进一步缩放的话，将tempBitmap缩放到合适的大小。 if (tempBitmap != null &amp;&amp; (tempBitmap.getWidth() &gt; desiredWidth || tempBitmap.getHeight() &gt; desiredHeight)) { bitmap = Bitmap.createScaledBitmap(tempBitmap, desiredWidth, desiredHeight, true); // 回收不用的tempBitmap。 tempBitmap.recycle(); } else { bitmap = tempBitmap; } } if (bitmap == null) { return Response.error(new ParseError(response)); } else { return Response.success(bitmap, HttpHeaderParser.parseCacheHeaders(response)); } } /\\*\\* \\* 覆写Response的deliverResponse方法，注意该方法是在main线程上运行的。 */ @Override protected void deliverResponse(Bitmap response) { mListener.onResponse(response); } /\\*\\* \\* Returns the largest power-of-two divisor for use in downscaling a bitmap \\* that will not result in the scaling past the desired dimensions. \\* 寻找最接近所需要缩放尺寸的2^x缩放比例 \\* \\* @param actualWidth Actual width of the bitmap \\* @param actualHeight Actual height of the bitmap \\* @param desiredWidth Desired width of the bitmap \\* @param desiredHeight Desired height of the bitmap */ // Visible for testing. static int findBestSampleSize( int actualWidth, int actualHeight, int desiredWidth, int desiredHeight) { double wr = (double) actualWidth / desiredWidth; double hr = (double) actualHeight / desiredHeight; double ratio = Math.min(wr, hr); float n = 1.0f; while ((n * 2) &lt;= ratio) { n *= 2; } return (int) n; } } 其实该部分的核心的代码是doParse(NetworkResponse response)部分，其工作为： 首先检查，如果不需要缩放，那么就直接解码 需要缩放，则按照以下步骤进行 首先获取图片真实的大小，通过设置BitmapFactory.Options的inJustDecodeBounds属性 计算我们图片根据边框限制，所需要实际缩放的大小 由于在decode的时候，可以设定inSamleSize来获取近似的大小，减少内存占用。 再次判断图片是否完全在给定的范围之内，如果不是，那么进一步缩放。 ImageLoaderImageLoader是基于ImageRequest的一个工具类，在ImageLoader的基础上，根据图片访问的特点做了更多的优化。我们首先来分析其结构。 在ImageLoader当中有很多辅助类用于优化设计，我们先看一看这些都是用来做什么的： ImageCachepublic interface ImageCache { public Bitmap getBitmap(String url); public void putBitmap(String url, Bitmap bitmap);} 图片消耗较大，因此必须使用Cache进行缓存，在系统资源紧张或者图片已经不需使用的时候，及时的释放内存并复用，以减少内存的消耗。在ImageLoader没有默认的Cache实现，需要用户提供。在Volley的User Guide中，有一个简单的LruBitmap的cache的实现，链接为：http://blog.happyhls.me/2014/11/14/volley-lesson-2-making-a-standard-request%EF%BC%88%E8%AF%91%EF%BC%89/ 。该Cache继承了Android提供的LRUCache，以后需要的话再单独分析。 ImageListerner/\\*\\* \\* Interface for the response handlers on image requests. \\* 用来处理response的回调接口 \\* \\* The call flow is this: \\* 1\\. Upon being attached to a request, onResponse(response, true) will \\* be invoked to reflect any cached data that was already available. If the \\* data was available, response.getBitmap() will be non-null. \\* 1、如果和一个request绑定之后，onResponse(response, true)会在被调用，表明在cache中有对应的数据。 \\* 如果数据是可用的，那么response.getBitmap()不是null。 \\* \\* 2\\. After a network response returns, only one of the following cases will happen: \\* \\- onResponse(response, false) will be called if the image was loaded. \\* or \\* \\- onErrorResponse will be called if there was an error loading the image. \\* 2、当network的数据返回的时候，仅仅会发生下面的其中一种情况： \\* \\- onResponse(response, false)会在image加载之后调用 \\* \\- onErrorResponse会在出错的时候调用 */ public interface ImageListener extends ErrorListener { /\\*\\* \\* Listens for non-error changes to the loading of the image request. \\* \\* @param response Holds all information pertaining to the request, as well \\* as the bitmap (if it is loaded). \\* @param isImmediate True if this was called during ImageLoader.get() variants. \\* This can be used to differentiate between a cached image loading and a network \\* image loading in order to, for example, run an animation to fade in network loaded \\* images. */ public void onResponse(ImageContainer response, boolean isImmediate); } 注释中拥有比较详细的描述，主要是设定了一个回调的接口，根据isImmediate来决定其显示的图片是默认的还是结果处理得到的结果。 在ImageLoader当中有一个静态方法，用来获取一个ImageListener实现，我们来观察其代码： public static ImageListener getImageListener(final ImageView view, final int defaultImageResId, final int errorImageResId) { return new ImageListener() { @Override public void onErrorResponse(VolleyError error) { if (errorImageResId != 0) { view.setImageResource(errorImageResId); } } @Override public void onResponse(ImageContainer response, boolean isImmediate) { if (response.getBitmap() != null) { view.setImageBitmap(response.getBitmap()); } else if (defaultImageResId != 0) { view.setImageResource(defaultImageResId); } } }; } 比较简单，不需要多说。 ImageContainer/\\*\\* \\* Container object for all of the data surrounding an image request. \\* 一个容器，其中包含了围绕着image请求的所有的数据 */ public class ImageContainer { /\\*\\* \\* The most relevant bitmap for the container. If the image was in cache, the \\* Holder to use for the final bitmap (the one that pairs to the requested URL). \\* \\* 容器最相关的bitmap。如果图片是在cache中，那么容器会使用这个来指向最终的bitmap。 */ private Bitmap mBitmap; private final ImageListener mListener; /\\*\\* The cache key that was associated with the request */ private final String mCacheKey; /\\*\\* The request URL that was specified */ private final String mRequestUrl; /\\*\\* \\* Constructs a BitmapContainer object. \\* @param bitmap The final bitmap (if it exists). \\* @param requestUrl The requested URL for this container. \\* @param cacheKey The cache key that identifies the requested URL for this container. */ public ImageContainer(Bitmap bitmap, String requestUrl, String cacheKey, ImageListener listener) { mBitmap = bitmap; mRequestUrl = requestUrl; mCacheKey = cacheKey; mListener = listener; } /\\*\\* \\* Releases interest in the in-flight request (and cancels it if no one else is listening). */ public void cancelRequest() { if (mListener == null) { return; } BatchedImageRequest request = mInFlightRequests.get(mCacheKey); if (request != null) { //此时reqeust对应的已经开始在执行 //判断是否需要取消整个任务，即同一个URL是否还有其他的地方在用 boolean canceled = request.removeContainerAndCancelIfNecessary(this); if (canceled) { mInFlightRequests.remove(mCacheKey); } } else { // check to see if it is already batched for delivery. //此时尚未执行 request = mBatchedResponses.get(mCacheKey); if (request != null) { request.removeContainerAndCancelIfNecessary(this); if (request.mContainers.size() == 0) { mBatchedResponses.remove(mCacheKey); } } } } /\\*\\* \\* Returns the bitmap associated with the request URL if it has been loaded, null otherwise. */ public Bitmap getBitmap() { return mBitmap; } /\\*\\* \\* Returns the requested URL for this container. */ public String getRequestUrl() { return mRequestUrl; } } 这是一个容器类，用来存储与图片访问相关的任务信息，那么这个时候大家可能就问了，在Volley中既然已经有了一个默认的实现ImgeRequest，那么为什么还需要再做一个ImageContainer来保存期相关的信息呢？通过读ImageLoader的源代码可以发现，其实Volley为了尽可能减少资源的消耗，会将图片请求进行检查，如果图片的地址是一致的，这里面对应的CacheKey是一样的话，那么就会合并为一个任务，然后再提交给ReqeustQueue去执行。当Network返回结果的时候，就会检查该CacheKey对应的多有的任务信息，依次派发出去。 这个类比较简单，主要存储了Bitmap，ImageListener，CacheKey，ReqeustUrl等。然后还有一个Cancel方法，其思路则是判断该任务是否已经有了请求的结果，如果有的话，那么就删除对应的结果；如果没有请求的结果，则从正在执行的任务队列中删除。 BatchedImageRequest/\\*\\* \\* Wrapper class used to map a Request to the set of active ImageContainer objects that are \\* interested in its results. \\* 一个包装来，用来包装那些活跃的ImageContainer的集合。 */ private class BatchedImageRequest { /\\*\\* The request being tracked */ private final Request&lt;?&gt; mRequest; /\\*\\* The result of the request being tracked by this item */ private Bitmap mResponseBitmap; /\\*\\* Error if one occurred for this response */ private VolleyError mError; /\\*\\* List of all of the active ImageContainers that are interested in the request */ /\\*\\* 该图片的所有的请求，注意此reqeust并不是Volley中的Reqeust，而是需要做的任务，使用的ImageContainer类来保存相关的信息 */ private final LinkedList&lt;ImageContainer&gt; mContainers = new LinkedList&lt;ImageContainer&gt;(); /\\*\\* \\* Constructs a new BatchedImageRequest object \\* @param request The request being tracked \\* @param container The ImageContainer of the person who initiated the request. */ public BatchedImageRequest(Request&lt;?&gt; request, ImageContainer container) { mRequest = request; mContainers.add(container); } /\\*\\* \\* Set the error for this response */ public void setError(VolleyError error) { mError = error; } /\\*\\* \\* Get the error for this response */ public VolleyError getError() { return mError; } /\\*\\* \\* Adds another ImageContainer to the list of those interested in the results of \\* the request. */ public void addContainer(ImageContainer container) { mContainers.add(container); } /\\*\\* \\* Detatches the bitmap container from the request and cancels the request if no one is \\* left listening. \\* 从容器中删掉对应的任务，如果删掉之后，对应的任务列表为空，则可以取消该任务，否则返回false \\* @param container The container to remove from the list \\* @return True if the request was canceled, false otherwise. */ public boolean removeContainerAndCancelIfNecessary(ImageContainer container) { mContainers.remove(container); if (mContainers.size() == 0) { mRequest.cancel(); return true; } return false; } } 该类就是完成我们刚刚提到的合并任务的功能。其中有一个链表LinkedList mContainers = new LinkedList();用来保存所有的同样的请求对应的任务信息。 说到这里，我们刚刚一直说到cacheKey，那么cacheKey到底是怎么样计算的呢？如下： private static String getCacheKey(String url, int maxWidth, int maxHeight) { return new StringBuilder(url.length() + 12).append(&quot;#W&quot;).append(maxWidth) .append(&quot;#H&quot;).append(maxHeight).append(url).toString(); 可以看到包含了两部分内容 URL maxWidth，maxHeight 到这里的分析，我们还是一头雾水，ImageLoader到底从哪里开始工作呢？最简单的办法是先跟着代码的流程走，一段典型的ImageLoader的使用代码为： ImageView imageView = (ImageView) findViewById(R.id.imageview); VolleyLog.setTag(getPackageName()); RequestQueue requestQueue = Volley.newRequestQueue(getApplicationContext()); ImageLoader imageLoader = new ImageLoader(requestQueue, new LruBitmapCache(getApplicationContext())); imageLoader.get(&quot;http://www.baidu.com/img/bdlogo.png&quot;, imageLoader.getImageListener(imageView, R.drawable.ic\\_launcher, R.drawable.ic\\_launcher)); 从上面我们可以看出，所有的事件的发起，都是从get()方法开始的，那我们继续分析get方法 public ImageContainer get(String requestUrl, ImageListener imageListener, int maxWidth, int maxHeight) { // only fulfill requests that were initiated from the main thread. // 仅仅去完成那些在主线程上发起调用的请求，因为最后需要设置ImageView，只能在UI线程，即主线程上操作。 throwIfNotOnMainThread(); final String cacheKey = getCacheKey(requestUrl, maxWidth, maxHeight); // Try to look up the request in the cache of remote images. // 尝试从cache中查找对应的图片 Bitmap cachedBitmap = mCache.getBitmap(cacheKey); if (cachedBitmap != null) { // Return the cached bitmap. // 如果有，那么就分配一个ImageContainer ImageContainer container = new ImageContainer(cachedBitmap, requestUrl, null, null); // 设置相应的图片 imageListener.onResponse(container, true); return container; } // The bitmap did not exist in the cache, fetch it! // 图片在cache中不存在，需要从网络上获取 ImageContainer imageContainer = new ImageContainer(null, requestUrl, cacheKey, imageListener); // Update the caller to let them know that they should use the default bitmap. // 让其显示默认的图片 imageListener.onResponse(imageContainer, true); // Check to see if a request is already in-flight. // 检查是否有可以合并的请求，已经在处理当中 BatchedImageRequest request = mInFlightRequests.get(cacheKey); if (request != null) { // If it is, add this request to the list of listeners. // 如果有，则添加到相应的队列当中，并返回 request.addContainer(imageContainer); return imageContainer; } // The request is not already in flight. Send the new request to the network and // track it. // 发起一个新的Image请求 Request&lt;Bitmap&gt; newRequest = makeImageRequest(requestUrl, maxWidth, maxHeight, cacheKey); //添加到RequestQueue当中 mRequestQueue.add(newRequest); mInFlightRequests.put(cacheKey, new BatchedImageRequest(newRequest, imageContainer)); return imageContainer; } 画一下其原理图 好了，从上面的流程图我们也可以看出： 我们判断该段代码是否工作在UI线程，如果不是工作在主线程，那么则会抛出异常并退出。 根据图片的URL地址和相关的大小，获取在ImageLoader内部使用的唯一的CacheKey 根据CacheKey去在ImageCache中查找是否有对应的图片，如果有的话，则将信息保存在ImageContainer当中，然后通过imageListener的回调，返回结果 在Cache中没有，则说明需要通过网络进行请求 先查找该CacheKey是否已经在之前发起过请求，也可能是别处同样的图片地址和大小，也在执行请求。 根据情况分别进行处理 如果已经在BatchedReqeust中存在，那么则直接将这一次的请求添加到正在处理的请求中就可以。 如果没有，那么则新建一个Volley的Reqeust，并添加到对应的RequestQueue当中。 最后返回对应的ImageContainer即可。","categories":[{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/categories/Volley/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/tags/Volley/"}]},{"title":"Volley源代码分析 – 3: 缓存之ByteArrayPool","slug":"android-volley-3-cache-bytearraypool","date":"2014-11-20T08:01:44.000Z","updated":"2018-10-03T15:14:17.415Z","comments":true,"path":"2014/11/20/android-volley-3-cache-bytearraypool/","link":"","permalink":"http://yoursite.com/2014/11/20/android-volley-3-cache-bytearraypool/","excerpt":"","text":"在Android的开发当中，需要特别小心内存的时候，如果不去控制内存的使用，任意新建或者删除对象，虽然GC可以及时的会收到大量的内存空间，但由于很多情况下，我们的细节也不会处理的特别到位，因此就会出现内存泄漏，最典型的就是，你这部分堆中的内存永远都不会被使用到了，但仍然在栈中有对象指向它。 在Volley的实际中，也特别注意到了这一点。其实很容易想象到，大量的网络访问，接收到的数据结果一般都会保存在一个byte[]的数组当中，然后再调用其他的处理类进行数据分析。我们也知道，Volley的设计初衷是满足那些大量的频繁的网络访问，因此如果直接简单的通过new byte[length]来新建一个数组，必然会大量的频繁的向系统申请内存，如果这些内存处理得到，那么也会消耗大量的GC时间，更别说处理不当带来的内存泄漏，必然导致我们的APP的堆空间的使用量不断上升。此外还可能引入大量的新建对象的资源消耗，当然这个微乎其微。综上，为了解决这些问题，而且又能够保证Volley作为library的轻量，Volley的设计者设计了一个简单的byte[]的池，即ByteArrayPool类，先看源代码，然后再分析一下其原理和作用。 package com.android.volley.toolbox; import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.LinkedList;import java.util.List; /** * ByteArrayPool is a source and repository of byte[] objects. Its purpose is to * supply those buffers to consumers who need to use them for a short period of time and then * dispose of them. Simply creating and disposing such buffers in the conventional manner can * considerable heap churn and garbage collection delays on Android, which lacks good management of * short-lived heap objects. It may be advantageous to trade off some memory in the form of a * permanently allocated pool of buffers in order to gain heap performance improvements; that is * what this class does. * * ByteArrayPool是一个byte[]对象的源和仓库。其目的在于支持那些用户所需要的使用一段时间，然后丢弃的buffer。 * 在一般的情况下，直接创建，然后丢弃这样的buffer堆空间的大量消耗以及在Android设备的垃圾回收延时，这些都是缺少 * 一个良好的对于短生命周期的堆的管理。申请一块永久的空间来获取堆性能上的提升是有价值的，这也是这个类的作用。 * * * A good candidate user for this class is something like an I/O system that uses large temporary * byte[] buffers to copy data around. In these use cases, often the consumer wants * the buffer to be a certain minimum size to ensure good performance (e.g. when copying data chunks * off of a stream), but doesn’t mind if the buffer is larger than the minimum. Taking this into * account and also to maximize the odds of being able to reuse a recycled buffer, this class is * free to return buffers larger than the requested size. The caller needs to be able to gracefully * deal with getting buffers any size over the minimum. * 一个比较好的使用环境是比如像I/O系统中大量的临时的byte[]缓冲的数据拷贝。在这些使用情况中，大多数情况下，用户想要 * 一个比较小的特定的空间来保证一个好的性能(比如从一个数据流中拷贝一个数据块)，但并不会关心这个buffer是否大于他们 * 所需要的最小的块。考虑到这些，也是尽可能的重用这个可回收的buffer，这个类返回大于请求大小的buffer。调用者需要优雅 * 的处理任何比最小的所需要的buffer大的空间。 * * If there is not a suitably-sized buffer in its recycling pool when a buffer is requested, this * class will allocate a new buffer and return it. * 如果一个请求提交的时候，在回收池当中没有合适的大小的buffer，那么这个类就会申请一块新的空间并且返回。 * * This class has no special ownership of buffers it creates; the caller is free to take a buffer * it receives from this pool, use it permanently, and never return it to the pool; additionally, * it is not harmful to return to this pool a buffer that was allocated elsewhere, provided there * are no other lingering references to it. * 该类对于其创建的buffer没有拥有者的概念；调用者可以自由的从pool中获取buffer，永久的使用这些buffer，不再归还。 * 除此之外，如果从其他的地方申请了buffer，归还到这个位置，也是没有任何坏处的。 * * This class ensures that the total size of the buffers in its recycling pool never exceeds a * certain byte limit. When a buffer is returned that would cause the pool to exceed the limit, * least-recently-used buffers are disposed. * 这个类保证了回收池中总共的buffer的大小用于不会超过其限制。当返回一个buffer会导致buffer池接近其极限的时候， * least-recently-used的buffer就会被丢弃。 *//** * 我的理解：该buffer的作用就在于通过保存一些buffer来减少申请空间的次数，从而更加优化堆的使用。 * 其方法是，当需要buffer的时候，从这里面取，如果没有合适的，那么就申请，如果申请到了的话，那么就将这块buffer从 * 记录的List中删除。 * 当buffer不用的时候，就将buffer归还，方法是，首先根据buffer的长度将buffer放入到mBuffersBySize的合适的位置上， * 然后判断新的buffer的大小是否超过了预设的大小限制，如果超过了的话，那么就从中删除那个占用空间最小的。 /public class ByteArrayPool { /** The buffer pool, arranged both by last use and by buffer size / /\\* buffer池，通过LastUse和大小管理 */ private List&lt;byte[]&gt; mBuffersByLastUse = new LinkedList&lt;byte[]&gt;(); private List&lt;byte[]&gt; mBuffersBySize = new ArrayList&lt;byte[]&gt;(64); /\\*\\* The total size of the buffers in the pool */ /\\*\\* 池中所有的buffer大小的总和 */ private int mCurrentSize = 0; /\\*\\* \\* The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay \\* under this limit. \\* 最大的buffers的大小的数量。当接近最大值的时候，就的buffer就会被丢弃。 */ private final int mSizeLimit; /\\*\\* Compares buffers by size */ /\\*\\* 通过buffer的大小进行比较 */ protected static final Comparator&lt;byte\\[\\]&gt; BUF_COMPARATOR = new Comparator&lt;byte\\[\\]&gt;() { @Override public int compare(byte\\[\\] lhs, byte\\[\\] rhs) { return lhs.length - rhs.length; } }; /\\*\\* \\* @param sizeLimit the maximum size of the pool, in bytes */ public ByteArrayPool(int sizeLimit) { mSizeLimit = sizeLimit; } /\\*\\* \\* Returns a buffer from the pool if one is available in the requested size, or allocates a new \\* one if a pooled one is not available. \\* 从池总获取一个buffer，如果大小合适，则直接读取，如果不合适，则申请一块空间。 \\* \\* @param len the minimum size, in bytes, of the requested buffer. The returned buffer may be \\* larger. \\* @return a byte\\[\\] buffer is always returned. */ public synchronized byte\\[\\] getBuf(int len) { for (int i = 0; i &lt; mBuffersBySize.size(); i++) { byte\\[\\] buf = mBuffersBySize.get(i); if (buf.length &gt;= len) { //此块buffer大小满足长度要求 //当前buffer池可用大小减去buf的长度 mCurrentSize -= buf.length; //该buffer刚刚被使用，所以从mBuffersBySize中删掉 mBuffersBySize.remove(i); //该buffer刚刚被使用，所以从mBuufersByLastUse中删掉 mBuffersByLastUse.remove(buf); //返回该buffer return buf; } } return new byte\\[len\\]; } /\\*\\* \\* Returns a buffer to the pool, throwing away old buffers if the pool would exceed its allotted \\* size. \\* 将一块buffer归还给池，如果pool达到其分配的大小，则丢弃任何的旧的buffer。 \\* @param buf the buffer to return to the pool. */ public synchronized void returnBuf(byte\\[\\] buf) { if (buf == null || buf.length &gt; mSizeLimit) { return; } //将该buffer放入到mBuufersByLastUse当中。 mBuffersByLastUse.add(buf); //找到在mBuffersBySize中合适的位置。 int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR); if (pos &lt; 0) { pos = -pos - 1; } //将buffer添加到合适的位置上。 mBuffersBySize.add(pos, buf); //将可用的buffer长度进行修改。 mCurrentSize += buf.length; trim(); } /\\*\\* \\* Removes buffers from the pool until it is under its size limit. \\* 如果当前系统中的可用buffer过多的话，则删除其中最小的buffer。 */ private synchronized void trim() { while (mCurrentSize &gt; mSizeLimit) { byte\\[\\] buf = mBuffersByLastUse.remove(0); mBuffersBySize.remove(buf); mCurrentSize -= buf.length; } } } 其实整个ByteArrayPool的程序比较简单，我的理解就是 该buffer的作用就在于通过保存一些buffer来减少申请空间的次数，从而更加优化堆的使用（可能在使用率不高的时候，会浪费一定的内存空间，但代价不高）。 其方法是 当需要buffer的时候，从这里面取，如果没有合适的，那么就申请一个新的大小合适的buffer。 如果申请到了的话，那么就将这块buffer从记录的List中删除。即意味着再次有其他程序获取buffer的时候，不会使用到这块buffer。 当buffer使用完毕时候，就将buffer归还。方法是： 根据buffer的长度将buffer放入到mBuffersBySize的合适的位置上 判断现在ByteArrayPool所占用的空间是否超过了预设的大小，如果超过了的话，那么就从中删除那个占用空间最小的。 基于ByteArrayPool的PoolingByteArrayOutputStream /** * A variation of {@link java.io.ByteArrayOutputStream} that uses a pool of byte[] buffers instead * of always allocating them fresh, saving on heap churn. /public class PoolingByteArrayOutputStream extends ByteArrayOutputStream { /\\* * If the {@link #PoolingByteArrayOutputStream(ByteArrayPool)} constructor is called, this is * the default size to which the underlying byte array is initialized. */ private static final int DEFAULT_SIZE = 256; private final ByteArrayPool mPool; /\\*\\* \\* Constructs a new PoolingByteArrayOutputStream with a default size. If more bytes are written \\* to this instance, the underlying byte array will expand. */ public PoolingByteArrayOutputStream(ByteArrayPool pool) { this(pool, DEFAULT_SIZE); } /\\*\\* \\* Constructs a new {@code ByteArrayOutputStream} with a default size of {@code size} bytes. If \\* more than {@code size} bytes are written to this instance, the underlying byte array will \\* expand. \\* \\* @param size initial size for the underlying byte array. The value will be pinned to a default \\* minimum size. */ public PoolingByteArrayOutputStream(ByteArrayPool pool, int size) { mPool = pool; buf = mPool.getBuf(Math.max(size, DEFAULT_SIZE)); } @Override public void close() throws IOException { mPool.returnBuf(buf); buf = null; super.close(); } @Override public void finalize() { mPool.returnBuf(buf); } /\\*\\* \\* Ensures there is enough space in the buffer for the given number of additional bytes. */ private void expand(int i) { /\\* Can the buffer handle @i more bytes, if not expand it */ if (count + i &lt;= buf.length) { return; } byte\\[\\] newbuf = mPool.getBuf((count + i) * 2); System.arraycopy(buf, 0, newbuf, 0, count); mPool.returnBuf(buf); buf = newbuf; } @Override public synchronized void write(byte\\[\\] buffer, int offset, int len) { expand(len); super.write(buffer, offset, len); } @Override public synchronized void write(int oneByte) { expand(1); super.write(oneByte); } } 需要注意的几点： 继承自ByteArrayOutputStream，所有的写入操作都是同步的 在写入之前首先会检查是否需要扩展buffer的空间。 覆写了finalize()方法，当垃圾回收的时候，会尝试归还所申请的空间，但注意，JVM并不保证这段代码一定会执行，而且在此实例的声明周期中，只会执行一次。所以我们尽量要调用close()方法显示的归还。 当然，如果不归还也没太大的问题，空间还是会被垃圾回收的，但就违背了我们使用这个输出流的初衷了。 性能？打算跑个测试看一下，应该还是不错，基本的测试思路是，开N个线程，在N个线程中申请随机大小的空间，如此重复，观察内存的占用情况。","categories":[{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/categories/Volley/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/tags/Volley/"},{"name":"Buffer","slug":"Buffer","permalink":"http://yoursite.com/tags/Buffer/"},{"name":"Cache","slug":"Cache","permalink":"http://yoursite.com/tags/Cache/"}]},{"title":"Volley源代码分析 – 2：任务的执行，CacheDispatcher、NetworkDispatcher、ResponseDelivery","slug":"android-volley-2-task-execution","date":"2014-11-19T09:05:39.000Z","updated":"2018-10-03T16:12:52.616Z","comments":true,"path":"2014/11/19/android-volley-2-task-execution/","link":"","permalink":"http://yoursite.com/2014/11/19/android-volley-2-task-execution/","excerpt":"","text":"首先，重温Volley框架图： 我们所有的代码都是围绕这个框架来分析。所以为什么现在来看看CacheDispatcher和NetworkDispatcher？ 从上面的框架图可以看出，大部分任务的执行都是通过CacheDispatcher和NetworkDispatcher来分发的。 从RequestQueue的代码入手，启动了RequestQueue之后(调用RequestQueue的start()方法)，主要做了两件事情，启动1个CacheDispatcher线程，启动多个NetworkDispatcher线程。 这里是RequestQueue的start()代码： public void start() { stop(); // Make sure any currently running dispatchers are stopped. 确保当前正在运行的调度器已经停止。 // Create the cache dispatcher and start it. 创建调度器，并且启动它 mCacheDispatcher = new CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery); mCacheDispatcher.start(); // Create network dispatchers (and corresponding threads) up to the pool size. // 创建网络的调度器，最高启动线程池大小个调度器。 for (int i = 0; i &lt; mDispatchers.length; i++) { NetworkDispatcher networkDispatcher = new NetworkDispatcher(mNetworkQueue, mNetwork, mCache, mDelivery); mDispatchers\\[i\\] = networkDispatcher; networkDispatcher.start(); } } 所以说，从哪个角度讲，都应该分析CacheDispatcher和NetworkDispatcher。 CacheDispatcher刚刚看RequestQueue的start()代码，看到mCacheDispatcher.start()的调用，其实就应该想到，这必然是个线程啊，当然，从一开始框架图更应该看出来。所以初始化之类的我们不需要关心，只要看一下其run()方法里面，都做了一些什么样的工作？ @Override public void run() { if (DEBUG) VolleyLog.v(&quot;start new dispatcher&quot;); //设定优先级会后台优先级。 Process.setThreadPriority(Process.THREAD\\_PRIORITY\\_BACKGROUND); // Make a blocking call to initialize the cache. // 阻塞调用，初始化cache mCache.initialize(); while (true) { try { // Get a request from the cache triage queue, blocking until // at least one is available. // 从cache中获取一个待分类的cache，采用了blocking的队列，会一直阻塞直到有可用的位置。 final Request&lt;?&gt; request = mCacheQueue.take(); request.addMarker(&quot;cache-queue-take&quot;); // If the request has been canceled, don&apos;t bother dispatching it. // 检查请求是否已经被取消，如果是的话，则放弃该请求，重新获取新的进行调度。 if (request.isCanceled()) { request.finish(&quot;cache-discard-canceled&quot;); continue; } // Attempt to retrieve this item from cache. // 尝试从Cache中获取数据 Cache.Entry entry = mCache.get(request.getCacheKey()); if (entry == null) { // 从Cache中获取数据失败，意味着cache miss，需要从网络中重新获取 request.addMarker(&quot;cache-miss&quot;); // Cache miss; send off to the network dispatcher. // 将请求添加到网络任务队列中。 mNetworkQueue.put(request); continue; } // If it is completely expired, just send it to the network. // 此处和上面情况类似，但是不是cache缺失，而是cache过期 if (entry.isExpired()) { request.addMarker(&quot;cache-hit-expired&quot;); // 更新之前，首先将数据保存一份。 request.setCacheEntry(entry); // 将Request添加到网络任务队列当中。 mNetworkQueue.put(request); continue; } // We have a cache hit; parse its data for delivery back to the request. // 到此处已经检查过Cache是否确实，Cache是否过期，此时说明数据从Cache中取回即可。 request.addMarker(&quot;cache-hit&quot;); // 首先将cache中的raw数据进行解析。 Response&lt;?&gt; response = request.parseNetworkResponse( new NetworkResponse(entry.data, entry.responseHeaders)); request.addMarker(&quot;cache-hit-parsed&quot;); if (!entry.refreshNeeded()) { // Completely unexpired cache hit. Just deliver the response. // 此时数据不需要更新，直接将数据分发出去。 mDelivery.postResponse(request, response); } else { // Soft-expired cache hit. We can deliver the cached response, // but we need to also send the request to the network for // refreshing. // 此时数据虽然说是cache命中了，但数据需要进行更新。 request.addMarker(&quot;cache-hit-refresh-needed&quot;); request.setCacheEntry(entry); // Mark the response as intermediate. // 标记该response为一个中间结果，以后还会需要更新 response.intermediate = true; // Post the intermediate response back to the user and have // the delivery then forward the request along to the network. // 将中间结果返回给用户，并且将请求转发给网络层。 // 但不清楚为什么要将添加到网络队列的过程放在其他线程中去做--&gt;查看该方法的签名，该方法是首先将结果传递给用户，然后再执行Runnable mDelivery.postResponse(request, response, new Runnable() { @Override public void run() { try { mNetworkQueue.put(request); } catch (InterruptedException e) { // Not much we can do about this. } } }); } } catch (InterruptedException e) { // We may have been interrupted because it was time to quit. if (mQuit) { return; } continue; } } } 和前面的文章一样，我们还是先来画一张流程图来分析一下： 这一部分就是在CacheDispatcher的线程中循环执行的部分，我们可以看到Cachedispatcher主要做了以下的工作： 从阻塞队列中取出一个需要处理的Request，如果没有，则一直等待。 取出之后，首先判断该Request是否已经被取消了，如果是的话，则调用Request.finish()方法取消相应的Request。并重新获取下一个需要执行的Request。 尝试从cache中获取cacheKey对应的entry。如果entry是null，则没有取到entry，需要放到网络任务中执行。 此时entry必然是有数据的，再一步判断entry是否在有效期，如果已经过期，则保留一份数据，然后提交到网络的任务队列当中执行。 此时entry是有效的而且没有过期，所以对结果进行解析。 根据entry中的数据判断数据是否需要刷新了，有的时候，这些数据现在还是有效，但可能过很短的时间就过期，那么在后面的操作中就记得需要刷新这些数据。 如果不需要刷新，就直接通过mDelivery分发结果 如果需要刷新，则设置Cache的数据备份，然后设置需要刷新的标签 调用postReqonse中带有Runnalbe参数的那个方法，首先将结果进行分发，分发完成之后则将该任务添加到网络的任务队列当中。 总结就是，首先尝试获取Cache对应的数据，如果没有数据，则扔到mNetworkQueue中等待执行，有的话，则判断是否过期，是否后续需要刷新，再分发结果，或者继续放进mNetworkQueue中即可。 NetworkDispatcher同样的办法，我们继续分析一下NetworkDispatcher的工作原理，首先上源代码： public void run() { //设置进程的优先级为后台进程。 Process.setThreadPriority(Process.THREAD\\_PRIORITY\\_BACKGROUND); while (true) { Request&lt;?&gt; request; try { // Take a request from the queue. // 从任务队列中获取一个请求 request = mQueue.take(); } catch (InterruptedException e) { // We may have been interrupted because it was time to quit. if (mQuit) { return; } continue; } try { //添加日志 request.addMarker(&quot;network-queue-take&quot;); // If the request was cancelled already, do not perform the // network request. // 如果该请求已经被取消，那么就不再处理 if (request.isCanceled()) { request.finish(&quot;network-discard-cancelled&quot;); continue; } //添加流量统计信息标记。 addTrafficStatsTag(request); // Perform the network request. // 从网络中获取请求数据 NetworkResponse networkResponse = mNetwork.performRequest(request); request.addMarker(&quot;network-http-complete&quot;); // If the server returned 304 AND we delivered a response already, // we&apos;re done -- don&apos;t deliver a second identical response. // 如果服务器已经返回了304，并且我们已经进行过同样的请求，那么就不需要再处理 // HTTP 304 = 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。 if (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) { request.finish(&quot;not-modified&quot;); continue; } // Parse the response here on the worker thread. // 在工作线程中，对网络请求返回的数据进行解析 Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse); request.addMarker(&quot;network-parse-complete&quot;); // Write to cache if applicable. // TODO: Only update cache metadata instead of entire record for 304s. // 如果需要，则写入cache。注意，对于304，则只写入元数据，而非整个全部数据 if (request.shouldCache() &amp;&amp; response.cacheEntry != null) { mCache.put(request.getCacheKey(), response.cacheEntry); request.addMarker(&quot;network-cache-written&quot;); } // Post the response back. // 标记该请求已经分发过。 request.markDelivered(); // 将解析的结果分发给main线程。 mDelivery.postResponse(request, response); } catch (VolleyError volleyError) { parseAndDeliverNetworkError(request, volleyError); } catch (Exception e) { VolleyLog.e(e, &quot;Unhandled exception %s&quot;, e.toString()); mDelivery.postError(request, new VolleyError(e)); } } } 同样的，我们也画一张流程图来分析一下NetworkDispatcher都做了什么事情。 从上图我们可以看出，NetworkDispatcher的run()方法中所做的事情和CacheDispatcher所做的事情基本上是类似的。 首先从阻塞队列中获取一个需要处理的Request。如果没有可以处理的Request，则阻塞等待。 判断这个request是否已经被取消了，如果取消了，则调用request的finish()方法。 添加流量统计 通过网络访问，获取网络访问的返回结果 如果说数据没有修改，而且数据结果已经被分发过，那么就可以终止该任务。 新的数据，那么需要解析数据 判断是否需要cache，如果需要，则写入cache，如果不需要则跳过。 标记该请求已经分发过，同时通过mDevliery派发结果。 ResponseDelivery通过分析上面的代码，我们可以发现，所有的操作的最后，都要讲Response交给mDelivery的postResponse方法当中，也就是要将结果分发出去。那么具体是怎么实现的呢？ ResponseDelivery的源代码如下： public interface ResponseDelivery { /** * Parses a response from the network or cache and delivers it. * * 解析从网络或者cache获取的相应，然后派发结果 */ public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response); /\\*\\* \\* Parses a response from the network or cache and delivers it. The provided \\* Runnable will be executed after delivery. \\* \\* 解析从网络或者cache获取的相应，然后派发结果，提供的Runnable将在派发之后执行。 */ public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable); /\\*\\* \\* Posts an error for the given request. \\* \\* 对给定的request返回error。 */ public void postError(Request&lt;?&gt; request, VolleyError error); } 从上我们可以看出，ResponseDelivery是一个接口，其中共有三个方法签名，实际上前两种是做的同一件事情，只是签名不同而已。在Volley中，有一个默认的实现，基本上我们也不会去修改它，就是ExecutorDelivery。 该方法共有两个构造函数，分别是 public ExecutorDelivery(final Handler handler) { // Make an Executor that just wraps the handler. mResponsePoster = new Executor() { @Override public void execute(Runnable command) { //默认情况下，这段代码的调用位于调用者的线程之上。 handler.post(command); } }; } public ExecutorDelivery(Executor executor) { mResponsePoster = executor; } 可以看出，一共有两个构造函数，一个其参数为Executor，即调用者传递给他一个executor，另外一种是传递一个handler进来，然后在构造函数中定义一个继承了Executor的匿名类，在execute(Runnable command)方法中，将command发送给handler到对应的线程上去处理。那么这个线程是什么呢？ 我们跟踪代码，发现在Volley内部，只有对第一个构造函数，即 public ExecutorDelivery(final Handler handler); 是已经使用了的，在RequestQueue的构造函数当中： public RequestQueue(Cache cache, Network network, int threadPoolSize) { this(cache, network, threadPoolSize, new ExecutorDelivery(new Handler(Looper.getMainLooper()))); } 在RequestQueue当中，实例化了一个ExecutorDelivery，需要注意的是，此时传入ExecutorDelivery构造函数所对应的Looper为Looper.getMainLooper()，也就是说，handler发送的消息都是在主线程即UI线程上进行处理的。这也就可以解释了之前我们看Android当中Volley的文档，其中一直在强调，所有的结果的分发都是在主线程上完成的。 我们继续查看源代码，看看ExecutorDelivery是怎么样来分发结果的。其实现的ReuestDelivery的接口的实现为： @Override public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response) { postResponse(request, response, null); } @Override public void postResponse(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable) { request.markDelivered(); request.addMarker(&quot;post-response&quot;); mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, runnable)); } @Override public void postError(Request&lt;?&gt; request, VolleyError error) { request.addMarker(&quot;post-error&quot;); Response&lt;?&gt; response = Response.error(error); mResponsePoster.execute(new ResponseDeliveryRunnable(request, response, null)); } 可以发现其主要做了两件事情： 调用request.markDelivered()来标记该request已经分发过了。 将一个Runnalbe对象实际上交给了主线程的handler去执行。 因此我们继续看看这个Runnable都做了哪些工作，该Runnable的代码如下： @SuppressWarnings(&quot;rawtypes&quot;) private class ResponseDeliveryRunnable implements Runnable { private final Request mRequest; private final Response mResponse; private final Runnable mRunnable; public ResponseDeliveryRunnable(Request request, Response response, Runnable runnable) { mRequest = request; mResponse = response; mRunnable = runnable; } @SuppressWarnings(&quot;unchecked&quot;) @Override public void run() { // If this request has canceled, finish it and don&apos;t deliver. // 如果request已经被取消，那么就不需要派发结果。 if (mRequest.isCanceled()) { mRequest.finish(&quot;canceled-at-delivery&quot;); return; } // Deliver a normal response or error, depending. // 如果Response解析成功，那么将任务派发给Request。 if (mResponse.isSuccess()) { mRequest.deliverResponse(mResponse.result); } else { mRequest.deliverError(mResponse.error); } // If this is an intermediate response, add a marker, otherwise we&apos;re done // and the request can be finished. // 如果是中间结果，那么就添加标记，否则则调用finish命令，结束该任务。 if (mResponse.intermediate) { mRequest.addMarker(&quot;intermediate-response&quot;); } else { mRequest.finish(&quot;done&quot;); } // If we have been provided a post-delivery runnable, run it. // 此时任务已经派发完成，如果传入了其他的Runnable，那么就调用该Runnable。 if (mRunnable != null) { mRunnable.run(); } } } 代码比较简单，也不需要去画什么流程图了。 检查该mRequest是否已经被取消了，如果已经取消了，那么就调用Request的finish()方法，进而调用RequestQueue的finish()方法删除该request。 根据该mRequest的执行结果，即mResponse.isSuccess()结果来调用相应的mRequest.deliverResponse()或者mRequest.deliverError()方法。 检查该mRequest对应的执行结果mResponse.intermeidate来判断该任务是否还有后面可能存在的更新，因为这时候标示mResponse的结果是暂时的，需要更新的。如果不需要更新的话那么，那么调用mRequst.finish()方法来结束该Request。 以上工作完成之后，如果还设置了需要执行的mRunnable，则调用该Runnable，需要注意的是，此时并不会开辟新的线程去执行其中的代码，而是直接运行在主线程上，所以我们必须要注意该Runnable代码中的工作量，避免ANR。 综上，CacheDispatcher、NetworkDispatcher、ResponseDelivery就分析完了，后面可能会继续分析下Volley其他设计比较巧妙的边边角角的代码。","categories":[{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/categories/Volley/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/tags/Volley/"}]},{"title":"Volley源代码分析 - 1：任务的添加、删除和取消","slug":"android-volley-1-task","date":"2014-11-19T08:03:42.000Z","updated":"2018-10-03T16:12:52.605Z","comments":true,"path":"2014/11/19/android-volley-1-task/","link":"","permalink":"http://yoursite.com/2014/11/19/android-volley-1-task/","excerpt":"","text":"之前跟随Android Developer Guide学习了Volley的使用，为了更好的理解，现在从其代码的角度去学习Volley。我根据英文的注释和部分自己的理解，将代码中文注释，并托管到Github上，大家可以前去查看。 谷歌的IO大会上，开发者对Volley进行了详细的讲解，地址：https://developers.google.com/events/io/sessions/325304728 我们先来看一下Volley的架构图： 可以看出，Volley至少工作在3个线程当中，其中 蓝色部分为主线程：主要的工作是将请求按照优先级的顺序添加到cache的队列当中，当发出去的请求的得到相应的时候，在主线程将结果进行分发。 绿色部分为cache线程：如果cache hit，那么直接将cache中的数据进行解析，并传递给主线程，如果miss，那么则交给NetworkDispatcher进行处理。 黄色部分则为网络线程：与cache线程不同，cache只有一个线程在工作，而网络线程则可以有多个同时工作，进行网络请求，解析结果，写入cache，最终也是响应结果交给主线程。 我们以一段代码为例，跟踪代码的流程，对比上面的框架图，看看Volley到底是如何工作的。 RequestQueue mQueue = Volley.newRequestQueue(MainActivity.this); JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(&quot;http://m.weather.com.cn/data/101010100.html&quot;, null, new Response.Listener&lt;JSONObject&gt;() { @Override public void onResponse(JSONObject response) { // TODO Auto-generated method stub Log.i(TAG, response.toString()); }},new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { // TODO Auto-generated method stub Log.i(TAG, error.getMessage()); }}); mQueue.add(jsonObjectRequest); 首先，我们新建了一个RequestQueue的实例，当然在实际使用中，我们应该使用Application的Context作为Volley的Context。 然后，我们新建了一个JsonObjectRequest，即一个Json的请求，在其中的回调函数onResponse中添加我们收到结果要做的事情，当然我们知道这部分代码是运行在主线程当中。 最后，将JsonObjectRequest的实例添加到RequestQueue当中。 这就是Volley使用的全部的代码，总体看来，我们所能看到的所有的请求都是进入RequestQueue，然后就等待处理，得到onResponse的响应，因此，我们可以跟随代码，从mQueue.add（jsonObjectRequest）来分析。 任务的添加：mQueue.add（jsonObjectRequest）public &lt;T&gt; Request&lt;T&gt; add(Request&lt;T&gt; request) { // Tag the request as belonging to this queue and add it to the set of current requests. //将request与该任务队列相关联。 request.setRequestQueue(this); //将该请求放在任务队列的待做任务当中。 synchronized (mCurrentRequests) { mCurrentRequests.add(request); } // Process requests in the order they are added. // 设定序列号 request.setSequence(getSequenceNumber()); // 添加日志 request.addMarker(&quot;add-to-queue&quot;); // If the request is uncacheable, skip the cache queue and go straight to the network. // 如果该日志不需要Cache的话，那么跳过cache的队列，直接进行网络请求 if (!request.shouldCache()) { mNetworkQueue.add(request); return request; } // 如果程序运行到这里，说明需要缓存cache，那么进行的操作是，先检查当前的任务有没有在cache的运行当中， // 如果正在进行，或者说cache对应的cacheKey有Reqeust正在执行，那么则直接加入到cacheKey对应的队列当中即可。 // 如果需要cache，而且没有正在这行，则添加到等待队列和cache队列当中。 // Insert request into stage if there&apos;s already a request with the same cache key in flight. // 同步任务队列，根据该请求是否添加到RequestQueue的不同情况，分别处理 synchronized (mWaitingRequests) { //判断等待队列是否包含当前添加的任务 String cacheKey = request.getCacheKey(); if (mWaitingRequests.containsKey(cacheKey)) { // There is already a request in flight. Queue up. // 该cacheKey对应的任务之前添加过，并且还没有处理完成。则取出cacheKey对应的任务队列，将该任务添加进去。 Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey); if (stagedRequests == null) { stagedRequests = new LinkedList&lt;Request&lt;?&gt;&gt;(); } stagedRequests.add(request); mWaitingRequests.put(cacheKey, stagedRequests); if (VolleyLog.DEBUG) { VolleyLog.v(&quot;Request for cacheKey=%s is in flight, putting on hold.&quot;, cacheKey); } } else { // Insert &apos;null&apos; queue for this cacheKey, indicating there is now a request in // flight. // 与上面不同的是，当前的任务没有处理过，所以将任务添加到等待队列中，然后添加到cache的队列中。 mWaitingRequests.put(cacheKey, null); mCacheQueue.add(request); } return request; } } 上面的代码就是RequestQueue的add()方法。我们可以画一下它的流程图 从中，可以看出，RequestQueue中add(Request request)所做的工作为 绑定request到此RequestQueue.this 将request添加到mCuurentRequest的链表中 为request设置序列号，并打印Log 根据request是否需要cache，如果不需要cache，则直接将其放入mNetworkueue当中。 如果request需要cache，则检查该request对应的cacheKey(一般实际上使用URL)是否已经在mWaitingRequests列表中存在，如果已经存在，那么则更新cacheKey所对应的列表，如果不存在，则将其放进mCacheQueue中，再放入mNetworkQueue中等待执行。 add(Request request)方法执行完毕，返回。 此时我们也可以明白在RequestQueue中的几个集合类的作用： //该map的作用是用来缓存正在执行的需要Cache的Request，但暂时还没有看到如果Cache执行完毕，或者从Network执行完毕之后，该Map是否删除对应的Requestprivate final Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests = new HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();//所有的需要处理的Reqeust都会在这个集合当中private final Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = new HashSet&lt;Request&lt;?&gt;&gt;();//mCacheQueue保存的是需要从Cache中获取的Requestprivate final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue = new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();//mNetworkQueue保存的是需要网络操作的Requestprivate final PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue = new PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;(); 对应的RequestQueue的add方法，我们再来看一下对应的finish(Request&lt;?&gt; request)方法。 任务的结束：finish(Request&lt;?&gt; request) 可以看出，RequestQueue的finish(Request request)主要做了以下的事情： 将reqeust从当前的任务列表mCurrentRequests中删除 判断该request是否是需要cache的请求，如果不是，则直接退出即可。 如果该request需要cache，那么则删除所对应的cacheKey，然后将等待的请求全部加入到mCacheQueue即cache的任务队列当中。（有个小思考：既然要取消对应的request，那么为什么还要加入到mCacheQueue当中，不是Volley说保证任务取消了就不会被派发吗？其实这里的执行和派发并没有关系，而且在request对象当中，还有一个mCanceled的标志，当NetWork或者Cache的worker在操作对应的Request之前，都会检查该标志，如果已经取消，则立刻放弃该任务。这里面是我的理解错误，其实finish()调用的并不是说任务要取消，而是说任务已经完成了，所以对应的也很容易理解了，首先该任务完成了，就应该从RequestQueue中消失，如果不需要cache，那么直接退出就可以啦，如果需要cache，那么就可以删除该cahcheKey(URL)对应的请求列表，因为这个时候网络任务应该已经完成，所以将剩下的任务加入到mCacheQueue当中，让他们从cache中获取就可以。）。 还有一点需要注意的是，该方法是的访问限定符是默认的，即包访问权限，并且在Volley的源代码中，仅仅是Request.finish(String tag)调用了该方法。 接下来我们进一步分析一下Request中的finish(String tag)方法，同时我们注意到，对于Reqeust主要是一些标记变量和关于请求的内容，在逻辑上其他的相关的代码并不多。 /\\*\\* \\* Notifies the request queue that this request has finished (successfully or with error). \\* \\* 通知请求队列，该请求已经完成，或者成功，或者存在错误。 \\* \\* &lt;p&gt;Also dumps all events from this request&apos;s event log; for debugging.&lt;/p&gt; \\* &lt;p&gt;导出event log的所有的时间，用来调试。&lt;/p&gt; \\* \\* 该方法可能来自CacheDisptacher，ResponseDelivery，NetworkDispatcher的调用 */ void finish(final String tag) { // 通知RequestQueue停止该任务 if (mRequestQueue != null) { mRequestQueue.finish(this); } //如果需要记录日志，则记录之。 if (MarkerLog.ENABLED) { //获取线程Id final long threadId = Thread.currentThread().getId(); //判断当前的Looper的线程是否为主线程，也就是判断当前的代码是否在主线程上运行。 if (Looper.myLooper() != Looper.getMainLooper()) { // If we finish marking off of the main thread, we need to // actually do it on the main thread to ensure correct ordering. // 如果我们是在其他的线程(非main线程)上取消任务，那么我们需要在主线程上来完成以保证正确的顺序。 // 这边的顺序没有特别看到，为什么要这样设计。 //获取主线程的handler Handler mainThread = new Handler(Looper.getMainLooper()); //分发取消请求的任务。 mainThread.post(new Runnable() { @Override public void run() { mEventLog.add(tag, threadId); mEventLog.finish(this.toString()); } }); return; } //这个地方比较疑惑的是，既然在工作线程中，为什么还要再通知主线程进行处理。 mEventLog.add(tag, threadId); mEventLog.finish(this.toString()); } else { long requestTime = SystemClock.elapsedRealtime() - mRequestBirthTime; if (requestTime &gt;= SLOW\\_REQUEST\\_THRESHOLD_MS) { VolleyLog.d(&quot;%d ms: %s&quot;, requestTime, this.toString()); } } } 此处代码比较简单，Request的finish方法主要是调用了RequestQueue的finish()方法来标记完成任务。进而打印相关的Log信息，此处有一点不太明白的是，为什么一定要在主线程上打印Log？ 任务的取消：cancelAll(final Object tag) /\\*\\* \\* Cancels all requests in this queue for which the given filter applies. \\* @param filter The filtering function to use */ public void cancelAll(RequestFilter filter) { synchronized (mCurrentRequests) { for (Request&lt;?&gt; request : mCurrentRequests) { if (filter.apply(request)) { request.cancel(); } } } } /\\*\\* \\* Cancels all requests in this queue with the given tag. Tag must be non-null \\* and equality is by identity. */ public void cancelAll(final Object tag) { if (tag == null) { throw new IllegalArgumentException(&quot;Cannot cancelAll with a null tag&quot;); } cancelAll(new RequestFilter() { @Override public boolean apply(Request&lt;?&gt; request) { return request.getTag() == tag; } }); } 这里面才是真正的取消任务，其主要的工作如下： 同步mCurrentRequests，因为要遍历任务，所以要同步该集合。 依次判断Request是否符合tag或者RequestFilter的要去，如果符合，则取消相应的任务。 而Request的cancel方法则更加简单，如下： public void cancel() { mCanceled = true; } 现在看来，如果要取消某个Request，Volley不会主动的要求Network或者Cache的工作线程停止当前的正在执行的Request，而是在执行过程中，如果发现Reqeust的mCanceled标记被设置，那么就不再进行下一步操作。 围绕任务所写的任务的添加、删除和取消相关的代码就分析到这里，下一篇文章会从任务调度的角度来分析Network或者Cache怎么从相应的任务队列中取出Request并执行相应的操作的。","categories":[{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/categories/Volley/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/tags/Volley/"}]},{"title":"整理-常用正则表达式","slug":"regex-notes","date":"2014-11-18T01:40:45.000Z","updated":"2018-10-03T15:00:01.208Z","comments":true,"path":"2014/11/18/regex-notes/","link":"","permalink":"http://yoursite.com/2014/11/18/regex-notes/","excerpt":"","text":"匹配IP地址： ((25[0-5]|2[0-4]\\\\d|[1]?\\\\d\\\\d?)\\.){3}(25[0-5]|2[0-4]\\\\d|[1]?\\\\d\\\\d?) ip地址中的点号，要用双反斜杠转义，否则代表任意字符，无法匹配。","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"Java正则表达式再学习","slug":"java-regex-learn-again","date":"2014-11-17T04:36:38.000Z","updated":"2018-10-03T14:44:20.457Z","comments":true,"path":"2014/11/17/java-regex-learn-again/","link":"","permalink":"http://yoursite.com/2014/11/17/java-regex-learn-again/","excerpt":"","text":"为什么叫Java正则表达式再学习，在很久之前写过一篇《Java正则表达式》的博客，但好久没有用过了，所以再拿出来梳理一下。 Java的正则表达式的工具在java.util.regex包下，有一个接口MatchResult，两个类Matcher，Pattern，还有一个Exceptions：PatternSyntaxException。 首先来看Pattern类 API地址：https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#cg 签名： public final class Pattern extends Object implements Serializable 是一个正则表达式的编译的版本。一个string类型的正则表达式，如果想要使用的话，必须首先要编译成Pattern的实例。编译后的pattern可以用来匹配任意的字符串序列并得到结果Matcher。匹配过程中所有的结果都会保存在Matcher当中，所以很多的matchers都会共享同一个pattern。 一个典型的使用样例如下： Pattern p = Pattern.compile(“a*b”);Matcher m = p.matcher(“aaaaab”);boolean b = m.matches(); 同时在Pattern中有一个便于使用的方法matches()，当我们仅仅需要匹配一次的时候，这个就很好用。如下： boolean b = Pattern.matches(“a*b”, “aaaaab”); 其实实际上是和上面的3行代码一样的。 还有一点就是Pattern类是线程安全的，Matcher在这种使用情况下，不是线程安全的。 Summary of regular-expression constructsConstruct Matches Characters _x_ The character _x_ \\\\ The backslash character \\0_n_ The character with octal value 0_n_ (0 &lt;= _n_ &lt;= 7) \\0_nn_ The character with octal value 0_nn_ (0 &lt;= _n_ &lt;= 7) \\0_mnn_ The character with octal value 0_mnn_ (0 &lt;= _m_ &lt;= 3, 0 &lt;= _n_ &lt;= 7) \\x_hh_ The character with hexadecimal value 0x_hh_ \\u_hhhh_ The character with hexadecimal value 0x_hhhh_ \\x_{h…h}_ The character with hexadecimal value 0x_h…h_ (Character.MIN_CODE_POINT &lt;= 0x_h…h_ &lt;= Character.MAX_CODE_POINT) \\t The tab character (‘\\u0009’) \\n The newline (line feed) character (‘\\u000A’) \\r The carriage-return character (‘\\u000D’) \\f The form-feed character (‘\\u000C’) \\a The alert (bell) character (‘\\u0007’) \\e The escape character (‘\\u001B’) \\c_x_ The control character corresponding to _x_ Character classes [abc] a, b, or c (simple class) [^abc] Any character except a, b, or c (negation) [a-zA-Z] a through z or A through Z, inclusive (range) [a-d[m-p]] a through d, or m through p: [a-dm-p] (union) [a-z&amp;&amp;[def]] d, e, or f (intersection) [a-z&amp;&amp;[^bc]] a through z, except for b and c: [ad-z] (subtraction) [a-z&amp;&amp;[^m-p]] a through z, and not m through p: [a-lq-z](subtraction) Predefined character classes . Any character (may or may not match line terminators) \\d A digit: [0-9] \\D A non-digit: [^0-9] \\s A whitespace character: [ \\t\\n\\x0B\\f\\r] \\S A non-whitespace character: [^\\s] \\w A word character: [a-zA-Z_0-9] \\W A non-word character: [^\\w] POSIX character classes (US-ASCII only) \\p{Lower} A lower-case alphabetic character: [a-z] \\p{Upper} An upper-case alphabetic character:[A-Z] \\p{ASCII} All ASCII:[\\x00-\\x7F] \\p{Alpha} An alphabetic character:[\\p{Lower}\\p{Upper}] \\p{Digit} A decimal digit: [0-9] \\p{Alnum} An alphanumeric character:[\\p{Alpha}\\p{Digit}] \\p{Punct} Punctuation: One of !”#$%&amp;’()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~ \\p{Graph} A visible character: [\\p{Alnum}\\p{Punct}] \\p{Print} A printable character: [\\p{Graph}\\x20] \\p{Blank} A space or a tab: [ \\t] \\p{Cntrl} A control character: [\\x00-\\x1F\\x7F] \\p{XDigit} A hexadecimal digit: [0-9a-fA-F] \\p{Space} A whitespace character: [ \\t\\n\\x0B\\f\\r] java.lang.Character classes (simple java character type) \\p{javaLowerCase} Equivalent to java.lang.Character.isLowerCase() \\p{javaUpperCase} Equivalent to java.lang.Character.isUpperCase() \\p{javaWhitespace} Equivalent to java.lang.Character.isWhitespace() \\p{javaMirrored} Equivalent to java.lang.Character.isMirrored() Classes for Unicode scripts, blocks, categories and binary properties \\p{IsLatin} A Latin script character (script) \\p{InGreek} A character in the Greek block (block) \\p{Lu} An uppercase letter (category) \\p{IsAlphabetic} An alphabetic character (binary property) \\p{Sc} A currency symbol \\P{InGreek} Any character except one in the Greek block (negation) [\\p{L}&amp;&amp;[^\\p{Lu}]] Any letter except an uppercase letter (subtraction) Boundary matchers ^ The beginning of a line $ The end of a line \\b A word boundary \\B A non-word boundary \\A The beginning of the input \\G The end of the previous match \\Z The end of the input but for the final terminator, if any \\z The end of the input Greedy quantifiers（贪婪模式） _X_? _X_, once or not at all 0,1 _X_* _X_, zero or more times 0,1…n _X_+ _X_, one or more times 1,2…n _X_{_n_} _X_, exactly _n_ times n _X_{_n_,} _X_, at least _n_ times &gt;=n _X_{_n_,_m_} _X_, at least _n_ but not more than _m_ times n-&gt;m Reluctant quantifiers（勉强模式） _X_?? _X_, once or not at all _X_*? _X_, zero or more times _X_+? _X_, one or more times _X_{_n_}? _X_, exactly _n_ times _X_{_n_,}? _X_, at least _n_ times _X_{_n_,_m_}? _X_, at least _n_ but not more than _m_ times Possessive quantifiers（侵占模式） _X_?+ _X_, once or not at all _X_*+ _X_, zero or more times _X_++ _X_, one or more times _X_{_n_}+ _X_, exactly _n_ times _X_{_n_,}+ _X_, at least _n_ times _X_{_n_,_m_}+ _X_, at least _n_ but not more than _m_ times Logical operators _XY_ _X_ followed by _Y_ _X_|_Y_ Either _X_ or _Y_ (_X_) X, as a capturing group Back references _n_ Whatever the _n_th capturing group matched _k_&lt;name&gt; Whatever the named-capturing group “name” matched Quotation \\ Nothing, but quotes the following character \\Q Nothing, but quotes all characters until \\E \\E Nothing, but ends quoting started by \\Q Special constructs (named-capturing and non-capturing) (?&lt;name&gt;_X_) _X_, as a named-capturing group (?:_X_) _X_, as a non-capturing group (?idmsuxU-idmsuxU) Nothing, but turns match flags i d m s u x U on - off (?idmsux-idmsux:_X_) _X_, as a non-capturing group with the given flags i d m s u x on - off (?=_X_) _X_, via zero-width positive lookahead (?!_X_) _X_, via zero-width negative lookahead (?&lt;=_X_) _X_, via zero-width positive lookbehind (?&lt;!_X_) _X_, via zero-width negative lookbehind (?&gt;_X_) _X_, as an independent, non-capturing group Backslashes, escapes, and quoting反斜杠(‘\\‘)充当的角色是引入注释。上面表格中所示，\\为注释后面的部分，\\Q…\\E则是注释从\\Q到\\E的部分(quote)。 不要在任何字母之前使用反斜杠，因为这些字符是以后可能用来扩展正则表达式语言所需要的，而且不管后面的字符是不是正则表达式的一部分，转义的处理要优先字母的匹配。 在Java中，根据Java的规范，反斜扛要两个才行，比如\\b匹配的是空格，在Java中，要使用\\\\b才可以。比如”\\(hello\\)”匹配的是字符串(hello)，但实际上要使”\\(hello\\)“才能实现。 Character Classes 一些字符串会匹配在另外一些字符中间，也可能这些字符是由连接符或者交集符(&amp;&amp;)组合在一起。其运算顺序从高往低依次是： 1 Literal escape \\x 2 Grouping […] 3 Range a-z 4 Union [a-e][i-u] 5 Intersection [a-z&amp;&amp;[aeiou]] Line terminatorsA line terminator is a one- or two-character sequence that marks the end of a line of the input character sequence. The following are recognized as line terminators: A newline (line feed) character (‘\\n’), A carriage-return character followed immediately by a newline character (“\\r\\n”), A standalone carriage-return character (‘\\r’), A next-line character (‘\\u0085’), A line-separator character (‘\\u2028’), or A paragraph-separator character (‘\\u2029). If UNIX_LINES mode is activated, then the only line terminators recognized are newline characters. The regular expression . matches any character except a line terminator unless the DOTALL flag is specified. By default, the regular expressions ^ and $ ignore line terminators and only match at the beginning and the end, respectively, of the entire input sequence. If MULTILINE mode is activated then ^ matches at the beginning of input and after any line terminator except at the end of input. When in MULTILINE mode $ matches just before a line terminator or the end of the input sequence. Groups and capturingGroup numbergroups是从左到有根据左括号来判断。比如在表达式((A)(B(C)))中，有以下的分组 1 ((A)(B(C))) 2 (A) 3 (B(C)) 4 (C) 其中group(0)=整个表达式。groups的分组这样来分，是因为输入序列的每一个字片段的匹配都会被保存下来。这些片段可能在以后的表达式中会被用到。具体的分就是根据括号从左到右依次括号括起来的范围，比如上面的((A)(B(C)))，第0个括号，就是整个的分组，即全部的表达式；而第1个括号，此处其实也是全部内容都包括起来了；第2个括号则是仅仅包括了(A)；第3个括号则是包括了(B(C))；第4个括号则是(C)。有以下代码可以参考： String patternString = &quot;((A)(B(C)))&quot;; Pattern pattern = Pattern.compile(patternString); Matcher matcher = pattern.matcher(&quot;DABCDEF&quot;); if(matcher.find()) { System.out.println(&quot;Found:&quot; + matcher.pattern().pattern()); }else { System.out.println(&quot;Not Found:&quot; + matcher.pattern().pattern()); } //Group 0 = ABC //Group 1 = ABC //Group 2 = A //Group 3 = BC //Group 4 = C System.out.println(&quot;Group 0 :&quot; + matcher.group(0)); System.out.println(&quot;Group 1 :&quot; + matcher.group(1)); System.out.println(&quot;Group 2 :&quot; + matcher.group(2)); System.out.println(&quot;Group 3 :&quot; + matcher.group(3)); System.out.println(&quot;Group 4 :&quot; + matcher.group(4)); 输出结果为： Found:((A)(B(C)))Group 0 :ABCGroup 1 :ABCGroup 2 :AGroup 3 :BCGroup 4 :C Group name一个片段可以起一个名字“name”，称作named-capturing group。名字可以有大小写字母和数字构成A-Za-z0-9，注意，第一个字符必须为字母。 The captured input associated with a group is always the subsequence that the group most recently matched. If a group is evaluated a second time because of quantification then its previously-captured value, if any, will be retained if the second evaluation fails. Matching the string “aba” against the expression (a(b)?)+, for example, leaves group two set to “b”. All captured input is discarded at the beginning of each match. Groups beginning with (? are either pure, non-capturing groups that do not capture text and do not count towards the group total, or named-capturing group. 起名字的方式是在相应的group当中添加?来完成，比如(pattern)为(?pattern) String patternString = “((A)(B(?C)))”; 这里面的名字就是nameC Unicode supportThis class is in conformance with Level 1 of Unicode Technical Standard #18: Unicode Regular Expression, plus RL2.1 Canonical Equivalents. Unicode escape sequences such as \\u2014 in Java source code are processed as described in section 3.3 of The Java™ Language Specification. Such escape sequences are also implemented directly by the regular-expression parser so that Unicode escapes can be used in expressions that are read from files or from the keyboard. Thus the strings “\\u2014” and “\\\\u2014”, while not equal, compile into the same pattern, which matches the character with hexadecimal value 0x2014. A Unicode character can also be represented in a regular-expression by using its Hex notation(hexadecimal code point value) directly as described in construct \\x{…}, for example a supplementary character U+2011F can be specified as\\x{2011F}, instead of two consecutive Unicode escape sequences of the surrogate pair \\uD840\\uDD1F. Unicode scripts, blocks, categories and binary properties are written with the \\p and \\P constructs as in Perl. \\p{prop} matches if the input has the property prop, while \\P{prop} does not match if the input has that property. Scripts, blocks, categories and binary properties can be used both inside and outside of a character class. Scripts are specified either with the prefix Is, as in IsHiragana, or by using the script keyword (or its short form sc)as in script=Hiragana or sc=Hiragana. The script names supported by Pattern are the valid script names accepted and defined by UnicodeScript.forName). Blocks are specified with the prefix In, as in InMongolian, or by using the keyword block (or its short form blk) as in block=Mongolian or blk=Mongolian. The block names supported by Pattern are the valid block names accepted and defined by UnicodeBlock.forName). Categories may be specified with the optional prefix Is: Both \\p{L} and \\p{IsL} denote the category of Unicode letters. Same as scripts and blocks, categories can also be specified by using the keyword general_category (or its short form gc) as in general_category=Lu or gc=Lu. The supported categories are those of The Unicode Standard in the version specified by the Character class. The category names are those defined in the Standard, both normative and informative. Binary properties are specified with the prefix Is, as in IsAlphabetic. The supported binary properties by Pattern are Alphabetic Ideographic Letter Lowercase Uppercase Titlecase Punctuation Control White_Space Digit Hex_Digit Noncharacter_Code_Point Assigned Predefined Character classes and POSIX character classes are in conformance with the recommendation of Annex C: Compatibility Properties of Unicode Regular Expression , when UNICODE_CHARACTER_CLASS flag is specified. Classes Matches \\p{Lower} A lowercase character:\\p{IsLowercase} \\p{Upper} An uppercase character:\\p{IsUppercase} \\p{ASCII} All ASCII:[\\x00-\\x7F] \\p{Alpha} An alphabetic character:\\p{IsAlphabetic} \\p{Digit} A decimal digit character:p{IsDigit} \\p{Alnum} An alphanumeric character:[\\p{IsAlphabetic}\\p{IsDigit}] \\p{Punct} A punctuation character:p{IsPunctuation} \\p{Graph} A visible character: [^\\p{IsWhite_Space}\\p{gc=Cc}\\p{gc=Cs}\\p{gc=Cn}] \\p{Print} A printable character: [\\p{Graph}\\p{Blank}&amp;&amp;[^\\p{Cntrl}]] \\p{Blank} A space or a tab: [\\p{IsWhite_Space}&amp;&amp;[^\\p{gc=Zl}\\p{gc=Zp}\\x0a\\x0b\\x0c\\x0d\\x85]] \\p{Cntrl} A control character: \\p{gc=Cc} \\p{XDigit} A hexadecimal digit: [\\p{gc=Nd}\\p{IsHex_Digit}] \\p{Space} A whitespace character:\\p{IsWhite_Space} \\d A digit: \\p{IsDigit} \\D A non-digit: [^\\d] \\s A whitespace character: \\p{IsWhite_Space} \\S A non-whitespace character: [^\\s] \\w A word character: [\\p{Alpha}\\p{gc=Mn}\\p{gc=Me}\\p{gc=Mc}\\p{Digit}\\p{gc=Pc}] \\W A non-word character: [^\\w] Categories that behave like the java.lang.Character boolean is_methodname_ methods (except for the deprecated ones) are available through the same \\p{prop} syntax where the specified property has the name java_methodname_. Comparison to Perl 5The Pattern engine performs traditional NFA-based matching with ordered alternation as occurs in Perl 5. Perl constructs not supported by this class: Predefined character classes (Unicode character)\\h A horizontal whitespace\\H A non horizontal whitespace\\v A vertical whitespace \\V A non vertical whitespace \\R Any Unicode linebreak sequence \\u000D\\u000A|[\\u000A\\u000B\\u000C\\u000D\\u0085\\u2028\\u2029] \\X Match Unicode extended grapheme cluster The backreference constructs, \\g{_n_} for the _n_thcapturing group and \\g{name} for named-capturing group. The named character construct, \\N{name} for a Unicode character by its name. The conditional constructs (?(condition)_X_) and (?(condition)_X_|_Y_), The embedded code constructs (?{code}) and (??{code}), The embedded comment syntax (?#comment), and The preprocessing operations \\l \\u, \\L, and \\U. Constructs supported by this class but not by Perl: Character-class union and intersection as described above. Notable differences from Perl: In Perl, \\1 through \\9 are always interpreted as back references; a backslash-escaped number greater than 9 is treated as a back reference if at least that many subexpressions exist, otherwise it is interpreted, if possible, as an octal escape. In this class octal escapes must always begin with a zero. In this class, \\1 through \\9 are always interpreted as back references, and a larger number is accepted as a back reference if at least that many subexpressions exist at that point in the regular expression, otherwise the parser will drop digits until the number is smaller or equal to the existing number of groups or it is one digit. Perl uses the g flag to request a match that resumes where the last match left off. This functionality is provided implicitly by the Matcher class: Repeated invocations of the find) method will resume where the last match left off, unless the matcher is reset. In Perl, embedded flags at the top level of an expression affect the whole expression. In this class, embedded flags always take effect at the point at which they appear, whether they are at the top level or within a group; in the latter case, flags are restored at the end of the group just as in Perl. For a more precise description of the behavior of regular expression constructs, please see Mastering Regular Expressions, 3nd Edition, Jeffrey E. F. Friedl, O’Reilly and Associates, 2006. Java 6、PCRE、Perl支持使用正则记号&lt;\\Q&gt;和&lt;\\E&gt;。&lt;\\Q&gt;会抑制所有元字符的含义，直到出现&lt;\\E&gt;为止。如果漏掉了&lt;\\E&gt;，那么在&lt;\\Q&gt;之后直到正则表达式结束之前的所有字符都会被当作字符文本来对待。所以下面的的两个正则表达式为一个意思： Pattern p = Pattern.compile(“\\\\$\\(\\)\\*\\+\\.\\\\?\\\\[\\\\\\\\\\^\\{\\|“);Matcher m = p.matcher(“$()*+.?[\\\\^{|”);boolean b = m.matches(); Pattern p = Pattern.compile(“\\\\Q$()+.?[\\\\^{|\\\\E”);Matcher m = p.matcher(“$()+.?[\\\\^{|”); Pattern的方法比较简单，主要如下： Modifier and Type Method and Description static [Pattern](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html &quot;class in java.util.regex&quot;) **[compile](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#compile(java.lang.String))**([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) regex) Compiles the given regular expression into a pattern. static [Pattern](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html &quot;class in java.util.regex&quot;) **[compile](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#compile(java.lang.String,%20int))**([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) regex, int flags) Compiles the given regular expression into a pattern with the given flags. int **[flags](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#flags())**() Returns this pattern’s match flags. [Matcher](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html &quot;class in java.util.regex&quot;) **[matcher](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#matcher(java.lang.CharSequence))**([CharSequence](https://docs.oracle.com/javase/7/docs/api/java/lang/CharSequence.html &quot;interface in java.lang&quot;) input) Creates a matcher that will match the given input against this pattern. static boolean **[matches](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#matches(java.lang.String,%20java.lang.CharSequence))**([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) regex, [CharSequence](https://docs.oracle.com/javase/7/docs/api/java/lang/CharSequence.html &quot;interface in java.lang&quot;) input) Compiles the given regular expression and attempts to match the given input against it. [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) **[pattern](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#pattern())**() Returns the regular expression from which this pattern was compiled. 返回所编译的正则表达式 static [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) **[quote](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#quote(java.lang.String))**([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) s) Returns a literal pattern String for the specified String. 将s使用\\Q…\\E包围起来，使得其中的元字符不需转义 [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;)[] **[split](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#split(java.lang.CharSequence))**([CharSequence](https://docs.oracle.com/javase/7/docs/api/java/lang/CharSequence.html &quot;interface in java.lang&quot;) input) Splits the given input sequence around matches of this pattern. [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;)[] **[split](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#split(java.lang.CharSequence,%20int))**([CharSequence](https://docs.oracle.com/javase/7/docs/api/java/lang/CharSequence.html &quot;interface in java.lang&quot;) input, int limit) Splits the given input sequence around matches of this pattern. [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) **[toString](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#toString())**() Returns the string representation of this pattern. 其中要注意的是，Pattern有几个flags，可以设置匹配的原则： public String[] split(CharSequence input, int limit) 围绕此模式的匹配拆分给定输入序列。此方法返回的数组包含输入序列的子字符串，由匹配此模式的另一子序列或输入序列的结尾终止。数组中子字符串的顺序与其在输入中出现的顺序相同。如果此模式与输入的任何子序列都不匹配，那么得到的数组仅包含一个元素，即字符串形式的输入序列。limit 参数控制应用模式的次数，从而影响结果数组的长度。如果限制 _n_ 大于零，那么模式至多应用 _n_&gt; - 1 次，数组的长度不大于 _n_，并且数组的最后条目将包含除最后的匹配定界符之外的所有输入。如果 _n_ 非正，那么将应用模式的次数不受限制，并且数组可以为任意长度。如果 _n_ 为零，那么应用模式的次数不受限制，数组可以为任意长度，并且将丢弃尾部空字符串。 例如，输入 “boo:and:foo” 将产生以下结果及参数： _Regex _ _Limit _ _Result _ : 2 { “boo”, “and:foo” } : 5 { “boo”, “and”, “foo” } : -2 { “boo”, “and”, “foo” } o 5 { “b”, “”, “:and:f”, “”, “” } o -2 { “b”, “”, “:and:f”, “”, “” } o 0 { “b”, “”, “:and:f” } 字段摘要 static int **[CANON_EQ](http://www.cjsdn.net/Doc/JDK60/java/util/regex/Pattern.html#CANON_EQ)** 启用规范等价。 static int **[CASE_INSENSITIVE](http://www.cjsdn.net/Doc/JDK60/java/util/regex/Pattern.html#CASE_INSENSITIVE)** 启用不区分大小写的匹配。 static int **[COMMENTS](http://www.cjsdn.net/Doc/JDK60/java/util/regex/Pattern.html#COMMENTS)** 模式中允许空白和注释。 static int **[DOTALL](http://www.cjsdn.net/Doc/JDK60/java/util/regex/Pattern.html#DOTALL)** 启用 dotall 模式。 static int **[LITERAL](http://www.cjsdn.net/Doc/JDK60/java/util/regex/Pattern.html#LITERAL)** 启用模式的字面值解析。 static int **[MULTILINE](http://www.cjsdn.net/Doc/JDK60/java/util/regex/Pattern.html#MULTILINE)** 启用多行模式。 static int **[UNICODE_CASE](http://www.cjsdn.net/Doc/JDK60/java/util/regex/Pattern.html#UNICODE_CASE)** 启用 Unicode 感知的大小写折叠。 static int **[UNIX_LINES](http://www.cjsdn.net/Doc/JDK60/java/util/regex/Pattern.html#UNIX_LINES)** 启用 Unix 行模式。 主要关注下Matcher的方法，列表如下： Modifier and Type Method and Description [Matcher](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html &quot;class in java.util.regex&quot;) **[appendReplacement](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer,%20java.lang.String))**([StringBuffer](https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html &quot;class in java.lang&quot;) sb, [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) replacement) Implements a non-terminal append-and-replace step. 参见下面详细的说明 [StringBuffer](https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html &quot;class in java.lang&quot;) **[appendTail](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#appendTail(java.lang.StringBuffer))**([StringBuffer](https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuffer.html &quot;class in java.lang&quot;) sb) Implements a terminal append-and-replace step. 参见下面详细的说明 int **[end](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#end())**() Returns the offset after the last character matched. 返回搜索结果的匹配字符的最后一个字符的位置的后面那个位置，比如“DABCD”中匹配ABC，那么end()的返回值为3+1=4. int **[end](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#end(int))**(int group) Returns the offset after the last character of the subsequence captured by the given group during the previous match operation.可以参考start(int group)。 boolean **[find](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#find())**() Attempts to find the next subsequence of the input sequence that matches the pattern. boolean **[find](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#find(int))**(int start) Resets this matcher and then attempts to find the next subsequence of the input sequence that matches the pattern, starting at the specified index. [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) **[group](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#group())**() Returns the input subsequence matched by the previous match.返回上次匹配结果的group()，注意，如果上次匹配没有匹配到，会抛出异常Exception in thread “main” java.lang.IllegalStateException: No match found at java.util.regex.Matcher.group(Unknown Source) [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) **[group](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#group(int))**(int group) Returns the input subsequence captured by the given group during the previous match operation.类似上面，但可以指定group(int group)。注意，如果上次匹配没有匹配到，会抛出异常Exception in thread “main” java.lang.IllegalStateException: No match found at java.util.regex.Matcher.group(Unknown Source) [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) **[group](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#group(java.lang.String))**([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) name) Returns the input subsequence captured by the given named-capturing group during the previous match operation.比如”((A)(B(?C)))”，比如matcher.group(“nameC”)则会找到nameC则对应的字符串C。注意，如果上次匹配没有匹配到，会抛出异常Exception in thread “main” java.lang.IllegalStateException: No match found at java.util.regex.Matcher.group(Unknown Source) int **[groupCount](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#groupCount())**() Returns the number of capturing groups in this matcher’s pattern. 返回group的数量，即左括号的数量，比如”((A)(B(?C)))”，那么则对应的groupCount()则为4，注意其中的group=0的不参与计算group数量。任何大于等于0并且小于等于groupCount()的数值，都能保证对应的group(int key)找到一个位置。 boolean **[hasAnchoringBounds](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#hasAnchoringBounds())**() Queries the anchoring of region bounds for this matcher. boolean **[hasTransparentBounds](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#hasTransparentBounds())**() Queries the transparency of region bounds for this matcher. boolean **[hitEnd](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#hitEnd())**() Returns true if the end of input was hit by the search engine in the last match operation performed by this matcher. boolean **[lookingAt](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#lookingAt())**() Attempts to match the input sequence, starting at the beginning of the region, against the pattern.类似于matches()方法，该方法也会尝试从字符串的开始处开始匹配，但与matches()不同的是，该方法不会要求整个待匹配的字符串和patern完全匹配，而是找到匹配的结果即可。 boolean **[matches](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#matches())**() Attempts to match the entire region against the pattern. 尝试将整个字符串和pattern匹配。判断pattern是否能够匹配整个字符串。 [Pattern](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html &quot;class in java.util.regex&quot;) **[pattern](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#pattern())**() Returns the pattern that is interpreted by this matcher. 返回Matcher所使用的Pattern。 static [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) **[quoteReplacement](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#quoteReplacement(java.lang.String))**([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) s) Returns a literal replacement String for the specified String.返回指定 String 的字面值替换 String。 此方法将生成一个 String，它将用作 Matcher 类的 appendReplacement 方法中的字面值替换 s。所产生的 String 将与作为字面值序列的 s 中的字符序列匹配。斜线 (‘\\‘) 和美元符号 (‘$’) 将不具有任何特殊意义。 [Matcher](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html &quot;class in java.util.regex&quot;) **[region](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#region(int,%20int))**(int start, int end) Sets the limits of this matcher’s region. 设置matcher匹配的区域，此方法会调用Matcher的reset()方法，重置搜索结果标志。 int **[regionEnd](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#regionEnd())**() Reports the end index (exclusive) of this matcher’s region. int **[regionStart](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#regionStart())**() Reports the start index of this matcher’s region. [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) **[replaceAll](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#replaceAll(java.lang.String))**([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) replacement) Replaces every subsequence of the input sequence that matches the pattern with the given replacement string. [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) **[replaceFirst](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#replaceFirst(java.lang.String))**([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) replacement) Replaces the first subsequence of the input sequence that matches the pattern with the given replacement string. boolean **[requireEnd](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#requireEnd())**() Returns true if more input could change a positive match into a negative one. [Matcher](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html &quot;class in java.util.regex&quot;) **[reset](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#reset())**() Resets this matcher.重置Matcher所有的状态置为0，包括其中的append position为0. [Matcher](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html &quot;class in java.util.regex&quot;) **[reset](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#reset(java.lang.CharSequence))**([CharSequence](https://docs.oracle.com/javase/7/docs/api/java/lang/CharSequence.html &quot;interface in java.lang&quot;) input) Resets this matcher with a new input sequence. 类似于reset()，但是会重置搜索查找的字符串。 int **[start](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#start())**() Returns the start index of the previous match. 返回上一个搜索结果的起始位置。比如“DABCDEF”中搜索“ABC”那么返回的结果为1. int **[start](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#start(int))**(int group) Returns the start index of the subsequence captured by the given group during the previous match operation.返回上一个搜索结果的指定group的起始位置。_m._start(0)=_m._start()，比如“DABCDEF”中搜索“((A(B(C)))”的话，那么start(4)，group4对应的为C，那么其实就是搜索字符C对应的位置，也就是4. [MatchResult](https://docs.oracle.com/javase/7/docs/api/java/util/regex/MatchResult.html &quot;interface in java.util.regex&quot;) **[toMatchResult](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#toMatchResult())**() Returns the match state of this matcher as a MatchResult. 返回当前matcher的match state给一个MatchResult。 [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) **[toString](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#toString())**() Returns the string representation of this matcher. [Matcher](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html &quot;class in java.util.regex&quot;) **[useAnchoringBounds](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#useAnchoringBounds(boolean))**(boolean b) Sets the anchoring of region bounds for this matcher. [Matcher](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html &quot;class in java.util.regex&quot;) **[usePattern](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#usePattern(java.util.regex.Pattern))**([Pattern](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html &quot;class in java.util.regex&quot;) newPattern) Changes the Pattern that this Matcher uses to find matches with. 更改当前Matcher使用的Pattern。 [Matcher](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html &quot;class in java.util.regex&quot;) **[useTransparentBounds](https://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#useTransparentBounds(boolean))**(boolean b) Sets the transparency of region bounds for this matcher. appendReplacementpublic Matcher appendReplacement(StringBuffer sb, [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) replacement) Implements a non-terminal append-and-replace step.This method performs the following actions: It reads characters from the input sequence, starting at the append position, and appends them to the given string buffer. It stops after reading the last character preceding the previous match, that is, the character at index start()) - 1.该方法会从输入的序列中读取字符，从append position的标志位开始，默认为0，然后追加到StringBuffer当中。当读到上一次匹配之前的最后一个字符的时候，停止，此时指针的位置为start()-1. It appends the given replacement string to the string buffer.将replacement的字符串追加到StringBuffer当中。 It sets the append position of this matcher to the index of the last character matched, plus one, that is, to end()).设置append position为上次匹配到的字符串的end()位置。 The replacement string may contain references to subsequences captured during the previous match: Each occurrence of ${name} or $_g_ will be replaced by the result of evaluating the corresponding group(name)) orgroup(g)) respectively. For $_g_, the first number after the $ is always treated as part of the group reference. Subsequent numbers are incorporated into g if they would form a legal group reference. Only the numerals ‘0’ through ‘9’ are considered as potential components of the group reference. If the second group matched the string “foo”, for example, then passing the replacement string “$2bar” would cause “foobar” to be appended to the string buffer. A dollar sign ($) may be included as a literal in the replacement string by preceding it with a backslash (\\$). Note that backslashes () and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string. This method is intended to be used in a loop together with the appendTail) and find) methods. The following code, for example, writes one dog two dogs in the yard to the standard-output stream: Pattern p = Pattern.compile(“cat”); Matcher m = p.matcher(“one cat two cats in the yard”); StringBuffer sb = new StringBuffer(); while (m.find()) { m.appendReplacement(sb, &quot;dog&quot;); } m.appendTail(sb); System.out.println(sb.toString()); Parameters: sb - The target string buffer replacement - The replacement string Returns: This matcher Throws: [IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html &quot;class in java.lang&quot;) - If no match has yet been attempted, or if the previous match operation failed [IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html &quot;class in java.lang&quot;) - If the replacement string refers to a named-capturing group that does not exist in the pattern [IndexOutOfBoundsException](https://docs.oracle.com/javase/7/docs/api/java/lang/IndexOutOfBoundsException.html &quot;class in java.lang&quot;) - If the replacement string refers to a capturing group that does not exist in the pattern 对于正则表达式，还有一个知识点是关于匹配模式的，最常见的是贪婪模式与非贪婪模式，有一篇文章写的很好，连接参考： http://blog.csdn.net/lxcnn/article/details/4756030 参考文献： 《关于Java正则表达式的一些理解》 《JDK中文版》 附录：测试代码 public class GroupStudy { public static void main(String[] args) { String patternString = “((A)(B(?C)))”; Pattern pattern = Pattern.compile(patternString); Matcher matcher = pattern.matcher(“DABCDEFABCD”); System.out.println(“First try:”); if(matcher.find()) { System.out.println(“Found:” + matcher.pattern().pattern()); }else { System.out.println(“Not Found:” + matcher.pattern().pattern()); } System.out.println(&quot;Next try - matcher.find():&quot;); if(matcher.find()) { System.out.println(&quot;Found:&quot; + matcher.pattern().pattern()); }else { System.out.println(&quot;Not Found:&quot; + matcher.pattern().pattern()); } //此处应该确保上一次匹配是匹配到的，否则应该在if(matcher.find())之内运行。 //Group 0 = ABC //Group 1 = ABC //Group 2 = A //Group 3 = BC //Group 4 = C System.out.println(&quot;Group :&quot; + matcher.group()); System.out.println(&quot;Group 0 :&quot; + matcher.group(0)); System.out.println(&quot;Group 1 :&quot; + matcher.group(1)); System.out.println(&quot;Group 2 :&quot; + matcher.group(2)); System.out.println(&quot;Group 3 :&quot; + matcher.group(3)); System.out.println(&quot;Group 4 :&quot; + matcher.group(4)); //start() System.out.println(&quot;start() : &quot; + matcher.start()); //start(group) System.out.println(&quot;start(3) : &quot; + matcher.start(4)); //group() System.out.println(&quot;group() : &quot; + matcher.group()); //group(4) System.out.println(&quot;group(4) : &quot; + matcher.group(4)); //group(nameC) System.out.println(&quot;group(\\\\&quot;nameC\\\\&quot;) : &quot; + matcher.group(&quot;nameC&quot;)); //groupCount() System.out.println(&quot;groupCount() : &quot; + matcher.groupCount()); }} 运行结果： First try:Found:((A)(B(?C)))Next try - matcher.find():Found:((A)(B(?C)))Group :ABCGroup 0 :ABCGroup 1 :ABCGroup 2 :AGroup 3 :BCGroup 4 :Cstart() : 7start(3) : 9group() : ABCgroup(4) : Cgroup(“nameC”) : CgroupCount() : 4","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"ADT卡在Android SDK Content Loader 0的解决办法","slug":"how-to-solve-ADT-supend-at-SDK-Content-Loader","date":"2014-11-16T11:04:03.000Z","updated":"2018-10-03T16:12:52.518Z","comments":true,"path":"2014/11/16/how-to-solve-ADT-supend-at-SDK-Content-Loader/","link":"","permalink":"http://yoursite.com/2014/11/16/how-to-solve-ADT-supend-at-SDK-Content-Loader/","excerpt":"","text":"在实验室打开ADT发现整个ADT一直卡在Android SDK Content Loader: (0%)，无法使用，如图所示： 在网上搜索，发现如下操作可以解决，参考http://stackoverflow.com/questions/13489141/eclipse-hangs-at-the-android-sdk-content-loader： Make sure that eclipse is not active. If it is active kill eclipse from the processes tab of the task manager Open %USERPROFILE%/ on Windows or simply ~ on Linux/OS X (You can locate this folder from the Desktop) Go to .android folder (This may be a hidden folder) Delete the folder cache which is located inside .android folder Delete the file ddms.cfg which is located inside .android folder Start Eclipse 实际上就是删除.android文件夹里面的cache和ddms.cfg，重启eclipse即可。感谢找到方法的原作者。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"ADT","slug":"ADT","permalink":"http://yoursite.com/tags/ADT/"}]},{"title":"几种线程安全的单例模式","slug":"java-singleton-implementations","date":"2014-11-16T07:38:28.000Z","updated":"2018-10-03T14:55:44.586Z","comments":true,"path":"2014/11/16/java-singleton-implementations/","link":"","permalink":"http://yoursite.com/2014/11/16/java-singleton-implementations/","excerpt":"","text":"记下几种常见的单例模式，并且都是线程安全的。 第一种：静态工厂方法，类加载的时候就初始化。 123456789101112public class SingletonFirst &#123; private static SingletonFirst singletonFirst = new SingletonFirst(); public static SingletonFirst getInstance() &#123; return singletonFirst; &#125; private SingletonFirst() &#123; //private constructor &#125;&#125; 代码如上所示，非常简洁，当类被加载到JVM的时候，singletonFirst的单例就会被初始化，这样有就有一个问题，当我们只有声明但没有使用类的时候，也会占用空间。 第二种：DCL(double checked locking) (注：Picasso就是使用的这种单例的初始化方式，只是lock修改为SingletonSecond.class即可) 123456789101112131415161718192021public class SingletonSecond &#123; private static SingletonSecond singletonSecond = null; private static final byte\\[\\] lock = new byte\\[0\\]; private SingletonSecond() &#123; &#125; public static SingletonSecond getInstance() &#123; if(singletonSecond == null) &#123; synchronized (lock) &#123; if(singletonSecond == null) &#123; singletonSecond = new SingletonSecond(); &#125; &#125; &#125; return singletonSecond; &#125;&#125; 这种是一个线程安全的Lazy Initialization的方法。如果我们没有调用getInstance()的时候，是不会实例化这个类的，但当调用getInstance()的时候，会首先检查实例是否生成，如果没有，那么则进入同步代码块，在此之前，多个线程可能会同时尝试进入该代码块，即在判断if(singletonSecond==null)的时候，多个线程可能同时访问并且同时条件成立。因此，当进入同步代码块的时候，需要再次判断singletonSecond是否被初始化过，如果没有，则生成新的实例。最后返回唯一的实例。 第三种：方法二的简化版本 123456789101112131415public class SingletonThird &#123; private static SingletonThird singletonThird = null; private SingletonThird() &#123; &#125; public static synchronized SingletonThird getInstance() &#123; if(singletonThird==null) &#123; singletonThird = new SingletonThird(); &#125; return singletonThird; &#125;&#125; 该版本其实如第二种类似，但书写简单，在方法上做同步，效率基本一致，不会由太多的额外消耗。此代码参考与Volley的源代码。 第四种：使用静态内部类作为辅助的办法 1234567891011121314public class SingletonFourth &#123; private SingletonFourth() &#123; &#125; public static SingletonFourth getInstance() &#123; return SingletonInitializeClass.INSTANCE; &#125; private static class SingletonInitializeClass &#123; public static final SingletonFourth INSTANCE = new SingletonFourth(); &#125;&#125; 当调用getInstance()的时候，会访问子类，如果子类没有加载到JVM的时候，JVM会将其载入并实例化INSTANCE，此时是由JVM保证其线程安全。 以上几种在实际生产环境中都是可以直接使用的，基本上都差不多。 第五种：枚举类实现单例模式 12345678public enum SingletonFifth &#123; INSTANCE; public static SingletonFifth getInstance() &#123; return INSTANCE; &#125;&#125; 这种在序列化和反序列化的时候优点更加突出，并且可以避免用户使用反射等机制获取新的对象。 下面是测试的代码，主要的思路是同时开100个线程去尝试获取单例模式的实例，然后将其放入集合中，然后打印集合中的元素，如果集合中有且仅有1个元素的话，那么即可说明线程安全的，如果在集合中有多余1个的元素，那么说明多个线程中去尝试获取单例的实例的时候，却拿到了不同的实例，那么如果出现这种情况的话，就不是线程安全的。 相关代码如下： 1、Worker线程，用来在不同线程中获取单例模式的实例。 123456789101112131415161718192021222324252627import java.util.concurrent.CountDownLatch;public abstract class Worker implements Runnable &#123; private CountDownLatch mLatchStart; private CountDownLatch mLatchStop; public Worker(CountDownLatch start, CountDownLatch stop) &#123; this.mLatchStart = start; this.mLatchStop = stop; &#125; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; mLatchStart.await(); doWork(); mLatchStop.countDown(); &#125; catch (InterruptedException ex) &#123; ex.printStackTrace(); &#125; &#125; abstract void doWork(); &#125; 如上所示，使用CountDownLatch来实现多个线程中的同时启动，等待所有的线程的完成。 主测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package Singleton;import java.util.HashSet;import java.util.Set;import java.util.concurrent.CountDownLatch;public class Test &#123; public static void main(String\\[\\] args) &#123; CountDownLatch mLatchStart = new CountDownLatch(1); CountDownLatch mLatchStop = new CountDownLatch(100); mLatchStart = new CountDownLatch(1); mLatchStop = new CountDownLatch(100); final Set&lt;SingletonFirst&gt; setFirst = new HashSet&lt;&gt;(); for(int i=0; i&lt;100; i++) &#123; new Thread(new Worker(mLatchStart, mLatchStop) &#123; @Override void doWork() &#123; // TODO Auto-generated method stub setFirst.add(SingletonFirst.getInstance()); &#125; &#125;).start(); &#125; mLatchStart.countDown(); try &#123; mLatchStop.await(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(setFirst); mLatchStart = new CountDownLatch(1); mLatchStop = new CountDownLatch(100); final Set&lt;SingletonSecond&gt; setSecond = new HashSet&lt;&gt;(); for(int i=0; i&lt;100; i++) &#123; new Thread(new Worker(mLatchStart, mLatchStop) &#123; @Override void doWork() &#123; // TODO Auto-generated method stub setSecond.add(SingletonSecond.getInstance()); &#125; &#125;).start(); &#125; mLatchStart.countDown(); try &#123; mLatchStop.await(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(setSecond); mLatchStart = new CountDownLatch(1); mLatchStop = new CountDownLatch(100); final Set&lt;SingletonThird&gt; setThird = new HashSet&lt;&gt;(); for(int i=0; i&lt;100; i++) &#123; new Thread(new Worker(mLatchStart, mLatchStop) &#123; @Override void doWork() &#123; // TODO Auto-generated method stub setThird.add(SingletonThird.getInstance()); &#125; &#125;).start(); &#125; mLatchStart.countDown(); try &#123; mLatchStop.await(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(setThird); mLatchStart = new CountDownLatch(1); mLatchStop = new CountDownLatch(100); final Set&lt;SingletonFourth&gt; setFourth = new HashSet&lt;&gt;(); for(int i=0; i&lt;100; i++) &#123; new Thread(new Worker(mLatchStart, mLatchStop) &#123; @Override void doWork() &#123; // TODO Auto-generated method stub setFourth.add(SingletonFourth.getInstance()); &#125; &#125;).start(); &#125; mLatchStart.countDown(); try &#123; mLatchStop.await(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println(setFourth); &#125;&#125; 运行结果： 1234SingletonFirst:\\[Singleton.SingletonFirst@3801167a\\]SingletonSecond:\\[Singleton.SingletonSecond@72116e25\\]SingletonThird:\\[Singleton.SingletonThird@44bb11cd\\]SingletonFourth:\\[Singleton.SingletonFourth@59ca08c\\] 如上所示，所有的集合中都有唯一的元素，是线程安全的。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"Java编程","slug":"Java/Java编程","permalink":"http://yoursite.com/categories/Java/Java编程/"},{"name":"面试","slug":"Java/Java编程/面试","permalink":"http://yoursite.com/categories/Java/Java编程/面试/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Singleton","slug":"Singleton","permalink":"http://yoursite.com/tags/Singleton/"},{"name":"单例模式","slug":"单例模式","permalink":"http://yoursite.com/tags/单例模式/"},{"name":"线程安全","slug":"线程安全","permalink":"http://yoursite.com/tags/线程安全/"}]},{"title":"Gson User Guide (译)","slug":"gson-user-guide","date":"2014-11-15T05:34:32.000Z","updated":"2018-10-03T15:08:44.395Z","comments":true,"path":"2014/11/15/gson-user-guide/","link":"","permalink":"http://yoursite.com/2014/11/15/gson-user-guide/","excerpt":"","text":"原文：https://sites.google.com/site/gson/gson-user-guide OverviewGson是一个Java库，用来将Java Objects转换为JSON的表示方法，也可以用来将一个JSON字符串转换为相等的JAVA object。GSON是一个开源代码，其代码主页为http://code.google.com/p/google-gson. 即使已经存在的对象，我们没有源代码的情况下，Gson依然可以工作。 Goals for Gson 提供一种比较易用的，像toString()或者构造函数那样的机制来转换Java和JSON。 允许已经存在的不能修改的对象也可以和JSON之间相互转换。 允许自定义对象的表示方法。 允许任意复杂的对象。 生成紧凑简洁而又可读性好的JSON输出。 Gson Performance and Scalability 这里有一些桌面环境(dual opteron, 8GB RAM, 64-bit Ubuntu)获得的指标。我们可以使用类PerformanceTest来重新测试。 Strings: Deserialized strings of over 25MB without any problems (seedisabled_testStringDeserializationPerformancemethod in PerformanceTest) Large collections: Serialized a collection of 1.4 million objects (seedisabled_testLargeCollectionSerializationmethod in PerformanceTest) Deserialized a collection of 87,000 objects (seedisabled_testLargeCollectionDeserializationin PerformanceTest) Gson 1.4 raised the deserialization limit for byte arrays and collection to over 11MB from 80KB. Note: Delete the disabled_ prefix to run these tests. We use this prefix to prevent running these tests every time we run junit tests. Gson UsersGson was originally created for use inside Google where it is currently used in a number of projects. It is now used by a number of public projects and companies. See details here. Using Gson最直接的使用方法就是直接通过new Gson()来构建一个Gson。同时也可以通过GsonBuilder来创建一个Gson实例，其中包括各种设置比如version control或者其他的。 Gson实例在调用Json的操作的时候，并不会保存任何的状态，所以我们可以自由的复用同一个对象来实现多种Json的序列化和反序列化操作。 Primitives Examples(Serialization)Gson gson = new Gson();gson.toJson(1); ==&gt; prints 1gson.toJson(“abcd”); ==&gt; prints “abcd”gson.toJson(new Long(10)); ==&gt; prints 10int[] values = { 1 };gson.toJson(values); ==&gt; prints [1] (Deserialization)int one = gson.fromJson(“1”, int.class);Integer one = gson.fromJson(“1”, Integer.class);Long one = gson.fromJson(“1”, Long.class);Boolean false = gson.fromJson(“false”, Boolean.class);String str = gson.fromJson(“\\“abc\\“”, String.class);String anotherStr = gson.fromJson(“[\\“abc\\“]“, String.class); Object Examplesclass BagOfPrimitives { private int value1 = 1; private String value2 = “abc”; private transient int value3 = 3; BagOfPrimitives() { // no-args constructor }} (Serialization)BagOfPrimitives obj = new BagOfPrimitives();Gson gson = new Gson();String json = gson.toJson(obj);==> json is {“value1”:1,”value2”:”abc”} 注意：我们不能序列化那种环形引用的对象，因为那样会导致无限的递归。 (Deserialization)BagOfPrimitives obj2 = gson.fromJson(json, BagOfPrimitives.class);==> obj2 is just like obj Finer Points with Objects 使用private修饰的成员变量是允许的并且是推荐的。 并不需要任何的注释来标示一个成员变量是否需要序列化或者反序列化。默认情况下，当前类中的所有的成员变量，包括从父类中继承过来的成员变量都会默认包含。 如果一个成员变量使用transient来修饰的话，那么这个类默认情况下是被JSON序列化和反序列化所忽略的。 Gson的实现能够正确的处理nulls 当序列化的时候，null值会被跳过，而不会输出。 当反序列化的时候，JSON结果中确实的entry会被置为null 如果一个成员变量是synthetic，那么在JSON的序列化或者反序列化中是忽略的。（这个是神马？） 成员变量对应着外部类中的内部类，匿名类或者局部类的时候，是被忽略的，并不会包含在序列化和反序列化之中。 Nested Classes (including Inner Classes)Gson可以很轻松的序列化静态嵌套类。 Gson也可以反序列化静态嵌套类。然而，Gson不能自动反序列化纯粹的内部类，这是因为即使他们的无参构造函数也需要一个引用指向外部类，而这个外部类在这个时候不是可用的。我们可以通过将这个内部类设置为静态的或者通过自己提供一个InstanceCreator来解决。这里有一个例子。 public class A { public String a; class B { public String b; public B() { // No args constructor for B } }} 可以注意到，上面的类B不能在默认情况下被Gson实例化的。 Gson不能反序列化{“b”:”abc”}为一个B的实例，是因为B是一个内部类。如果这是一个静态类，那么是可以的，另外一种解决办法是为B写一个自定义的instance creator。 public class InstanceCreatorForB implements InstanceCreator&lt;A.B&gt; { private final A a; public InstanceCreatorForB(A a) { this.a = a; } public A.B createInstance(Type type) { return a.new B(); }} 上面的方法是可行的，但是不推荐使用。 Array ExamplesGson gson = new Gson();int[] ints = {1, 2, 3, 4, 5};String[] strings = {“abc”, “def”, “ghi”}; (Serialization)gson.toJson(ints); ==&gt; prints [1,2,3,4,5]gson.toJson(strings); ==&gt; prints [“abc”, “def”, “ghi”] (Deserialization)int[] ints2 = gson.fromJson(“[1,2,3,4,5]“, int[].class);==> ints2 will be same as ints Gson也支持多维数组，数组元素可以是任何复杂类型。 Collections ExamplesGson gson = new Gson();Collection ints = Lists.immutableList(1,2,3,4,5); (Serialization)String json = gson.toJson(ints); ==&gt; json is [1,2,3,4,5] (Deserialization)Type collectionType = new TypeToken&lt;Collection&gt;(){}.getType();Collection ints2 = gson.fromJson(json, collectionType);ints2 is same as ints 需要注意到是，我们定义了Collection的类型，这在Java中是必须的。 Collections Limitations 可以序列化任意复杂的对象，但是无法从其中反序列化。 这是因为用户没有办法来识别序列化的结果中的类型type 当反序列化的时候，集合必须是一个指定的泛型类型。 Serializing and Deserializing Generic Types 我们调用toJson(obj)方法的时候，Gson会调用obj.getClass()来获取要序列化的成员变量的信息。同样的我们也可以通过传递MyClass.class对象给fromJson(json, MyClass.class)方法。如果该对象是一个非泛型类的话，这样做是很有效的。但是，如果这个类是一个泛型类，那么使用这种方法泛型的信息会丢失（这是因为Java泛型的擦除机制）。这里有一个例子来说明这一点。 class Foo { T value;}Gson gson = new Gson();Foo foo = new Foo();gson.toJson(foo); // May not serialize foo.value correctly gson.fromJson(json, foo.getClass()); // Fails to deserialize foo.value as Bar 上面的代码中，无法将数值解析为Bar的类型，这是因为Gson调用list.getClass()来获取类的信息，但是这个方法却返回一个类的信息Foo.class。这意味着Gson没有办法知道Foo的类型信息，而不仅仅是Foo。 为了解决这个问题，我们可以通过为泛型指定准确的参数化类型来实现，通过使用TypeToker类型来实现。 Type fooType = new TypeToken&lt;Foo&gt;() {}.getType();gson.toJson(foo, fooType); gson.fromJson(json, fooType); 这种机制来获取fooType，实际上是定义了一个匿名的嵌套类，其中包括getType()方法，可以返回完整的参数化类型。 Serializing and Deserializing Collection with Objects of Arbitrary Types有个时候，我们的JSON数组可能包含复杂的混合类型。比如： [‘hello’,5,{name:’GREETINGS’,source:’guest’}] 这等同于包含以下的集合： Collection collection = new ArrayList();collection.add(“hello”);collection.add(5);collection.add(new Event(“GREETINGS”, “guest”)); 此处Event的定义为： class Event { private String name; private String source; private Event(String name, String source) { this.name = name; this.source = source; }} 我们可以在不需要做任何修改的情况下实现，只要使用toJson(collection)方法即可。 但是当我们需要反序列化的时候，fromJson(json, Collection.class)却无法工作，因为Gson没有办法知道如何map输入的类型。Gson要求我们为fromJson提供一个制定参数的集合类型。所有我们有三种办法： Option 1：使用Gson的parser API(低等级的straming parser流解析器，或者DOM parser JsonParser)来解析数组元素，然后使用Gson.fromJson()来解析每一个数组元素。这是一种推荐方法，这里有一个例子。 /* * Copyright (C) 2011 Google Inc. * * Licensed under the Apache License, Version 2.0 (the “License”); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an “AS IS” BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson.extras.examples.rawcollections; import java.util.ArrayList;import java.util.Collection; import com.google.gson.Gson;import com.google.gson.JsonArray;import com.google.gson.JsonParser; public class RawCollectionsExample { static class Event { private String name; private String source; private Event(String name, String source) { this.name = name; this.source = source; } @Override public String toString() { return String.format(“(name=%s, source=%s)”, name, source); } } @SuppressWarnings({ “unchecked”, “rawtypes” }) public static void main(String[] args) { Gson gson = new Gson(); Collection collection = new ArrayList(); collection.add(“hello”); collection.add(5); collection.add(new Event(“GREETINGS”, “guest”)); String json = gson.toJson(collection); System.out.println(“Using Gson.toJson() on a raw collection: “ + json); JsonParser parser = new JsonParser(); JsonArray array = parser.parse(json).getAsJsonArray(); String message = gson.fromJson(array.get(0), String.class); int number = gson.fromJson(array.get(1), int.class); Event event = gson.fromJson(array.get(2), Event.class); System.out.printf(“Using Gson.fromJson() to get: %s, %d, %s”, message, number, event); }} Option 2：对Collection.class来注册一个类型的adapter。adapter能够注意到数组中的每一个元素并且能够完美的将其映射到合适的对象上去。这种的办法的缺点在于这种方法会弄糟其他的集合的类型的反序列化。 Option 3：为MyCollectionMemberType注册一个类型的adapter，并且使用fromJson的Collection签名方法。这种方法仅仅在数组作为顶层元素，并且我们能够将保存数组的类型更改为Collection的时候有效。 Built-in Serializers and DeserializersGson has built-in serializers and deserializers for commonly used classes whose default representation may be inappropriate. Here is a list of such classes: java.net.URL to match it with strings like “http://code.google.com/p/google-gson/&quot;. java.net.URI to match it with strings like “/p/google-gson/“. You can also find source-code for some commonly used classes such as JodaTime at this page. DateTime private static class DateTimeTypeConverter implements JsonSerializer, JsonDeserializer { @Override public JsonElement serialize(DateTime src, Type srcType, JsonSerializationContext context) { return new JsonPrimitive(src.toString()); } @Override public DateTime deserialize(JsonElement json, Type type, JsonDeserializationContext context) throws JsonParseException { try { return new DateTime(json.getAsString()); } catch (IllegalArgumentException e) { // May be it came in formatted as a java.util.Date, so try that Date date = context.deserialize(json, Date.class); return new DateTime(date); } } }Instant private static class InstantTypeConverter implements JsonSerializer, JsonDeserializer { @Override public JsonElement serialize(Instant src, Type srcType, JsonSerializationContext context) { return new JsonPrimitive(src.getMillis()); } @Override public Instant deserialize(JsonElement json, Type type, JsonDeserializationContext context) throws JsonParseException { return new Instant(json.getAsLong()); } } Custom Serialization and Deserialization 有些时候，默认的实现并不是我们所需要的效果。这在处理一些库的类的时候经常碰到，比如（DateTime等等）。Gson允许我们注册我们自己的序列化和反序列化的实现。主要分为两部分来完成： Json Serialiers：需要为类定义一个自定义的序列化实现。 Json Deserializers：需要为类定义一个自定义的反序列化实现。 Instance Creators：如果存在无餐构造函数的话，这个并不是必须的。 GsonBuilder gson = new GsonBuilder();gson.registerTypeAdapter(MyType2.class, new MyTypeAdapter());gson.registerTypeAdapter(MyType.class, new MySerializer());gson.registerTypeAdapter(MyType.class, new MyDeserializer());gson.registerTypeAdapter(MyType.class, new MyInstanceCreator()); registerTypeAdapter会检查adapter实现的一个或者多个接口并且为其全部注册。 Writing a Serializerprivate class DateTimeSerializer implements JsonSerializer { public JsonElement serialize(DateTime src, Type typeOfSrc, JsonSerializationContext context) { return new JsonPrimitive(src.toString()); }} 当调用toJson()的时候对调用。 Writing a Deserializerprivate class DateTimeDeserializer implements JsonDeserializer { public DateTime deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { return new DateTime(json.getAsJsonPrimitive().getAsString()); }} Finer points with Serializers and Deserializers 可以优化的点 经常情况下，我们会想要注册一个单独的handler来处理raw类型所对应的所有的泛型 比如，假设我们有一个“Id”的类来标示Id和用来传输。 Id类来说，对于所有的泛型都有着同样的序列化。 需要写出id的数值。 反序列化也很相近，但并不完全一样。 需要调用new Id(Class, String)来返回一个Id的实例。 Gson支持注册一个单独的handler来处理这些情况。我们也可以为每一个泛型都注册一个handler(比如Id需要单独的处理)。Type参数对于toJson和fromJson中便于我们对于同样的raw类型来处理所有的泛型类型。 Writing an Instance Creator 当反序列化一个对象的时候，Gson需要创建一个该类的默认的实例。一个书写良好的用于序列化和反序列化的类应该含有无参构造函数 并不需要关心这个无参构造函数是public还是private的 通常境况下，Instance Creator在我们处理没有无参构造函数的时候是必须的。 Instance Creator Example private class MoneyInstanceCreator implements InstanceCreator { public Money createInstance(Type type) { return new Money(“1000000”, CurrencyCode.USD); }} Type也可以对应一个泛型类型 Type在处理一个特别类型的泛型的时候调用构造函数的时候是很有用的。 比如，如果一个Id类包含一个类如何生成Id InstanceCreator for a Parameterized Type 有些时候，我们要实例化的类是一个参数化类型。通常情况下，这并不是问题，因为其本质是一个raw类型。比如： class MyList extends ArrayList {} class MyListInstanceCreator implements InstanceCreator&lt;MyList&lt;?&gt;&gt; { @SuppressWarnings(“unchecked”) public MyList&lt;?&gt; createInstance(Type type) { // No need to use a parameterized list since the actual instance will have the raw type anyway. return new MyList(); }} 然后，有些时候，你需要根据具体的参数类型来创建实例，在这个时候，我们可以将类型参数递给createInstance方法，这里有个例子。 public class Id { private final Class classOfId; private final long value; public Id(Class classOfId, long value) { this.classOfId = classOfId; this.value = value; }} class IdInstanceCreator implements InstanceCreator&lt;Id&lt;?&gt;&gt; { public Id&lt;?&gt; createInstance(Type type) { Type[] typeParameters = ((ParameterizedType)type).getActualTypeArguments(); Type idType = typeParameters[0]; // Id has only one parameterized type T return Id.get((Class)idType, 0L); }} 在上面的例子中，如果不传递Id的类的具体的类型，那么Id的实例就无法实例化。我们通过传递参数化类型type来实现。type对象实际上是Java的参数化类型Id，就是说实际的实例应该是Id。由于Id类仅仅有一个类型参数T，我们使用getActualTypeArgumentI()的下标0来找到类型Foo.class。 Compact Vs. Pretty Printing for JSON Output FormatThe default JSON output that is provide by Gson is a compact JSON format. This means that there will not be any whitespace in the output JSON structure. Therefore, there will be no whitespace between field names and its value, object fields, and objects within arrays in the JSON output. As well, “null” fields will be ignored in the output (NOTE: null values will still be included in collections/arrays of objects). See theNull Object Support section for information on configure Gson to output all null values. If you like to use the Pretty Print feature, you must configure your Gsoninstance using the GsonBuilder. The JsonFormatter is not exposed through our public API, so the client is unable to configure the default print settings/margins for the JSON output. For now, we only provide a default JsonPrintFormatter that has default line length of 80 character, 2 character indentation, and 4 character right margin. The following is an example shows how to configure a Gson instance to use the default JsonPrintFormatter instead of theJsonCompactFormatter: Gson gson = new GsonBuilder().setPrettyPrinting().create(); String jsonOutput = gson.toJson(someObject); Null Object SupportGson中对于null的默认行为是忽略它。这允许了更加优化的输出格式。然后，当使用Gson反序列化，将字符串转换为Java实例的时候，客户端要小心处理这些null数值。 然后，我么可以通过设置Gson的实例来输出null： Gson gson = new GsonBuilder().serializeNulls().create(); 注意：当使用Gson来序列化nulls的时候，Gson会添加JsonNull元素到JsonElement结构体中。因此，这个类可以用来自定义序列化/反序列化。 public class Foo { private final String s; private final int i; public Foo() { this(null, 5); } public Foo(String s, int i) { this.s = s; this.i = i; }} Gson gson = new GsonBuilder().serializeNulls().create();Foo foo = new Foo();String json = gson.toJson(foo);System.out.println(json); json = gson.toJson(null);System.out.println(json); ======== OUTPUT ========{“s”:null,”i”:5}null Versioning Support 同一对象的不同版本可以使用注释@Since来维护。这个注释可以用在Classes，Fileds，以及在以后的版本中会实现Methods。为了利用这个特点，我们必须配置Gson的实例来忽略任何的filed/object，其版本大于某些版本号的时候。如果Gson没有设置任何版本号，那么Gson就会序列化/反序列化任何的fileds和classes，而忽略了版本号。 public class VersionedClass { @Since(1.1) private final String newerField; @Since(1.0) private final String newField; private final String field; public VersionedClass() { this.newerField = “newer”; this.newField = “new”; this.field = “old”; }} VersionedClass versionedObject = new VersionedClass();Gson gson = new GsonBuilder().setVersion(1.0).create();String jsonOutput = gson.toJson(someObject);System.out.println(jsonOutput);System.out.println(); gson = new Gson();jsonOutput = gson.toJson(someObject);System.out.println(jsonOutput); ======== OUTPUT ========{“newField”:”new”,”field”:”old”} {“newerField”:”newer”,”newField”:”new”,”field”:”old”} Excluding Fields From Serialization and Deserialization Gson支持大量的机制来排除top-level classes，fileds，filed types。以下是几种可选的机制可以用来排除filed和class。如果以下的机制不能满足，那么可以通过自定义序列化和反序列化来实现。 Java Modifier Exclusion 默认情况下，如果我们标示一个filed为transient，那么就会在序列化和反序列化的时候被排除。同样的，如果一个filed被标注为static，那么默认情况下也是被排除的。如果我们想要包含那些transient的成员变量，那么可以使用以下的办法。 import java.lang.reflect.Modifier; Gson gson = new GsonBuilder() .excludeFieldsWithModifiers(Modifier.STATIC) .create(); 注意：我们可以添加任意多的修饰符到“excludeFiledsWithModifiers”方法，比如： Gson gson = new GsonBuilder() .excludeFieldsWithModifiers(Modifier.STATIC, Modifier.TRANSIENT, Modifier.VOLATILE) .create(); Gson’s @Expose该特性可以用来标记特定的fileds来排除。为了使用这个注释，我们需要如下创建Gson GsonBuilder().excludeFieldsWithoutExposeAnnotation().create() User Defined Exclusion Strategies以上的方法如果不能满足的话，可以通过写我们自己的策略并添加到Gson中，更多的可以参考ExclusionStrategy JavaDoc。 以下的例子展示了如何排除那些使用了”@Foo”注释的fileds。 @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.FIELD}) public @interface Foo { // Field tag only annotation } public class SampleObjectForTest { @Foo private final int annotatedField; private final String stringField; private final long longField; private final Class&lt;?&gt; clazzField; public SampleObjectForTest() { annotatedField = 5; stringField = &quot;someDefaultValue&quot;; longField = 1234; } } public class MyExclusionStrategy implements ExclusionStrategy { private final Class&lt;?&gt; typeToSkip; private MyExclusionStrategy(Class&lt;?&gt; typeToSkip) { this.typeToSkip = typeToSkip; } public boolean shouldSkipClass(Class&lt;?&gt; clazz) { return (clazz == typeToSkip); } public boolean shouldSkipField(FieldAttributes f) { return f.getAnnotation(Foo.class) != null; } } public static void main(String[] args) { Gson gson = new GsonBuilder() .setExclusionStrategies(new MyExclusionStrategy(String.class)) .serializeNulls() .create(); SampleObjectForTest src = new SampleObjectForTest(); String json = gson.toJson(src); System.out.println(json); } ======== OUTPUT ========{“longField”:1234} JSON Field Naming SupportGson支持一些预先定义的filed naming policies来实现标准的Java变量名称向Json变量名称的转化，具体的可以参考FieldNamingPolicy。 也支持一个基于注释的策略允许客户端来为每一个变量定义名称。注意，基于注释的策略可能会导致“Runtime”异常。 以下是一个例子。 private class SomeObject { @SerializedName(“custom_naming”) private final String someField; private final String someOtherField; public SomeObject(String a, String b) { this.someField = a; this.someOtherField = b; }} SomeObject someObject = new SomeObject(“first”, “second”);Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();String jsonRepresentation = gson.toJson(someObject);System.out.println(jsonRepresentation); ======== OUTPUT ========{“custom_naming”:”first”,”SomeOtherField”:”second”} If you have a need for custom naming policy (see this discussion), you can use the @SerializedName annotation. Sharing State Across Custom Serializers and Deserializers有些情况下，我们可以通过自定义Serializers和Deserializers来共享一些状态 (see this discussion).我们可以通过以下3中办法来实现： 将状态保存在static的变量里面。 将serializer/deserializer声明为parent type的内部类，然后使用parent type的实例来保存状态。 使用Java的ThreadLocal 其中1,2不是线程安全的，3是线程安全。 StreamingIn addition Gson’s object model and data binding, you can use Gson to read from and write to a stream. You can also combine streaming and object model access to get the best of both approaches. Issues in Designing GsonSee the Gson design document for a discussion of issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion. Future Enhancements to GsonFor the latest list of proposed enhancements or if you’d like to suggest new ones, see the Issues section under the project website. Using Gson with Maven2To use Gson with Maven2/3, you can use the Gson version available in Maven Central by adding the following dependency: com.google.code.gson gson 2.3 compile That is it, now your maven project is Gson enabled.","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Gson","slug":"Gson","permalink":"http://yoursite.com/tags/Gson/"},{"name":"Json","slug":"Json","permalink":"http://yoursite.com/tags/Json/"}]},{"title":"Volley Lesson 4 -Implementing a Custom Request（译）","slug":"android-volley-usage-4-implementing-request","date":"2014-11-14T06:28:28.000Z","updated":"2018-10-03T15:16:30.625Z","comments":true,"path":"2014/11/14/android-volley-usage-4-implementing-request/","link":"","permalink":"http://yoursite.com/2014/11/14/android-volley-usage-4-implementing-request/","excerpt":"","text":"原文：http://developer.android.com/training/volley/request-custom.html 这边文章主要描述如何实现一个自己的request类型，实现Volley默认并不支持的功能。 Write a Custom Request大多数时候，大多请求都不需要我们自己去实现一个Request，因为toolbox中默认有很多实现，比如string，image，JSON。 但如果我们要自己实现的时候，我们需要做的工作如下： 继承Reqest类，为我们期待的请求结果的类型。比如我们想要response为String类型，那么我们就继承Request即可。更多的可以参考Volley的toolbox类StringRequest和ImageReqeust来学习。 实现抽象方法：parseNetworkResponse()和deliverResponse()，下面会更加细致的描述。 parseNetworkResponse用来解析response。以下为一个例子。 @Overrideprotected Response parseNetworkResponse( NetworkResponse response) { try { String json = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); return Response.success(gson.fromJson(json, clazz), HttpHeaderParser.parseCacheHeaders(response)); } // handle errors…} 需要注意以下的事情： parseNetworkResponse()有一个参数NetworkResponse，其中包括了response的返回值比如byte[]，HTTP状态码，response headers 方法的实现必须要返回一个Response，其中包含了我们期待的返回值的类型，cache的元信息，或者失败的信息。 如果我们的协议没有标准的cache定义，那么我们可以自己构建Cache.Entry，对于大多数请求以下的代码可以实现： return Response.success(myDecodedObject, HttpHeaderParser.parseCacheHeaders(response)); Volley会从worker thread调用parseNetworkResponse()。这就保证了其中耗时的操作不会阻塞UI线程。 deliverResponseVolley会在parseNetworkResponse()完成的时候在main线程中调用callback接口，比如： protected void deliverResponse(T response) { listener.onResponse(response); Example: GsonRequestGson是一个方便的类通过反射实现Java类和JSON的转换。You can define Java objects that have the same names as their corresponding JSON keys, pass Gson the class object, and Gson will fill in the fields for you. Here’s a complete implementation of a Volley request that uses Gson for parsing: public class GsonRequest extends Request { private final Gson gson = new Gson(); private final Class clazz; private final Map&lt;String, String&gt; headers; private final Listener listener; /\\*\\* \\* Make a GET request and return a parsed object from JSON. \\* \\* @param url URL of the request to make \\* @param clazz Relevant class object, for Gson&apos;s reflection \\* @param headers Map of request headers */ public GsonRequest(String url, Class&lt;T&gt; clazz, Map&lt;String, String&gt; headers, Listener&lt;T&gt; listener, ErrorListener errorListener) { super(Method.GET, url, errorListener); this.clazz = clazz; this.headers = headers; this.listener = listener; } @Override public Map&lt;String, String&gt; getHeaders() throws AuthFailureError { return headers != null ? headers : super.getHeaders(); } @Override protected void deliverResponse(T response) { listener.onResponse(response); } @Override protected Response&lt;T&gt; parseNetworkResponse(NetworkResponse response) { try { String json = new String( response.data, HttpHeaderParser.parseCharset(response.headers)); return Response.success( gson.fromJson(json, clazz), HttpHeaderParser.parseCacheHeaders(response)); } catch (UnsupportedEncodingException e) { return Response.error(new ParseError(e)); } catch (JsonSyntaxException e) { return Response.error(new ParseError(e)); } } }","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/tags/Volley/"}]},{"title":"Volley Lesson 3 -Making a Standard Request（译）","slug":"android-volley-usage-3-standard-request","date":"2014-11-14T06:03:39.000Z","updated":"2018-10-03T15:15:45.045Z","comments":true,"path":"2014/11/14/android-volley-usage-3-standard-request/","link":"","permalink":"http://yoursite.com/2014/11/14/android-volley-usage-3-standard-request/","excerpt":"","text":"原文链接：http://developer.android.com/training/volley/request.html 该文将介绍如何使用常见的Volley支持的请求类型： StringRequest：定义一个URL，在response中接收原始的字符串。可以参见之前的Setting Up a Request Queue。 ImageRequest：定义一个URL，在response中接收图片 JsonObjectReqeust/JsonArrayRequest：都是JsonReqeust的子类，接收Json object或者array。 如果我们的数据类型也是上面的几种之一的话，那么我们是不需要自己实现自己的request的。如果需要接收自己特定格式的Request的话，可以参考下一节课程。 Request an ImageVolley提供了以下的类用来请求图像。这些类一次提供了不同级别上的图片处理能力。 ImageReqeust：一个请求可以用来访问特定URL的图片并且返回一个解码之后的bitmap。并且也提供了方便的特性比如缩放至一个特定的尺寸。其中最大的好处在于Volley的线程调度保证了耗时的图片操作，比如decoding，比如resizing都发生在worker线程中。 ImageLoader：是一个工具类用来加载和缓存URL的图片。ImageLoader在处理大量的ImageRequest的时候很有用，比如：当我们需要在ListView中放置很多的缩放图片，ImageLoader提供了in-memory级别的cache来作为Volley的前置cache，这样就避免了很多闪烁的现象。这样也使得我们在cache命中，而且又使用disk I/O的时候可以不阻塞main线程。ImageLoader也会负责一些聚合操作，如果没有ImageLoader，那么大部分的response handler都要负责在view上设置图片等操作。ImageLoader的聚合操作使得同时我们可以同时派发得以实现。 NetworkImageView：基于ImageLoader构建，当图片需要从网络URL中获取的时候，用来代替ImageView。如果使用NewworkImageView的话，当NetworkImageView从视图上剥离的时候回自动的取消等待的请求。 Use ImageRequest一个使用ImageRequest的例子，其中使用单利调用RequestQueue。 ImageView mImageView;String url = “http://i.imgur.com/7spzG.png&quot;;mImageView = (ImageView) findViewById(R.id.myImage);… // Retrieves an image specified by the URL, displays it in the UI.ImageRequest request = new ImageRequest(url, new Response.Listener() { @Override public void onResponse(Bitmap bitmap) { mImageView.setImageBitmap(bitmap); } }, 0, 0, null, new Response.ErrorListener() { public void onErrorResponse(VolleyError error) { mImageView.setImageResource(R.drawable.image_load_error); } });// Access the RequestQueue through your singleton class.MySingleton.getInstance(this).addToRequestQueue(request); Use ImageLoader and NetworkImageView在需要展示大量的图片的时候，使用ImageLoader或者NetworkImageView会拥有更高的效率，比如ListView。如果使用NetworkImageView，可以像如下使用： &lt;com.android.volley.toolbox.NetworkImageView android:id=”@+id/networkImageView” android:layout_width=”150dp” android:layout_height=”170dp” android:layout_centerHorizontal=”true” /&gt; 我们可以直接使用ImageLoader来展示图片，如下： ImageLoader mImageLoader;ImageView mImageView;// The URL for the image that is being loaded.private static final String IMAGE_URL = “http://developer.android.com/images/training/system-ui.png&quot;;…mImageView = (ImageView) findViewById(R.id.regularImageView); // Get the ImageLoader through your singleton class.mImageLoader = MySingleton.getInstance(this).getImageLoader();mImageLoader.get(IMAGE_URL, ImageLoader.getImageListener(mImageView, R.drawable.def_image, R.drawable.err_image)); 使用NetworkImageView的话如下： ImageLoader mImageLoader;NetworkImageView mNetworkImageView;private static final String IMAGE_URL = “http://developer.android.com/images/training/system-ui.png&quot;;… // Get the NetworkImageView that will display the image.mNetworkImageView = (NetworkImageView) findViewById(R.id.networkImageView); // Get the ImageLoader through your singleton class.mImageLoader = MySingleton.getInstance(this).getImageLoader(); // Set the URL of the image that should be loaded into this view, and// specify the ImageLoader that will be used to make the request.mNetworkImageView.setImageUrl(IMAGE_URL, mImageLoader); 要注意的是，以上的ImageLoader都是使用了单例模式，使得在整个APP的生命周期中都可以直接使用。特别注意的是，这种设计模式在使用ImageLoader的时候特别需要重视，因为ImageLoader使用了内存缓存，可以减少图片旋转时候闪烁现象的发生。否则如果我们是在activity中设置ImageLoader，那么当用户每次旋转屏幕的时候，ImageLoader都会重构，就会导致严重的闪烁现象。 Example LRU cacheVolley工具类提供了一个标准的cache实现：DiskBasedCache。该类会在磁盘中特定文件夹中直接缓存文件。但是实用ImageLoader的时候，我们需要自己创建一个内存cache，该cache要实现ImageLaoder.ImageCache接口。 以下是一个in-memory的LruBitmapCache例子，该类继承了LruCache类，并且实现ImageLoader.ImageCache接口。 import android.graphics.Bitmap;import android.support.v4.util.LruCache;import android.util.DisplayMetrics;import com.android.volley.toolbox.ImageLoader.ImageCache; public class LruBitmapCache extends LruCache&lt;String, Bitmap&gt; implements ImageCache { public LruBitmapCache(int maxSize) { super(maxSize); } public LruBitmapCache(Context ctx) { this(getCacheSize(ctx)); } @Override protected int sizeOf(String key, Bitmap value) { return value.getRowBytes() * value.getHeight(); } @Override public Bitmap getBitmap(String url) { return get(url); } @Override public void putBitmap(String url, Bitmap bitmap) { put(url, bitmap); } // Returns a cache size equal to approximately three screens worth of images. public static int getCacheSize(Context ctx) { final DisplayMetrics displayMetrics = ctx.getResources(). getDisplayMetrics(); final int screenWidth = displayMetrics.widthPixels; final int screenHeight = displayMetrics.heightPixels; // 4 bytes per pixel final int screenBytes = screenWidth * screenHeight * 4; return screenBytes * 3; } } 如下使用： RequestQueue mRequestQueue; // assume this exists.ImageLoader mImageLoader = new ImageLoader(mRequestQueue, new LruBitmapCache( LruBitmapCache.getCacheSize())); Request JSONVolley提供了以下两个类实现JSON请求： JsonArrayRequest：请求数组 JsonObjectRequest：获取JSON Object。可以有一个JSONObject通过request body传递请求。 两个类都是基于JsonRequest实现，以下是个例子。 TextView mTxtDisplay;ImageView mImageView;mTxtDisplay = (TextView) findViewById(R.id.txtDisplay);String url = “http://my-json-feed&quot;; JsonObjectRequest jsObjRequest = new JsonObjectRequest (Request.Method.GET, url, null, new Response.Listener() { @Override public void onResponse(JSONObject response) { mTxtDisplay.setText(&quot;Response: &quot; + response.toString()); } }, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { // TODO Auto-generated method stub } }); // Access the RequestQueue through your singleton class.MySingleton.getInstance(this).addToRequestQueue(jsObjRequest);","categories":[{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/categories/Volley/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/tags/Volley/"}]},{"title":"Volley Lesson 2 -Setting Up a RequestQueue（译）","slug":"android-volley-usage-2-setting-up-requestqueue","date":"2014-11-13T12:45:49.000Z","updated":"2018-10-03T15:16:06.261Z","comments":true,"path":"2014/11/13/android-volley-usage-2-setting-up-requestqueue/","link":"","permalink":"http://yoursite.com/2014/11/13/android-volley-usage-2-setting-up-requestqueue/","excerpt":"","text":"原文：http://developer.android.com/training/volley/requestqueue.html 在上一篇文章Sending a Simple Request中展示了如何的简单的构造一个RequestQueue来充分利用Volley的默认的特性。这篇文章将展示如果通过一步一步来创建一个符合自己的需求的RequestQueue。 本片文章这描述了一种推荐的常用用法，创建一个单例的RequestQueue，使得其在我们的app的整个证明周期中都得到使用。 Set Up a Network and Cache一个RequestQueue需要两部分来完成他的工作：一个网络network来传输其请求，一个cache来处理缓存。在Volley的toolbox中这些都有标准的实现：DiskBasedCache提供了一个cache，每一个response对应一个文件，并且在内存中拥有索引。BasicNetwork提供了标准的传输途径，可以选择androidHttpClient或者HttpURLConnection。 BasicNetwork是Volley的默认的network实现。一个BasicNetwork必须初始化一个Http客户端以便用来连接网络，典型的就是AndroidHttpClient或者HttpURLConnection。 AndroidHttpClient在API版本低于9（Gingerbread）的时候使用，在API低于9的版本中，HttpURLConnection是没有这个类的。更多的讨论可以参见 Android’s HTTP Clients. HttpURLConnection可以用来API&gt;=9的版本之中。 为了使得network能够在所有的Android平台上都能够使用，我们可以通过检测Android版本来调用不同的intent client。比如： HttpStack stack;…// If the device is running a version &gt;= Gingerbread…if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.GINGERBREAD) { // …use HttpURLConnection for stack.} else { // …use AndroidHttpClient for stack.}Network network = new BasicNetwork(stack); 下面这个片段则展示了上面描述的内容在建立RequestQueu的时候，何时能够被调用： RequestQueue mRequestQueue; // Instantiate the cacheCache cache = new DiskBasedCache(getCacheDir(), 1024 * 1024); // 1MB cap // Set up the network to use HttpURLConnection as the HTTP client.Network network = new BasicNetwork(new HurlStack()); // Instantiate the RequestQueue with the cache and network.mRequestQueue = new RequestQueue(cache, network); // Start the queuemRequestQueue.start(); String url =”http://www.myurl.com&quot;; // Formulate the request and handle the response.StringRequest stringRequest = new StringRequest(Request.Method.GET, url, new Response.Listener() { @Override public void onResponse(String response) { // Do something with the response }}, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { // Handle error }}); // Add the request to the RequestQueue.mRequestQueue.add(stringRequest);… 如果我们仅仅需要执行一次请求，那么我们可以在需要的时候建立RequestQueue，然后在stop()中取消掉queue。但更推荐的，更常用的一种办法是使用单例的设计模式来创建一个在整个app的生命周期中都能够使用的RequestQueue。 Use a Singleton Pattern如果我们的程序一直需要使用网络的时候，那么更加有效，或者说效率更高的方式是通过单例模式来构建一个在整个app的生命中都能够访问到的RequestQueue。这有很多的途径，其中推荐的是使用单实例类，在该类中创建RequestQueue和其他的Volley需要的功能。另外一种实现的方式是可以继承Application类，然后再Application的onCreate()方法中创建RequestQueue，但这种方法并不推荐，因为单例模式可以以一种更加优雅的方法实现这个效果。 一个关键的概念就是，RequestQueue必须使用Application的context上下文来实例化，而不是Activity的context来实例化。这样可以保障ReqeueQueue可以在整个app的生命周期中都得到保持，而不会在每次activity重建的时候重新创建，比如设备旋转的时候。 这里有一个单例的类，提供了RequestQueue和ImageLoader的功能： private static MySingleton mInstance; private RequestQueue mRequestQueue; private ImageLoader mImageLoader; private static Context mCtx; private MySingleton(Context context) { mCtx = context; mRequestQueue = getRequestQueue(); mImageLoader = new ImageLoader(mRequestQueue, new ImageLoader.ImageCache() { private final LruCache&lt;String, Bitmap&gt; cache = new LruCache&lt;String, Bitmap&gt;(20); @Override public Bitmap getBitmap(String url) { return cache.get(url); } @Override public void putBitmap(String url, Bitmap bitmap) { cache.put(url, bitmap); } }); } public static synchronized MySingleton getInstance(Context context) { if (mInstance == null) { mInstance = new MySingleton(context); } return mInstance; } public RequestQueue getRequestQueue() { if (mRequestQueue == null) { // getApplicationContext() is key, it keeps you from leaking the // Activity or BroadcastReceiver if someone passes one in. mRequestQueue = Volley.newRequestQueue(mCtx.getApplicationContext()); } return mRequestQueue; } public &lt;T&gt; void addToRequestQueue(Request&lt;T&gt; req) { getRequestQueue().add(req); } public ImageLoader getImageLoader() { return mImageLoader; } } 下面是使用的办法 / Get a RequestQueueRequestQueue queue = MySingleton.getInstance(this.getApplicationContext()). getRequestQueue();… // Add a request (in this example, called stringRequest) to your RequestQueue.MySingleton.getInstance(this).addToRequestQueue(stringRequest);","categories":[{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/categories/Volley/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/tags/Volley/"}]},{"title":"Volley Lesson 1 -Sending a Simple Request（译）","slug":"android-volley-usage-1-sending-request","date":"2014-11-13T12:24:25.000Z","updated":"2018-10-03T15:15:24.658Z","comments":true,"path":"2014/11/13/android-volley-usage-1-sending-request/","link":"","permalink":"http://yoursite.com/2014/11/13/android-volley-usage-1-sending-request/","excerpt":"","text":"Volley的学习初步打算如下几个步骤： 学习Android Training中的关于Volley使用的几篇文章 分析Volley的源代码 原文：http://developer.android.com/training/volley/simple.html 本篇是Training中的第一篇文章，《Sending a Simple Request》，主要分为以下几个部分： 添加INTERNET权限 使用newRequestQueue 发送请求Request 取消请求Request 在高层来看，我们使用volley，只要创建一个RequestQueue，然后传递给这个RequestQueue一个Request即可。RequestQueue会管理工作线程(Worker threads)来运行网络操作，对缓存的读取或者写入操作，对请求做出相应。Request来解析raw的相应，并且Volley会仔细处理并发送给main线程。 添加Intent权限将”android.permission.INTERNET”添加到Android manifest中即可。 使用newRequestQueueVolley提供了一个简单的默认的创建RequestQueue的方法，使用Volley.newRequestQueue即可。代码： final TextView mTextView = (TextView) findViewById(R.id.text);… // Instantiate the RequestQueue.RequestQueue queue = Volley.newRequestQueue(this);String url =”http://www.google.com&quot;; // Request a string response from the provided URL.StringRequest stringRequest = new StringRequest(Request.Method.GET, url, new Response.Listener() { @Override public void onResponse(String response) { // Display the first 500 characters of the response string. mTextView.setText(“Response is: “+ response.substring(0,500)); }}, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { mTextView.setText(“That didn’t work!”); }});// Add the request to the RequestQueue.queue.add(stringRequest); Volley总是在main线程中来分发解析过的相应。这样的话可以更好的根据接收到的数据来操作相关的UI控件，同时，对于库中的很多操作来说，这是严格要求的，比如取消requests。 可以通过查看下一篇文章《Setting Up a RequestQueue》来自己创建一个RequestQueue。 发送请求要发送请求，只要构建一个请求，并且在RequestQueue中使用add方法加入进去即可。一旦加入到Queue之中，那么它的请求就会放进流水线中，得到处理，得到的元数据raw response会得到解析，并且分发出来。 当我们调用add()方法的时候，Volley一直有一个cache处理线程，和一个网络分发线程的pool线程池在运行。当我们将一个request加入到queue中，这个请求就会并cache线程处理并分类：如果这个请求在cache中命中，那么缓存的响应就会在cache线程中得到解析并且在main线程中派发。如果这个请求无法在cache中命中，那么会发到network队列中。从中找到第一个可以获得的网络线程，拿到这个请求，执行相关的HTTP传输操作，然后在work线程中解析相应的结果，然后写入缓存cache，再然后将解析后的响应传递给main线程来派发。 注意到，其中费时的操作，比如阻塞的I/O操作，或者解析/解码操作都是在worker线程中进行的。我们可以在任何一个线程中想RequestQueue中添加请求，但结果都会在main线程中得到派发。 下图1展示了一个请求的生命周期。 取消请求为了取消请求，调用cancel方法即可。一旦被取消，Volley可以保证我们的请求处理(response handler)不会再被调用。这意味着，我们只要再activity的onStop()方法中调用cancel()方法，那么我们就不需要在response的handlers中检车getActivity()==null,不管onSaveInstanceState()是否被调用，或者是其他的被保持的引用。 为了更好的利用这个优势，我们需要跟踪所有的正在执行的请求，以便于在某个特定的时刻取消它们。有一个简单的途径来实现这个目的，我们可以为每一个request绑定一个tag object，然后就可以利用这个tag来搜索所有需要取消的请求。比如说，我们可以为请求绑定请求发起的Activity，然后在onStop中调用requestQueue.cancelAll(this)即可。同样的，对于ViewPager来说，我们可以将请求绑定在特定的tabs上，这样就可以取消相应tab上的请求。 以下是一个例子： 1、定义tag，并且绑定到request中 public static final String TAG = “MyTag”;StringRequest stringRequest; // Assume this exists.RequestQueue mRequestQueue; // Assume this exists. // Set the tag on the request.stringRequest.setTag(TAG); // Add the request to the RequestQueue.mRequestQueue.add(stringRequest); 2、在onStop方法中，取消所有的tag绑定的请 @Overrideprotected void onStop () { super.onStop(); if (mRequestQueue != null) { mRequestQueue.cancelAll(TAG); }} 在取消请求的时候一定要仔细处理。如果我们需要依赖response的handler来处理的话，我们必须特别仔细考虑，因为只要我们取消了请求，那么这个handler永远不会被调用的。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"Volley","slug":"Android/Volley","permalink":"http://yoursite.com/categories/Android/Volley/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Volley","slug":"Volley","permalink":"http://yoursite.com/tags/Volley/"}]},{"title":"Android面试题目总结","slug":"android-interview-summary","date":"2014-11-06T14:25:51.000Z","updated":"2018-10-03T16:12:52.519Z","comments":true,"path":"2014/11/06/android-interview-summary/","link":"","permalink":"http://yoursite.com/2014/11/06/android-interview-summary/","excerpt":"","text":"已经进入11月份，公司也都跑了一遍，把之前整理的资料也慢慢的整理出来。这一篇是Android可能出的面试的题目的总结，以后慢慢补充。 1、 Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念 DVM指Dalvik的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念。 2、 android中的动画有哪几类，它们的特点和区别是什么？ 两种，一种是Tween动画、还有一种是Frame动画。Tween动画，这种实现方式可以使视图组件移动、放大、缩小以及产生透明度的变化；另一种Frame动画，传统的动画方法，通过顺序的播放排列好的图片来实现，类似电影。 3、handler机制的原理 （作用：在新启动的线程中发送消息，在主线程中获取、处理消息。） andriod提供了 Handler 和 Looper 来满足线程间的通信。Handler 先进先出原则。Looper类用来管理特定线程内对象之间的消息交换(Message Exchange) Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的Message Queue(消息队列)。 Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里；或者接收Looper从Message Queue取出)所送来的消息。 Message Queue(消息队列):用来存放线程放入的消息。 线程：UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。 4、说说mvc模式的原理，它在android中的运用 MVC(Model_view_contraller)” 模型_视图_控制器”。 MVC应用程序总是由这三个部分组成。Event(事件)导致Controller改变Model或View，或者同时改变两者。只要 Controller改变了Models的数据或者属性，所有依赖的View都会自动更新。类似的，只要Controller改变了View，View会从潜在的Model中获取数据来刷新自己。 5、View的刷新: 在需要刷新的地方,使用handle.sendmessage发送信息,然后在handle的getmessage里面执行invaliate或者postinvaliate. 6、GC内存泄露出现情况: 数据库的cursor没有关闭 如果说cursor可以立刻关闭，那么可以使用try{} finally{cursor.close()}来关闭cursor。 如果cursor在其他的地方还要继续使用的话，那么则最好在Activity或者Fragment的生命周期的onDestroy()方法中记得关闭 构造adapter时,没有使用缓存contentview，衍生listview的优化问题 减少创建view的对象,在getView方法中充分复用contentview 为了减少内部类的开销，将ViewHolder设置为静态内部类。 Bitmap对象不使用时采用recycle()释放内存 这个是内存泄漏很容易导致OOM的问题。 activity中的对象的生命周期大于activity 比如一个Activity中保存有一个静态对象，该对象指向一个内部类，那么就会有额外的开销。（静态对象会尝试维护原先的引用，但此时内部类必须保持一个对外部类的引用，因此会额外保存一份外部类的指针，因此外部类不会被GC掉） 方法是将该内部类声明为静态类。 在Activity生命周期之外，不要用户指向Acitivty内部的对象。 7、Intent的设计的优势或者设计初衷 Android使用了统一的封装来实现了一致的编程模型。 实现系统各个部分的一个松耦合，比如可以指定启动具有某种特征的程序而不需要硬编码 8、Android为什么要设计4大组件，他们之间的联系，不设计行不行（主要是为了实现MVC模式，然而java中最难的模式也是这个，很少有产品能将这个模式做得很好 Activity Service Broadcast ContentProvider 9、Service的生命周期 Service常用生命周期回调方法如下： onCreate() 该方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次startService()或bindService()方法，服务也只被创建一次。 onDestroy()该方法在服务被终止时调用。startService和bindService对应的onStartCommand()和onBind() onUnbind()会多次被调。 Context.startService()启动Service有关的生命周期方法 onStartCommand() 只有采用Context.startService()方法启动服务时才会回调该方法。该方法在服务开始运行时被调用。 多次调用startService()方法尽管不会多次创建服务，但onStartCommand() 方法会被多次调用。 Context.bindService()启动Service有关的生命周期方法 onBind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务绑定时被调用，当调用者与服务已经绑定，多次调用Context.bindService()方法并不会导致该方法被多次调用。 onUnbind()只有采用Context.bindService()方法启动服务时才会回调该方法。该方法在调用者与服务解除绑定时被调用。 服务的分类： 本地服务(Local)：直接依附于主线程，可以使用bindService()中的Binder进行通信，也可以通过启动服务的时候将任务通过Intent提交给Service，完成时通过广播进行结果反馈。 远程服务(Remote)：在AndroidManifest.xml中配置对应的Service为android:remote=”true”，此时需要通过广播或者AIDL进行通信。其生命周期与主线程独立 优先级： 前台服务：会同时在状态栏加以提示，优先级高，但服务终止的时候状态栏也会消失。 后台服务：默认状态，优先级低于前台服务，GC时相比更容易被干掉。 几个注意事项： bindService()+unbindService()应该成对出现 startService()+stopService()应该成对出现 屏幕旋转时，Activity是重新创建的，因此Service也是同样，重新创建之后，与之前的Service连接就会断开。 bindService方法： 在Service中实现Binder内部类，当Service创建之后初始化该Binder内部类，并保存实例，然后覆写onBind(Intent inent)方法，在其中返回该Binder实例。 在Activity中创建ServiceConnection()内部类或者匿名类，覆写其中的onServiceConnected(ComponentName name, IBinder service)方法和onServiceDisconnected(ComponmentName name)方法，然后再onServiceConnected方法中获取Service对应的Binder类的实例。 参考：http://www.cnblogs.com/newcj/archive/2011/05/30/2061370.html 注意： Service默认是工作在主线程的，所以默认情况下，如果在Service中做的时间过长，同样也会导致ANR的问题，因此有3中解决方法： 在Service开启线程 使用IntentService(会开辟一个工作线程的FIFO工作队列，工作完成之后自动结果，覆写onHandleIntent(Intent intent)就可以) 设置android:remote=”true”，使用广播通信 AIDL Service的onStartCommand()会返回一个数值，表示当Service被Kill掉的时候不同的反应。 START_NOT_STICKY 如果系统在onStartCommand()方法返回之后kill掉该服务，那么除非有其他的Pending Intent需要传递，那么不会重新创建该Service。 START_STICKY 如果系统在onStartCommand()方法返回之后kill掉该服务，那么系统会重新创建该服务，并且重新调用onStartCommand()，并且不会重新派发最近的intent。如果此时没有需要派发的Intent，那么就会传入一个null的intent。这种情况适用于媒体播放等情况，不执行命令，但是在后台等待任务。 START_REDELIVER_INTENT 如果系统在onStartCommand()方法返回之后kill掉该服务，那么系统会重新创建该服务，并且重新调用onStartCommand()，并且重新派发最近的intent。用于需要立刻恢复继续处理的情况，比如说下载服务。 如何实现Service的不死之身？ onDestory中重启服务 两个服务互相关心 AlarmManger定时广播检查 监听各种事件，比如锁屏开屏，网络变化。 10、注册广播有几种方式，这些方式有何优缺点？请谈谈Android引入广播机制的用意。 Android广播机制（两种注册方法） 在android下，要想接受广播信息，那么这个广播接收器就得我们自己来实现了，我们可以继承BroadcastReceiver，就可以有一个广播接受器了。有个接受器还不够，我们还得重写BroadcastReceiver里面的onReceiver方法，当来广播的时候我们要干什么，这就要我们自己来实现，不过我们可以搞一个信息防火墙。具体的代码： public class SmsBroadCastReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Bundle bundle = intent.getExtras(); Object[] object = (Object[]) bundle.get(“pdus”); SmsMessage sms[] = new SmsMessage[object.length]; for (int i = 0; i &lt; object.length; i++) { sms[0] = SmsMessage.createFromPdu((byte[]) object); Toast.makeText(context, “来自” + sms.getDisplayOriginatingAddress() + “的消息是：” + sms.getDisplayMessageBody(), Toast.LENGTH_SHORT).show(); } // 终止广播，在这里我们可以稍微处理，根据用户输入的号码可以实现短信防火墙。 abortBroadcast(); }} 当实现了广播接收器，还要设置广播接收器接收广播信息的类型，这里是信息：android.provider.Telephony.SMS_RECEIVED 我们就可以把广播接收器注册到系统里面，可以让系统知道我们有个广播接收器。这里有两种，一种是代码动态注册： //生成广播处理 smsBroadCastReceiver = newSmsBroadCastReceiver(); //实例化过滤器并设置要过滤的广播 IntentFilter intentFilter = newIntentFilter(&quot;android.provider.Telephony.SMS_RECEIVED&quot;); //注册广播 BroadCastReceiverActivity.this.registerReceiver(smsBroadCastReceiver,intentFilter); 一种是在AndroidManifest.xml中配置广播 &lt;receiver android:name=&quot;.SmsBroadCastReceiver&quot; &gt; &lt;intent-filterandroid:priority&gt; &lt;actionandroid:name android.provider.Telephony.SMS_RECEIVED=&quot;&quot; /&gt; &lt;intent-filter&gt; &lt;/intent-filter&gt; &lt;/intent-filterandroid:priority&gt; &lt;/receiver&gt; 两种注册类型的区别是： 1)第一种不是常驻型广播，也就是说广播跟随程序的生命周期。 2)第二种是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。 11、请解释下在单线程模型中Message、Handler、MessageQueue、Looper之间的关系。Handler简介： 一个Handler允许你发送和处理Message和Runable对象，这些对象和一个线程的MessageQueue相关联。每一个线程实例和一个单独的线程以及该线程的MessageQueue相关联。当你创建一个新的Handler时，它就和创建它的线程绑定在一起了。这里，线程我们也可以理解为线程的MessageQueue。从这一点上来看，Handler把Message和Runable对象传递给MessageQueue，而且在这些对象离开MessageQueue时，Handler负责执行他们。 Handler有两个主要的用途：（1）确定在将来的某个时间点执行一个或者一些Message和Runnable对象。（2）在其他线程（不是Handler绑定线程）中排入一些要执行的动作。 Scheduling Message，即（1），可以通过以下方法完成： post(Runnable):Runnable在handler绑定的线程上执行，也就是说不创建新线程。 postAtTime(Runnable,long): postDelayed(Runnable,long): sendEmptyMessage(int): sendMessage(Message): sendMessageAtTime(Message,long): sendMessageDelayed(Message,long): post这个动作让你把Runnable对象排入MessageQueue,MessageQueue受到这些消息的时候执行他们，当然以一定的排序。sendMessage这个动作允许你把Message对象排成队列，这些Message对象包含一些信息，Handler的hanlerMessage(Message)会处理这些Message.当然，handlerMessage(Message)必须由Handler的子类来重写。这是编程人员需要作的事。 当posting或者sending到一个Hanler时，你可以有三种行为：当MessageQueue准备好就处理，定义一个延迟时间，定义一个精确的时间去处理。后两者允许你实现timeout,tick,和基于时间的行为。 当你的应用创建一个新的进程时，主线程（也就是UI线程）自带一个MessageQueue，这个MessageQueue管理顶层的应用对象（像activities,broadcast receivers等）和主线程创建的窗体。你可以创建自己的线程，并通过一个Handler和主线程进行通信。这和之前一样，通过post和sendmessage来完成，差别在于在哪一个线程中执行这么方法。在恰当的时候，给定的Runnable和Message将在Handler的MessageQueue中被Scheduled。 Message简介： Message类就是定义了一个信息，这个信息中包含一个描述符和任意的数据对象，这个信息被用来传递给Handler.Message对象提供额外的两个int域和一个Object域，这可以让你在大多数情况下不用作分配的动作。 尽管Message的构造函数是public的，但是获取Message实例的最好方法是调用Message.obtain(),或者Handler.obtainMessage()方法，这些方法会从回收对象池中获取一个。 MessageQueue简介： 这是一个包含message列表的底层类。Looper负责分发这些message。Messages并不是直接加到一个MessageQueue中，而是通过MessageQueue.IdleHandler关联到Looper。 你可以通过Looper.myQueue()从当前线程中获取MessageQueue。 Looper简介： Looper类被用来执行一个线程中的message循环。默认情况，没有一个消息循环关联到线程。在线程中调用prepare()创建一个Looper，然后用loop()来处理messages，直到循环终止。 大多数和message loop的交互是通过Handler。 下面是一个典型的带有Looper的线程实现。 class LooperThread extends Thread { public Handler mHandler; public void run() { Looper.prepare(); mHandler = new Handler() { public voidhandleMessage(Message msg) { // process incomingmessages here } }; Looper.loop(); }} 12、AIDL的全称是什么？如何工作？能处理哪些类型的数据？AIDL的英文全称是Android Interface Define Language 当A进程要去调用B进程中的service时，并实现通信，我们通常都是通过AIDL来操作的 A工程： 首先我们在net.blogjava.mobile.aidlservice包中创建一个RemoteService.aidl文件，在里面我们自定义一个接口，含有方法get。ADT插件会在gen目录下自动生成一个RemoteService.java文件，该类中含有一个名为RemoteService.stub的内部类，该内部类中含有aidl文件接口的get方法。 说明一：aidl文件的位置不固定，可以任意 然后定义自己的MyService类，在MyService类中自定义一个内部类去继承RemoteService.stub这个内部类，实现get方法。在onBind方法中返回这个内部类的对象，系统会自动将这个对象封装成IBinder对象，传递给他的调用者。 其次需要在AndroidManifest.xml文件中配置MyService类，代码如下： &lt;!-- 注册服务 --&gt; &lt;service android:name=&quot;.MyService&quot;&gt; &lt;intent-filter&gt; &lt;!-- 指定调用AIDL服务的ID --&gt; &lt;actionandroid:name=&quot;net.blogjava.mobile.aidlservice.RemoteService&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; 为什么要指定调用AIDL服务的ID,就是要告诉外界MyService这个类能够被别的进程访问，只要别的进程知道这个ID，正是有了这个ID,B工程才能找到A工程实现通信。 说明：AIDL并不需要权限 B工程： 首先我们要将A工程中生成的RemoteService.java文件拷贝到B工程中，在bindService方法中绑定aidl服务 绑定AIDL服务就是将RemoteService的ID作为intent的action参数。 说明：如果我们单独将RemoteService.aidl文件放在一个包里，那个在我们将gen目录下的该包拷贝到B工程中。如果我们将RemoteService.aidl文件和我们的其他类存放在一起，那么我们在B工程中就要建立相应的包，以保证RmoteService.java文件的报名正确，我们不能修改RemoteService.java文件 bindService(newInten(“net.blogjava.mobile.aidlservice.RemoteService”),serviceConnection, Context.BIND_AUTO_CREATE); ServiceConnection的onServiceConnected(ComponentName name, IBinderservice)方法中的service参数就是A工程中MyService类中继承了RemoteService.stub类的内部类的对象。 13、 横竖屏切换时候activity的生命周期? 不设置Activity的android:configChanges时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次 设置Activity的android:configChanges=”orientation”时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次 设置Activity的android:configChanges=”orientation|keyboardHidden”时，切屏不会重新调用各个生命周期，只会执行onConfigurationChanged方法 14、如何将SQLite数据库(dictionary.db文件)与apk文件一起发布? 解答：可以将dictionary.db文件复制到Eclipse Android工程中的res aw目录中。所有在res aw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到res aw目录中 15、 如何将打开res aw目录中的数据库文件? 解答：在Android中不能直接打开res aw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。复制的基本方法是使用getResources().openRawResource方法获得res aw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。 16、Android引入广播机制的用意? 从MVC的角度考虑(应用程序内) 、其实回答这个问题的时候还可以这样问，android为什么要有那4大组件，现在的移动开发模型基本上也是照搬的web那一套MVC架构，只不过是改了点嫁妆而已。android的四大组件本质上就是为了实现移动或者说嵌入式设备上的MVC架构，它们之间有时候是一种相互依存的关系，有时候又是一种补充关系，引入广播机制可以方便几大组件的信息和数据交互。 程序间互通消息(例如在自己的应用程序内监听系统来电) 效率上(参考UDP的广播协议在局域网的方便性) 设计模式上(反转控制的一种应用，类似监听者模式) 17、XML包括哪些解释技术，区别是什么？ DOM将文档解析成一颗文档树，可在节点上进行遍历、增加、修改和删除。一次性读入内存，对内存消耗大。 SAX至上而下解析文档，以事件进行驱动。不会一次性读入内存，对内存消耗小，不能任意读取节点，并且不能对节点进行增加、修改和删除。 18、switch语句能否作用在byte上，能否作用在long上，能否作用在String上? switch能作用在byte、char、short和int上，JDK1.7后可以作用在String上。 19、”==”和equals方法究竟有什么区别？ ==比较地址。==是运算符，equals是方法，方法可以通过重写改变其行为，如String的equals就是比较字符串内容。 20、java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？ java中有三种流，分别是字节流（InputStream、OutputStream）、字符流（Reader、Writer）、对象流（ObjectInputStream、ObjectOutputStream）。 21、字节流与字符流的区别？ 字节流用于读取或写出二进制数据，比如图片、影像等数据。 字符流用于读取或写出字符数据，比如传输字符串。 所有的数据都可以通过字节流来进行处理，不过如果是字符数据，用字节流还需要进行转换后传输，如果使用字符流可以方便数据的转换。 22、当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? 如果其他方法没有加synchronized的话是可以进入的。 23、.描述4 种 activity 的启动模式 standard ：系统的默认模式，一次跳转即会生成一个新的实例。假设有一个activity命名为MainActivity，执行语句： startActivity(new Intent(MainActivity.this, MainActivity.class))后，MainActivity将跳转到另外一个MainActivity，也就是现在的Task栈里面有MainActivity的两个实例。按返回键后你会发现仍然是在MainActivity（第一个）里面。 singleTop singleTop 跟standard 模式比较类似。如果已经有一个实例位于Activity栈的顶部时，就不产生新的实例，而只是调用Activity中的newInstance()方法。如果不位于栈顶，会产生一个新的实例。例：当MainActivity为 singleTop 模式时，执行跳转后栈里面依旧只有一个实例，如果现在按返回键程序将直接退出。 singleTask singleTask模式和后面的singleInstance模式都是只创建一个实例的。在这种模式下，无论跳转的对象是不是位于栈顶的activity，程序都不会生成一个新的实例（当然前提是栈里面已经有这个实例）。这种模式相当有用，在以后的多activity开发中，经常会因为跳转的关系导致同个页面生成多个实例，这个在用户体验上始终有点不好，而如果你将对应的activity声明为 singleTask 模式，这种问题将不复存在。如果该activity启动过，系统会找到对应的task，将task栈中位于activity之上的清除，然后调出对应的activity singleInstance 设置为 singleInstance 模式的 activity 将独占一个task（感觉task可以理解为进程），独占一个task的activity与其说是activity，倒不如说是一个应用，这个应用与其他activity是独立的，它有自己的上下文activity。 24、如何一次性退出所有打开的Activity 编写一个Activity作为入口，当需要关闭程序时，可以利用Activity的SingleTop模式跳转该Activity，它上面的所有Activity都会被销毁掉。然后再将该Activity关闭。 或者再跳转时，设置intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);这样也能将上面的Activity销毁掉。 25、Activity和Service之间如何通信 启动时Intent传递 通过Binder在Activity中获取Service的实例，然后可以在Activity中直接调用Service的方法 通过广播，在Service中发布广播，然后在Activity中接收 通过Binder的transact方法。public final boolean transact (int code, Parcel data, Parcel reply, int flags) Messager AIDL 26、Android不同进程之间数据交换方式 Intent，ContentProvider，Broadcast，AIDL Android同一进程中，Service和Activity通信方式 Binder，Intent，ContentProvider，Broadcast，AIDL，(通过Binder传递Handler对象)Handler 27、Intent对象可以携带的携带数据 通过查询Intent/Bundle的API文档，我们可以获知，Intent/Bundle支持传递基本类型的数据和基本类型的数组数据，以及String/CharSequence类型的数据和String/CharSequence类型的数组数据。而对于其它类型的数据貌似无能为力，其实不然，我们可以在Intent/Bundle的API中看到Intent/Bundle还可以传递Parcelable（包裹化，邮包）和Serializable（序列化）类型的数据，以及它们的数组/列表数据。 28、ContentValues可以存放的数据类型 Key：String Value：Byte，Integer，Float，Short，byte[]，String，Double，Long，Boolean等常用数据类型。 28、算法让程序更省电 利用推送服务替换轮询 通过AlarmManager的定时任务替代轮询操作 还可以采用比如一些指数退避的算法来减少更新频率，尤其是后台的时候，用户不去点击界面的时候，不需要那么高的刷刷新频率。 先获取当前的连接状态，在发送Http请求的时候，是否有网络可以用，如果无网络可用，则不要去获取新的数据，因为必然是在浪费电量。 检查电量，根据电量的多少采取不同的策略。 wakeclock和其他的硬件资源不要占用时间过多，用完之后及时释放 传感器 加速度传感器，亮度传感器等等 其他的 蓝牙，WiFi，GPS等等 可以将上面的资源的获取和释放，与生命周期结合起来。 29、能快速重新联网 心跳检测 监听网络状态 30、Queue接口 Throws exception Returns special value Insert add(e)) offer(e)) Remove remove()) poll()) Examine element()) peek()) 31、Android中常见的设计模式 组合模式 View和ViewGroup的使用(几乎所有的widget和布局类) 观察者模式 通知和广播 DataSetObserver,ContentObserver 单例模式 获取系统中的各种Service，比如INPUT_METHOD_SERVICE，WIFI的Service 模板方法模式 View中定好模板，子类比如Button或者自定义的View要依据其模板来。 备忘录模式 就是保存状态，然后做会其他的事情，然后再回来继续 享元模式 比如String之间共享，还有SQL的编译，具体的没看过 命令模式 Runnable的run()方法 工厂方法 太多了，比如BitmapFactory，Connection相关的 适配器模式 ListView，GridView，ViewPager等里面的Adapter。 原型模式 clone方法 策略模式 比如Collections中的sort()方法 比如Annimation中的Interpolator不同实现，不同的Interpolator带来不同的策略。 生成器模式(建造者模式) DialogBuilder() 责任链/响应链 触摸、按键各种事件的传递 装饰者模式 各种InputStream.OutputStream 31、Adapter中getView的写法 ListView item缓存机制：为了使得性能更优，ListView会缓存行item(某行对应的View)。ListView通过adapter的getView函数获得每行的item。滑动过程中， a. 如果某行item已经滑出屏幕，若该item不在缓存内，则put进缓存，否则更新缓存； b. 获取滑入屏幕的行item之前会先判断缓存中是否有可用的item，如果有，做为convertView参数传递给adapter的getView。 更具体可见源代码ListView.obtainView。 来源： &lt;http://www.trinea.cn/android/android-listview-display-error-image-when-scroll/&gt; 虽然两种设置不同，结果也不同，但是convertview的机制没有变。 其实到此为止我们可以总结出convertview的机制了，就是在初始显示的时候，每次显示一个item都调用一次getview方法但是每次调用的时候covertview为空（因为还没有旧的view），当显示完了之后。如果屏幕移动了之后，并且导致有些Item（也可以说是view）跑到屏幕外面，此时如果还有新的item需要产生，则这些item显示时调用的getview方法中的convertview参数就不是null，而是那些移出屏幕的view（旧view），我们所要做的就是将需要显示的item填充到这些回收的view（旧view）中去，最后注意convertview为null的不仅仅是初始显示的那些item，还有一些是已经开始移入屏幕但是还没有view被回收的那些item。 最终我们用亲手写的代码实现了Recycler(反复循环器). 第二个问题其实应该在第一个问题中嵌套来讲，但是为了思路清晰我分开了： view的setTag和getTag方法其实很简单，在实际编写代码的时候一个view不仅仅是为了显示一些字符串、图片，有时我们还需要他们携带一些其他的数据以便我们对该view的识别或者其他操作。于是android 的设计者们就创造了setTag(Object)方法来存放一些数据和view绑定，我们可以理解为这个是view 的标签也可以理解为view 作为一个容器存放了一些数据。而这些数据我们也可以通过getTag() 方法来取出来。 到这里setTag和getTag大家应该已经明白了。再回到上面的话题，我们通过convertview的setTag方法和getTag方法来将我们要显示的数据来绑定在convertview上。如果convertview 是第一次展示我们就创建新的Holder对象与之绑定，并在最后通过return convertview 返回，去显示；如果convertview 是回收来的那么我们就不必创建新的holder对象，只需要把原来的绑定的holder取出加上新的数据就行了。 来源： &lt;http://blog.csdn.net/pkxiuluo01/article/details/7380974&gt; class LooperThread extends Thread { @Override public View getView(int position, View convertView, ViewGroup parent) { ViewHolder holder; if (convertView == null) { convertView = inflater.inflate(R.layout.list_item, null); holder = new ViewHolder(); …… convertView.setTag(holder); } else { holder = (ViewHolder)convertView.getTag(); } } private static class ViewHolder { ImageView appIcon; TextView appName; TextView appInfo; }} 32、生命周期 Activity的生命周期 Fragent的生命周期 33、屏幕尺寸 px Pixels - corresponds to actual pixels on the screen. 对应屏幕上的每一个像素点 in Inches - based on the physical size of the screen. 1 Inch = 2.54 centimeters 英尺 mm Millimeters - based on the physical size of the screen. 毫米 pt Points - 1/72 of an inch based on the physical size of the screen. 点？ dp Density-independent Pixels - an abstract unit that is based on the physical density of the screen. These units are relative to a 160 dpi screen, so one dp is one pixel on a 160 dpi screen. The ratio of dp-to-pixel will change with the screen density, but not necessarily in direct proportion. Note: The compiler accepts both “dip” and “dp”, though “dp” is more consistent with “sp”. 分辨率独立单位，单位是在160dpi上定义的，160dpi上，1dp=pixel sp Scale-independent Pixels - this is like the dp unit, but it is also scaled by the user’s font size preference. It is commend you use this unit when specifying font sizes, so they will be adjusted for both the screen density and user’s preference. 缩放独立的单位，一般用在文字大小上 来源： &lt;http://stackoverflow.com/questions/2025282/difference-between-px-dp-dip-and-sp-in-android&gt; 34、Android事件处理机制： 基于监听的事件处理：比如设置onClickListener 基于回调的事件处理：主要是重写Android组件的特定的回调方法，或者重写Activity的回调方法。 onBackPressed(),onKeyDown(int keycode, KeyEvent event), onKeyLongPress,onKeyUp() 基于分工的事件模型分工更加明确，事件源、事件监听由两个类分开实现，具有更好的维护性。 Android的事件处理机制保证监听的事件监听器会被优先触发。 35、Activity的启动、关闭 启动 startActivity(Intent intent); startActivityForResult(Intent intent, int requestCode) 要注意上面的intent可以是显示的intent，也可以是隐式的，但如果是隐式的，那么指向的activity必须设置category为 关闭 finish()关闭自己 finish(int requestCode)，关闭以startActivityForResult启动的Activity。 System.exit(0) 36、Intent-Filter中action和category的区别。 回答：改变以前从app角度来看问题的思路，整个问题从intent的设计角度来谈。当Intent在创建的时候，创建者并不会知道到底系统中哪个程序来处理这个Intent。但是Intent的创建者会知道他们想要做什么（比如从设备中获取一个通讯录），并且需要访问其他的程序来获取所需要的。 为了在实现这个，Intent会有一些信息来实现这个，其中就包含了actions和categories。 actions是定义了一个Intent的通用的方法，比如查看contact，比如从Gallery中获取一张照片。 category则是提供了额外的信息来识别到底调用哪个程序。比如当浏览器中点击一个I拦截，Intent会包含一个BROWSABLE的category来识别他。 所以当系统去识别一个Intent的时候，会查找所有注册的Activy，Service，BroadcastReceiver包含上面全部信息的那些。如果Intent要识别PICK的action，那么如果Activity的Intent-fileter中不包含PICK的action的就会被从候选名单中剔除。con 通过这种办法，由action，category，type，以及可能的scheme组合在一起，来找到具体的执行操作的组件。 37、Android 程序 ，不能混淆的地方 Android系统组件，系统组件有固定的方法被系统调用。 被Android Resource 文件引用到的。名字已经固定，也不能混淆，比如自定义的View 。 Android Parcelable ，需要使用android 序列化的。 其他Anroid 官方建议 不混淆的，如 android.app.backup.BackupAgentHelper android.preference.Preference com.android.vending.licensing.ILicensingService Java序列化方法，系统序列化需要固定的方法。 枚举 ，系统需要处理枚举的固定方法。 本地方法，不能修改本地方法名 annotations 注释 数据库驱动 有些resource 文件 用到反射的地方","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"},{"name":"面试","slug":"Android/面试","permalink":"http://yoursite.com/categories/Android/面试/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"Queue,PriorityQueue学习","slug":"java-queue-priorityqueue","date":"2014-03-06T06:04:05.000Z","updated":"2018-10-03T15:10:41.260Z","comments":true,"path":"2014/03/06/java-queue-priorityqueue/","link":"","permalink":"http://yoursite.com/2014/03/06/java-queue-priorityqueue/","excerpt":"","text":"import java.util.Arrays;import java.util.Collections;import java.util.HashSet;import java.util.List;import java.util.PriorityQueue;import java.util.Queue;import java.util.Random;import java.util.Set; public class TestPriorityQueue { public static void main(String[] args){ PriorityQueue priorityQueue = new PriorityQueue(); Random random = new Random(47); for(int i=0; i&lt;10; i++){ priorityQueue.offer(random.nextInt(i+10)); } printQ(priorityQueue); List&lt;Integer&gt; ints = Arrays.asList(25, 22, 20, 18, 14, 9, 3, 1, 1, 2, 3, 9, 14, 18, 21, 23, 25); priorityQueue = new PriorityQueue&lt;Integer&gt;(ints); printQ(priorityQueue); priorityQueue = new PriorityQueue&lt;&gt;(ints.size(), Collections.reverseOrder()); priorityQueue.addAll(ints); printQ(priorityQueue); String fact = &quot;EDUCATION SHOULD ESCHEW OBFUSCATION&quot;; List&lt;String&gt; strings = Arrays.asList(fact.split(&quot;&quot;)); PriorityQueue&lt;String&gt; stringPriorityQueue = new PriorityQueue&lt;String&gt;(strings); printQ(stringPriorityQueue); stringPriorityQueue = new PriorityQueue&lt;String&gt;(strings.size(), Collections.reverseOrder()); stringPriorityQueue.addAll(strings); printQ(stringPriorityQueue); Set&lt;Character&gt; charSet = new HashSet&lt;Character&gt;(); for(char c : fact.toCharArray()){ charSet.add(c); } PriorityQueue&lt;Character&gt; characterPQ = new PriorityQueue&lt;Character&gt;(charSet); printQ(characterPQ); } public static void printQ(Queue queue){ while(queue.peek() != null){ System.out.print(queue.remove()+&quot; &quot;); } System.out.println(); } } 运行结果为： 0 1 1 1 1 1 3 5 8 141 1 2 3 3 9 9 14 14 18 18 20 21 22 23 25 2525 25 23 22 21 20 18 18 14 14 9 9 3 3 2 1 1 A A B C C C D D E E E F H H I I L N N O O O O S S S T T U U U WW U U U T T S S S O O O O N N L I I H H F E E E D D C C C B A A A B C D E F H I L N O S T U W 注意： PriorityQueue可以传入Comparator来规定排序的顺序，主要是Comparator中的compare函数。","categories":[{"name":"Java 编程思想","slug":"Java-编程思想","permalink":"http://yoursite.com/categories/Java-编程思想/"},{"name":"Java编程","slug":"Java-编程思想/Java编程","permalink":"http://yoursite.com/categories/Java-编程思想/Java编程/"},{"name":"读书笔记","slug":"Java-编程思想/Java编程/读书笔记","permalink":"http://yoursite.com/categories/Java-编程思想/Java编程/读书笔记/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Queue","slug":"Queue","permalink":"http://yoursite.com/tags/Queue/"}]},{"title":"内部类","slug":"java-inner-class","date":"2014-03-06T04:58:16.000Z","updated":"2018-10-03T14:54:17.305Z","comments":true,"path":"2014/03/06/java-inner-class/","link":"","permalink":"http://yoursite.com/2014/03/06/java-inner-class/","excerpt":"","text":"1、创建内部类：内部类：即该类位于一个类的内部。典型的情况是，外部类中有一个方法，可以返回一个指向内部类的引用，如果需要具体指明这个对象的类型，需要使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960612、链接到外部类：---------内部类可以访问其外围对象的所有成员，包括private修饰的成员变量或者方法。典型的代码如下：```javainterface Selector&#123; boolean end(); Object current(); void next();&#125;public class Sequence &#123; private Object\\[\\] items; private int next = 0; public Sequence(int size)&#123; items = new Object\\[size\\]; &#125; public void add(Object x)&#123; if(next &lt; items.length)&#123; items\\[next++\\] = x; &#125; &#125; private class SequeneSelector implements Selector&#123; private int i = 0; @Override public boolean end() &#123; // TODO Auto-generated method stub return i == items.length; &#125; @Override public Object current() &#123; // TODO Auto-generated method stub return items\\[i\\]; &#125; @Override public void next() &#123; // TODO Auto-generated method stub if(i &lt; items.length) i++; &#125; &#125; public Selector selector()&#123; return new SequeneSelector(); &#125; public static void main(String\\[\\] args)&#123; Sequence sequence = new Sequence(10); for(int i=0; i &lt; 10; i++)&#123; sequence.add(i); &#125; Selector selector = sequence.selector(); while(!selector.end())&#123; System.out.print(selector.current()+&quot; &quot;); selector.next(); &#125; &#125; &#125; 这段代码很有价值： 1、说明了内部类可以访问到外部类的所有的元素。 2、介绍了一种“迭代器”方法，这个需要在《Head First设计模式》好好读一读。 同时需要注意的是：当内部类是static类型的情况下，内部类依赖于外部类的存在而存在，因此在构建内部类的情况下，需要一个指向其外围类对象的引用。 3、使用.this和.new如果需要在内部类中返回对外部类的引用，需要使用 外部类.this 来返回。参见以下代码： 123456789101112131415161718public class Outer &#123; void print()&#123; System.out.println(\"Outer print\"); &#125; public class Inner&#123; public Outer getOuter()&#123; return Outer.this; &#125; &#125; public Inner inner()&#123; return new Inner(); &#125; public static void main(String\\[\\] args)&#123; Outer outer = new Outer(); Outer.Inner inner = outer.inner(); inner.getOuter().print(); &#125;&#125; 如果需要在内部类定义的外部类以外的地方生成内部类，需要使用 外部类.new 的方法来生成。参见以下代码： 1234567public class TestOuter &#123; public static void main(String\\[\\] args)&#123; Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); inner.getOuter().print(); &#125;&#125; 这个地方要注意的是，必须使用外部类的对象来创建内部类。在拥有外部类的对象之前，不能创建内部类。当前，如果内部类是静态static的(即嵌套类)，那是可以需要外部类的引用的。 4、匿名内部类12345678910111213141516171819interface Contents&#123; String value();&#125;public class AnonymousClass &#123; public Contents contents(final String conent)&#123; return new Contents() &#123; private String label = conent; @Override public String value() &#123; // TODO Auto-generated method stub return label; &#125; &#125;; &#125; public static void main(String\\[\\] args)&#123; System.out.print(new AnonymousClass().contents(\"Test\").value()); &#125;&#125; 如上代码所示，匿名内部类返回了一个继承自Contents的匿名类的对象。需要注意的是，如果传入的变量需要在匿名类内部直接使用的话，那么函数参数要求必须是final修饰的，即不允许匿名类来修改。但如果不是在匿名类中直接使用，那么是可以不需要final修饰的。 需要注意的是：匿名内部类既可以扩展类，也可以扩展接口，但不能两者皆有，而且如果扩展接口的话，只允许扩展一个。 5、匿名内部类与工厂函数匿名内部类和工厂函数是很好的搭配在一起，参见下面的程序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960interface Game&#123; boolean move();&#125;interface GameFactory&#123; Game getGame();&#125;class Checkers implements Game&#123; private Checkers()&#123;&#125; private int moves = 0; private static final int MOVES = 3; public boolean move()&#123; System.out.println(\"Checkers move \" + moves); return ++moves != MOVES; &#125; public static GameFactory factory = new GameFactory() &#123; @Override public Game getGame() &#123; // TODO Auto-generated method stub return new Checkers(); &#125; &#125;;&#125;class Chess implements Game&#123; private Chess()&#123;&#125; private int moves = 0; private static final int MOVES = 4; @Override public boolean move() &#123; // TODO Auto-generated method stub System.out.println(\"Chess move \" + moves); return ++moves != MOVES; &#125; public static GameFactory factory = new GameFactory() &#123; @Override public Game getGame() &#123; // TODO Auto-generated method stub return new Chess(); &#125; &#125;;&#125;public class Games &#123; public static void playGame(GameFactory factory)&#123; Game game = factory.getGame(); while(game.move())&#123;&#125;; &#125; public static void main(String\\[\\] args)&#123; playGame(Checkers.factory); playGame(Chess.factory); &#125;&#125; 运行结果为 1234567Checkers move 0Checkers move 1Checkers move 2Chess move 0Chess move 1Chess move 2Chess move 3 6、嵌套类嵌套类，即使用了static修饰的内部类。由于使用了static修饰，因此以下两个问题需要注意： 1、要创建嵌套类的对象，不需要其外围类的对象 2、嵌套类中，不能访问非静态的外部类对象。 普通的内部类，不能有static修饰的变量或者方法，也不能包含嵌套类。但是嵌套类可以包含这些东西。同样的嵌套类中也么有.this指向外部类。 7、接口内部的类普通情况下，接口内不能放置任何代码，但是嵌套类可以作为接口的一部分。放到接口中的任何类都是pubilc static的 8、为什么使用内部类每个内部类都能够独立的继承自一个接口的实现，所以无论外围类是否已经继承了某个类或者接口的实现，对于内部类没有影响。","categories":[{"name":"Java 编程思想","slug":"Java-编程思想","permalink":"http://yoursite.com/categories/Java-编程思想/"},{"name":"读书笔记","slug":"Java-编程思想/读书笔记","permalink":"http://yoursite.com/categories/Java-编程思想/读书笔记/"}],"tags":[]},{"title":"Java:证明在接口中的域隐式地是static和final的","slug":"java-prove-interface-static-final","date":"2014-03-05T03:05:12.000Z","updated":"2018-10-03T15:01:07.699Z","comments":true,"path":"2014/03/05/java-prove-interface-static-final/","link":"","permalink":"http://yoursite.com/2014/03/05/java-prove-interface-static-final/","excerpt":"","text":"在读《Java编程思想》的时候，P184页看到这样一个题目，很有意思： 证明在接口中的域隐士地是static和final的 首先，我们都明白，Java的接口，默认的域都是static和final的，而方法默认的也是public的，那么怎么确定呢？ 对于final，这个比较简单，直接改写该域，如果可以，则不是final修饰，如果不能，则是final修饰。 对于static，其实也是一样，如果可以直接访问，那么则是static修饰的，如果不能，则说明不是static修饰的。 除了上面的方法外，还有一种，使用Java的反射机制。 import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;public class Test{ interface TestInterface{ int data = 1; void test(); } public static void main(String[] args) { try{ Class obj = TestInterface.class; Field field = obj.getField(“data”); System.out.println(“修饰符:”+Modifier.toString(field.getModifiers())); Method method = obj.getMethod(“test”, null); System.out.println(“修饰符:”+Modifier.toString(method.getModifiers())); }catch(Exception e){ e.printStackTrace(); }; } } 具体就无需解释，运行结果如下： 修饰符:public static final修饰符:public abstract","categories":[{"name":"Java 编程思想","slug":"Java-编程思想","permalink":"http://yoursite.com/categories/Java-编程思想/"},{"name":"读书笔记","slug":"Java-编程思想/读书笔记","permalink":"http://yoursite.com/categories/Java-编程思想/读书笔记/"}],"tags":[]},{"title":"标记化结构初始化语法(C语言)(转载)","slug":"c-struct-introduce","date":"2013-09-02T09:07:09.000Z","updated":"2018-10-03T15:02:20.201Z","comments":true,"path":"2013/09/02/c-struct-introduce/","link":"","permalink":"http://yoursite.com/2013/09/02/c-struct-introduce/","excerpt":"","text":"看LDD的时候，看到标准C的标记化结构初始化语法，找到文章，转载一下： http://blog.csdn.net/chen_chun_guang/article/details/6199932 http://www.hustyx.com/cplusplus/agtodXN0eWl4aWFuZ3IPCxIHQXJjaGl2ZRihigcM 以前在看Linux代码时，就对它的结构体初始化写法感到奇怪，所有的初始化代码都写清了变量名，并且变量名前面还有一个诡异的点。最近学习Linux设备驱动，又遇到了，就查了一下，发现自己的知识果然纰漏不少，此种初始化写法并不是什么特殊的代码风格，而是所谓的C语言标记化结构初始化语法（designated initializer），而且还是一个ISO标准。 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;struct operators{ void (*read1)(char *); void (*read2)(char *); void (*read3)(char *); int n;}; void read1(char data){ printf(“read1: %s/n”,data);}void read2(char data){ printf(“read2: %s/n”,data);}void read3(char *data){ printf(“read3: %s/n”,data);} int main(){ //传统的初始化方法 //struct operators my_op = {read1, read2, read3, 100}; //所谓的标记化结构初始化语法 struct operators my_op = {.read2 = read2, .read1 = read1, .read3 = read3, .n = 100}; my_op.read1(“wangyang”); my_op.read2(“wangyang”); my_op.read3(“wangyang”); return 0;} 重点就在于main()函数中对my_op结构体的初始化语句，使用点加变量名进行初始化。用过python的人会马上感觉到这与关键字传参是多么的相似。 那它的好处在哪里呢？我想好处有三: 首先，标记传参不用理会参数传递的顺序，正如我上面的例子表示的那样，我是先初始化了read2，然后再初始化了read1，程序员不用记忆参数的顺序； 其次，我们可以选择性传参，在传统C语言顺序传参中，如果你只想对第三个变量进行初始化，那么你不得不给第一个, 第二个参数进行初始化，而有时候一个变量并没有很合适的默认值，而使用标记初始化法，你可以相当自由地对你有把握的参数进行初始化； 第三，扩展性更好，如果你要在该结构体中增加一个字段，传统方式下，为了考虑代码修改量，你最好将新添加的字段放在这个结构体的最后面，否则你将要面对大量且无趣的修改，你可能觉得放在哪里没什么关系，但是我们都习惯了，姓名下面是性别，性别下面是年龄，接着是兴趣爱好，最后是事迹描述，如果年龄放在了最后面，难道不别扭么？！ 有人提到，该种语法还有利于提高性能，木有感觉出来，我在这里就不谈这点了。 其实，该种初始化语法并不是什么新技术，新定义，它就是ISO C99的一个标准用法，也就是说99年就有了，再说Linus也不会去赶什么时髦的，据说C Primer Plus第五版中提到了这点，不过，我没有看过该书，遗憾，我是直接投入了面向对象的怀抱。 GCC有扩展标记化结构初始化语法，写法是下面这样的： struct operators my_op = {read2 : read2, read1 : read1, read3 : read3,};","categories":[{"name":"C编程","slug":"C编程","permalink":"http://yoursite.com/categories/C编程/"}],"tags":[]},{"title":"Java 本地方法 1、初步认识","slug":"java-jni-method","date":"2013-07-10T08:20:12.000Z","updated":"2018-10-03T14:43:33.041Z","comments":true,"path":"2013/07/10/java-jni-method/","link":"","permalink":"http://yoursite.com/2013/07/10/java-jni-method/","excerpt":"","text":"本地方法，就是在Java虚拟机中调用二进制文件，Android的JNI调用用的也是Java的这一套，因此有必要好好来学习一下。 主要参考 《Java核心技术：卷 II 高级特性》 一、从Java中调用C函数1、Java层代码：在Android编程中，这也是本地方法最为常用的一块内容，在Java中，使用native关键字表示本地方法，提示该方法是在外部定义。本地方法不包括代码，直接用分号结束。如：在Fruit.java，代码如下： package NativeMethod; public class Fruit { public static native void hello();} 此处的本地方法，我们使用的是静态的，其实本地方法既可以是静态的，也可以是非静态的。区别？ 该类可以编译，但现在还无法被调用，否则会提示找到函数的错误。 2、C本地代码：为了使得我们的程序能够被Java中被调用，我们必须按照Java本地方法的原则来书写函数，规则为： 我们的工程的目录为 包名(NativeMethod)，该包下面有Fruit.java和TestNativeMethod.java两个文件 1）使用完整的Java的方法名字，包含包名，比如是 Fruit.java下面的 hello()方法，则应该是 NativeMethod.Fruit.hello 2）使用下划线代替所有的句号，并加上Java前缀，即 Java_NativeMethod_Fruit_hello 3）如果类名中有非ASCII字母或者数字，如：’_’,’$’等，或者大于’\\u007F’的字符，则用 _0xxxx代替，其中xxxx为4个十六进制数。 Tips： 如果重载本地方法，那么相同的名字提供多个本地方法的话，需要在名称后面附加两个下划线，后面再加上已经编码的参数类型，如有一个本地方法greeting和greeting(int repeat) ，那么第一个 为 _greeting__ 另外一个为 _greeting__I. 这些工作无需手工完成，可以使用javah工具。以上述我们的程序为例。 首先cd到我们的包名所在的文件夹$ lsNativeMethod Serializable 编译我们的Fruit.java，javac NativeMethod/Fruit.java 使用javah生成头文件javah NativeMethod.Fruit 需要注意的是，此处不是指定指定目录找到类的文件，而是在前面提到的头文件格式中的第一步那样，指明类的完整名字，包含包名，此处我们的包名是NativeMethod，方法名是Fruit，因此调用的是 javah NativeMethod.Fruit 生成的文件NativeMethod_Fruit.h /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt;/* Header for class NativeMethod_Fruit */ #ifndef _Included_NativeMethod_Fruit #define _Included_NativeMethod_Fruit #ifdef __cplusplusextern “C” { #endif/* * Class: NativeMethod_Fruit * Method: hello * Signature: ()V /JNIEXPORT void JNICALL Java_NativeMethod_Fruit_hello (JNIEnv , jclass); #ifdef __cplusplus} #endif #endif 编辑C代码#include “NativeMethod_Fruit.h” #include &lt;stdio.h&gt; JNIEXPORT void JNICALL Java_NativeMethod_Fruit_hello (JNIEnv * env, jclass cl){ printf(“Hello World!\\n”);} 生成动态连接库gcc -fPIC -I /home/happyhls/tools/jdk1.7.0_25/include/ -I /home/happyhls/tools/jdk1.7.0_25/include/linux/ -shared -o libNativeMethod_Fruit.so NativeMethod_Fruit.c 其中，-fPIC命令为使用PIC动态连接，是动态连接方式的一种。 -I引入头文件， -shared生成动态连接库 编写测试代码package NativeMethod; public class TestNativeMethod { public static void main(String\\[\\] args){ Fruit.hello(); } static{ System.loadLibrary(&quot;NativeMethod_Fruit&quot;); } } 运行即可。java -Djava.library.path=. NativeMethod/TestNativeMethodHello World! 注意的是，此处需要引入环境变量，所以运行时使用-D选项 方法有两种 1、export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH 2、java -Djava.library.path=. 运行路径","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Java 序列化","slug":"java-serialize","date":"2013-07-08T08:37:05.000Z","updated":"2018-10-03T14:43:10.925Z","comments":true,"path":"2013/07/08/java-serialize/","link":"","permalink":"http://yoursite.com/2013/07/08/java-serialize/","excerpt":"","text":"综述概念：所谓序列化，是指Java可以将任何对象写出到流中，并且在任何时候将其读回，这样我们就可以方便的将Java的对象进行保存、回复。 一：Serializable接口java.io.Serializable接口，该接口是最为常用并且最为简单使用的序列化接口，只要我们在想要序列化的类上继承该接口，就可以自动实现该类的序列化。 1、使用：参考下面的代码： package Serializable; import java.io.Serializable; public class Fruit implements Serializable{ public String name; public float price; public Fruit(String name,float price){ this.name = name; this.price = price; } public void show(){}; } package Serializable; import java.io.Serializable; public class Apple extends Fruit implements Serializable{ public Apple(String name,float price){ super(name, price); } @Override public void show(){ System.out.println(&quot;A apple named:&quot;+name+&quot; price:&quot;+price); } } package Serializable; import java.io.Serializable; public class Orange extends Fruit implements Serializable{ public Orange(String name,float price){ super(name, price); } @Override public void show(){ System.out.println(&quot;A orange named:&quot;+name+&quot; price:&quot;+price); } } package Serializable; import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream; public class SerializableInterfaceTest { private static final long serialVersionUID = 8449604890628424672L; public static void main(String\\[\\] args){ try { ObjectOutputStream op = new ObjectOutputStream(new FileOutputStream(new File(&quot;testSerializable&quot;))); op.writeObject(new Apple(&quot;apple&quot;, 1.1f)); op.writeObject(new Orange(&quot;orange&quot;,2.2f)); op.close(); } catch (FileNotFoundException e) { // TODO Auto-generated catch block System.out.println(&quot;File not found!&quot;); } catch (IOException e) { // TODO: handle exception e.printStackTrace(); } try { ObjectInputStream oi = new ObjectInputStream(new FileInputStream(new File(&quot;testSerializable&quot;))); Apple apple = (Apple)oi.readObject(); Orange orange = (Orange)oi.readObject(); apple.show(); orange.show(); } catch (FileNotFoundException e) { // TODO Auto-generated catch block System.out.println(&quot;File not found!&quot;); } catch (IOException e) { // TODO: handle exception e.printStackTrace(); } catch(ClassNotFoundException e){ e.printStackTrace(); } } } 程序运行结果： A apple named:apple price:1.1A orange named:orange price:2.2 生成的testSerializable文件内容为： ��sr\u0012Serializable.AppleE-�f����\u0002xr\u0012Serializable.Fruit_,�}�&amp;��\u0002\u0002FpriceL\u0004namet\u0012Ljava/lang/String;xp?���tapplesr\u0013Serializable.Orange���0h�\u0002xq~\u0001@ 可以看到，通过 java.io.Serializable接口，可以实现类的序列化，并将序列化之后的数据写入文件，并重新从文件读出。 2、注意事项：仔细观察上面的程序，Fruit基类、Apple子类、Orange子类都实现了序列化，那么问题来了，如果说父类和子类有没有实现该接口的情况下会怎么样呢？ 将Fruit基类去掉对Serializable的接口，重新运行该程序，会发现如下的错误： java.io.InvalidClassException: Serializable.Apple; no valid constructor at java.io.ObjectStreamClass$ExceptionInfo.newInvalidClassException(ObjectStreamClass.java:150) at java.io.ObjectStreamClass.checkDeserialize(ObjectStreamClass.java:768) at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:1770) at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1348) at java.io.ObjectInputStream.readObject(ObjectInputStream.java:370) at Serializable.SerializableInterfaceTest.main(SerializableInterfaceTest.java:32) 会发现在程序写入序列化的时候，没有任何错误的提示，但在读入数据的时候，却提示错误，我们看写入的文件内容有什么变化 ��sr\u0012Serializable.AppleE-�f����\u0002xpsr\u0013Serializable.Orange���0h�\u0002xp 会发现确实只序列化了Apple和Orange子类，但重新构建的时候，是找不到Fruit基类的，也就是上面，没有相应的构造函数。 原因是什么？ 我们继续探究，如果Fruit基类继承了该接口，但子类Apple没有继承该接口呢？重新编译、运行，发现能够正常运行，那是不是如果父类继承了该接口，子类就可以自动的序列化呢？从Java继承的角度来将，是这样理解的，父类继承了该接口，子类当然可以，但Java的Serializable接口是使用了Java的Reflection机制实现的，因此我们继续探究一下，当前的Apple类过于简单，我们再稍微加一点内容，将Apple修改如下： package Serializable; import java.io.Serializable; public class Apple extends Fruit{ public int productYear; public Apple(String name,float price){ super(name, price); productYear = 2013; } @Override public void show(){ System.out.println(&quot;A apple named:&quot;+name+&quot; price:&quot;+price +&quot; product:&quot;+productYear); } } 在这里增加了一个int的productYear属性，执行结果为： A apple named:apple price:1.1 product:2013A orange named:orange price:2.2 所以可以看出来，如果父类继承了Serializable接口的话，子类也可以自动继承该接口，并实现序列化。 那如果父类没有继承该接口，我们写子类，想要实现Serializable接口，怎么去做呢？http://docs.oracle.com/javase/7/docs/api/ API Reference中有这样一段： During deserialization, the fields of non-serializable classes will be initialized using the public or protected no-arg constructor of the class. A no-arg constructor must be accessible to the subclass that is serializable. The fields of serializable subclasses will be restored from the stream. 如果说，子类要实现序列化，那么要求父类实现序列化，或者父类拥有无参构造函数。 父类实现序列化的方法已经验证过了，那么验证一下父类拥有无参构造函数的情况，修改Furit代码为： package Serializable; public class Fruit{ public String name; public float price; public Fruit(String name,float price){ this.name = name; this.price = price; } public Fruit(){ this.name = &quot;Default&quot;; this.price = 0.1f; } public void show(){}; } 同时，为Apple子类和Orange子类添加无参构造函数，运行结果为下： A apple named:Default price:0.1A orange named:Default price:0.1 在反序列化的时候，如果父类没有实现序列化，那么JVM调用了父类的无参构造函数，为子类中的父类对象进行了实例化。 3、修改默认的序列化机制：1）有数据不希望被序列化？ 使用默认的序列化策略，类中所有的数据域都会被序列化。但在实际使用的时候，很多的情况下我们是不希望数据被序列化的，这时候怎么办？在Java中有一个很简单的机制可以实现该目的，使用transient关键字。e.g. 我们将上面程序中的基类Fruitjava进行修改，改动如下： 改动之前 public String name; 改动之后 public transient String name; 其实改动很少，只是将 name 加上了 transient关键字，再次运行程序，结果如下： A apple named:null price:1.1A orange named:null price:2.2 达到目的，所有的名称都没有从文件中的反序列化中得到。默认值为null 2）自定义序列化的对象 如果希望完全在Serializable接口基础上实现自定义序列化，需要自己实现witeObject接口和readObject接口，同时，在调用writeObject接口的时候，要先调defaultWriteObject()来使得自定义的序列化仍然使用Java Serializable默认的机制，当然，在读取的时候，要先调用 defaultReadObject()，也是一样的道理。 e.g 我们可以对Fruit基类做如下的修改： private void writeObject(ObjectOutputStream out) throws IOException{ out.defaultWriteObject(); out.writeObject(name); out.writeFloat(price); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException{ in.defaultReadObject(); this.name = (String)in.readObject(); this.price = in.readFloat(); } 4、一个对象被多个对象共享的时候：比如将代码按下列修改 1)添加类Owner package Serializable;import java.io.Serializable;public class Owner implements Serializable{ public String name; public Owner(String name){ this.name = name; }} 2)修改Fruit基类，增加设置Owner属性 package Serializable; import java.io.Serializable; public class Fruit implements Serializable{ public String name; public float price; public Owner owner; public Fruit(String name,float price){ this.name = name; this.price = price; } public void setOwner(Owner owner){ this.owner = owner; } public Fruit(){ this.name = &quot;Default&quot;; this.price = 0.1f; } public void show(){}; } 3)修改测试程序，为每个Fruit设置Owner ObjectOutputStream op = new ObjectOutputStream(new FileOutputStream(new File(&quot;testSerializable&quot;))); Apple apple = new Apple(&quot;apple&quot;, 1.1f); Orange orange = new Orange(&quot;orange&quot;,2.2f); Owner owner = new Owner(&quot;Happy&quot;); apple.setOwner(owner); orange.setOwner(owner); op.writeObject(apple); op.writeObject(orange); op.close(); 程序运行结果不变，那我们观察生成的文件 ��sr\u0012Serializable.AppleD�\u0015[�\u001b�^\u0002xr\u0012Serializable.Fruit\u0010”=�l K\u0002\u0003FpriceL\u0004namet\u0012Ljava/lang/String;Lownert\u0014LSerializable/Owner;xp?���tapplesr\u0012Serializable.Owner\u001el[B0�\u0002\u0001L\u0004nameq~\u0002xptHappysr\u0013Serializable.Orange�[ɪ�pd�\u0002xq~\u0001@ ��t\u0006orangeq~ 可以发现，在内容中，Owner只是提到一次，也就是因为两个Fruit的指向了同一个Owner，因此在序列化保存中，只是将该对象保存了一次。 在Java核心技术中是这样解释这一部分内容的： 每个对象用是用一个序列号(serial number)保存的，在写入过程其算法为： 1、对遇到的每一个对象引用都关联了一个序列号 2、对每一个对象，当第一次遇到的时候，都保存其对象数据到流中。 3、如果某个对象在之前被保存过，那么只写出“与之前保存过的序列号为x的对象相同” 在读取的过程中，其算法为： 1、对于流程的对象，在第一次遇到其序列号的时候，构建它，并使用流中的数据来初始化它，然后记录这个顺序号和新对象之间的关联。 2、当遇到“与之前保存过的序列号为x的对象相同”标记时候，获取与这个顺序号想关联的对象引用。 Tips：因为序列化用序列号代替了内存地址，所有允许将对象集合从一台机器传送到另外一台机器。 5、版本管理：6、clone+serializable书签Java 二：Externable 1、使用： 2、与Serializable区别 三：Android序列化Parcelable 四：开源序列化接口：","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"系统调用","slug":"linux-system-call","date":"2013-07-06T10:51:21.000Z","updated":"2018-10-03T16:12:52.573Z","comments":true,"path":"2013/07/06/linux-system-call/","link":"","permalink":"http://yoursite.com/2013/07/06/linux-system-call/","excerpt":"","text":"1、什么是系统调用？系统调用是在用户空间进程和硬件设备之间添加了一个中间层。主要作用有： 1、为用户空间提供了一种硬件的抽象接口。用户只需要关心要实现的功能，而不需要关系底层是怎么样实现的。 2、保证了系统的安全和稳定。作为中间层，系统调用可以基于权限、用户类型和其他的一些规则对需要进行的访问进行裁决。 3、每个进程都运行在虚拟系统中，而在用户空间和系统的其他部分提供这样的一层公共接口，也是出于这样的考虑。如果应用程序可以随意访问硬件而内核又一无所知，那么几乎就没有办法实现多任务和虚拟内存。也就没法谈安全性和稳定性。 在Linux中，系统调用是用户空间访问内核的唯一的手段了；除了异常和陷入之外，系统调用是内核唯一的合法入口。 2、API、POSIX和C库的关系 在Unix的接口设计中，有这么一句话“提供体制(mechanism)而不是策略(policy)”，换句话就是说，Unix的系统调用抽象出来用与完成某种特定的目的的函数，至于这些函数怎么使用，则不需要内核去关心。。 3、系统调用系统调用(Linux下为syscall)，通过C库中定义的函数调用来进行。通常都需要定义零个、一个或者几个参数(输入) 如getpid()的系统调用，其定义的示例： SYSCALL_DEFINE(getpid){ return task_tgid_vnr(current); //return current-&gt;tgid} 定义中并不需要规定其是如何实现的，SYSCALL_DEFINE0为一个宏，定义了一个无参数的系统调用(数字为0),展开之后的代码为 asmlinkage long sys_getpid(void) 分析定义： 1) asmlinkage为限定词，为一个编译指令，通知编译器从栈中提取函数的参数。所有的系统调用都需要用到该限定词。 2)函数的返回值为long型，是出于兼容32位机器和64位机器的考虑。系统调用在用户空间和内核空间有不同的返回值类型，在用户空间其返回值的类型为int，在内核空间其返回值的类型为long。 3)最终，get_pid()在内核中被定义为 sys_getpid()。这是Linux中所有系统都遵守的命名规则。 1、系统调用号在Linux中每一个都有一个系统调用号，在用户空间的进程执行系统调用的时候，会通过这个系统调用号找到到底需要执行的是哪一个系统调用;用户空间的进程不会提及用户调用的名称。 系统调用号一旦被分配，则不能被修改，否则编译好的代码就会运行错误。同时，如果一个系统调用被删除，那么也不被允许被回收利用。(这两个注意到 地方的理解就在于，系统使用系统调用号来区别不同的系统调用的，如果可以的话，就会出现混乱)。在Linux中还有一个为实现的系统调用sys_ni_syscall()，除了返回-ENOSYS外不做任何工作，专门用来补缺。 内核将系统注册过的系统调用放在sys_call_table中，arch/x86/kernel/syscall_table_32.S 可以查看到x86体系结构下的系统调用表。 2、系统调用的性能Linux的系统调用的执行时间要比其他系统执行的快，原因： 1、较短的上下文切换的时间。 2、系统调用处理程序和每个系统调用本身都非常整洁。 4、系统调用处理程序由于内核是在受保护的地址空间上，因此用户空间是无法直接执行内核代码的，也不能直接调用内核空间的程序，所有Linux系统调用的实现是通过告知内核自己需要执行一个系统调用，然后切换到内核态，然后内核就可以代表应用程序在内核空间执行系统调用。 通知内核的机制则是通过软中断的方式来实现：引发一个异常，促使系统切换到内核态上去执行异常处理程序，此时的异常处理程序实际上就是系统调用的处理程序。 1、指定恰当的系统调用所有的系统调用陷入内核态的方法都是一样的，通过引发一个异常，是系统切换到内核态上去处理。所有还需要把系统调用号传送给内核，在X86中，系统调用好通过eax寄存器传送给内核。其他的体系结构也都是类似的。 system_call()程序通过给定的系统号，与NR_syscalls做比较检查其有效性。如果其大于或者等于NR_syscalls，则返回-ENOSYS。否则继续执行相应的系统调用。 2、参数传递参数的传递类似于系统号的传递，都是放在寄存器中，给用户空间的返回值也是类似。 5、怎么实现系统调用1、实现系统调用：1）明确系统调用的功能：在Linux中不提倡多用途的系统调用（同一个系统调用号，通过不同的传递的参数值来完成不同的工作） 2）明确系统调用的接口：新的系统调用的参数、返回值和错误码都是什么？系统调用接口应该追求 简洁、参数尽可能少。比如需要考虑功能多次改变会怎么样？新的功能能否可以追加到系统调用？是否可以容易的修订错误并且不会破坏向后兼容。 系统调用的标志，不是用来实现单个系统调用有多个不同的行为(如前所述，这是不允许的)，而是为了即使增加新的功能和选项的时候，也不会破坏向后兼容或者不需要增加新的系统调用。 在设计系统调用的时候，比如要考虑的，尽量为将来做多考虑：1)是不是对函数做了不必要的限制？系统调用设计的越通用越好，不能假设说，系统调用以后也会这么用，系统调用的目的不变，但用法可能会发生改变。2)系统调用是不是可移植的？不要对机器的字节长度和字节序做假设。 2、参数验证系统调用必须仔细检查传入的参数是否合法有效的。由于系统调用是在内核空间中运行，如果将不合法的参数传入内核，将会对系统的稳定性和安全性都产生极大的破坏。 e.g 与I/O相关的，需要检查文件描述符是否正确。与进程相关的，需要检查PID是否正确。 最重要的检查是检查指针是否合法有效。系统调用在接收用户空间的指针之前，内核需要保证： 1、指针区域指向的内存区域为用户空间。进程绝对不能哄骗内核去读取内核空间的内容。 2、指针区域指向的内存区域是在进程的地址空间里面。进程不能哄骗内核去读取其他进程的数据。 3、如果是读，需要标记内存区域是可读;如果写，则需要标志可写;如果可以执行，则内存被标记为可执行。进程不能够绕过内存内存的访问限制。 内核提供了两个放完来完成必须的检查，以及完成内核空间与用户空间的数据的来回拷贝。copy_to_user() 和 copy_from_user() copy_to_user() 向用户空间写入大的数据，3个参数：进程空间的目的内存地址;内核空间内的源地址;需要拷贝的数据长度(字节数)。 copy_from_user() 从用户空间读取数据 如果执行失败，这两个函数返回的都是没能够完成的拷贝的数据的字节数。如果成功，则返回0。如果出现错误，则返回的是标准 -EFFAULT。 范例：演示了 copy_to_user() copy_from_user()用法 SYSCALL_DEFINE3(silly_copy, unsigned long src, unsigned long dest, unsinged long len){ unsinged long buf; if (copy_from_user(&amp;buf , src, len)) return -EFAULT; if (copy_to_user(dst, &amp;buf, len)) return -EFAULT; return len;} 其中 copy_to_user() copy_from_user()都可能会引起系统阻塞。 检查是否具有合法的权限。在老版本使用suser()来完成，该版本只能检查用户是否为超级用户，现在被新版本更细粒度的取代。新的系统允许检查针对特定资源的特殊权限。可以通过调用capable()检查是否有权能够对指定的资源进行操作，如果返回非0,则可以操作，如果返回0,则无权操作。 比如说，使用capable(CAP_SYS_NICE)可以检查调用者是否具有更改其他进程nice的值的权限。 6、系统调用上下文内核在执行系统调用的时候，出于进程上下文。 current指针指向当前任务，即引发系统调用的那个进程。在进程上下文中，内核可以休眠，并且内核可以被其他进程抢占。 说明：1、能够休眠说明系统调用可以使用内核提供的绝大部分的功能。（中断不能休眠，所有绝大部分的工作都推迟到底半部执行。） 2、因为是在进程上下文中，进程可以被抢占，因此是新抢占的进程也可以调用该系统调用，因此要保证系统调用是可重入的。 1、绑定系统调用的其他操作 2、从用户空间访问系统调用 7、为什么尽量不通过系统调用的方式实现系统调用的优点： 1、系统调用容易创建且使用方便 2、Linux系统调用性能比较高 问题： 1、需要一个系统调用号，该调用号需要在开发阶段由官方分配 2、系统调用被加入稳定内核之后就固话了，其接口不允许改动。 3、需要将系统调用注册到每一个支持的体系中去。 4、脚本中不容易调用系统调用，也不能从文件系统直接访问系统调用。 。。。 替代方法： 实现一个设备节点，并实现write()和read()。使用ioctl()来对特定设备进行操作或者对特定信息进行检索。","categories":[{"name":"Linux内核设计与实现","slug":"Linux内核设计与实现","permalink":"http://yoursite.com/categories/Linux内核设计与实现/"},{"name":"读书笔记","slug":"Linux内核设计与实现/读书笔记","permalink":"http://yoursite.com/categories/Linux内核设计与实现/读书笔记/"}],"tags":[]},{"title":"Linux任务调度算法","slug":"linux-task-schedule","date":"2013-07-01T09:17:06.000Z","updated":"2018-10-03T14:32:22.225Z","comments":true,"path":"2013/07/01/linux-task-schedule/","link":"","permalink":"http://yoursite.com/2013/07/01/linux-task-schedule/","excerpt":"","text":"一、多任务概念多任务主要分为两类：非抢占式多任务(cooperative multitasking)和抢占式多任务(preemptive multitasking)。 概念：抢占(preemption)、进程的时间片(tineslice)、让步(yielding)、公平调度算法(CFS) 二、I/O消耗型和处理器消耗型进程I/O消耗型：这种任务应该经常处于可以运行的状态，并且每次都是运行短短的一段时间，因为其等待更多的IO请求的时候，经常会堵塞。 处理器消耗型：这种任务通常在不停的运行，比如说科学计算或者Matlab之类的，从调度的角度来考虑，不应该让他们经常运行，应该是降低调度的频率，延长其运行时间。 有一些任务分类比较模糊，既是I/O消耗型，也是处理器消耗型，比如X Windows服务。 调度的策略是在这两个矛盾中寻找平衡：进程相应迅速(响应时间短)和最大系统的利用率(高吞吐量)。而Unix的调度更倾向于I/O调度，以便于更好的提供程序的响应速度。 三、进程的优先级调度算法中最基本的一类是基于优先级的调度。通常的(Linux不采用)是优先级高的先运行，低的后运行，相同的优先级的进程按照轮转的方式进行调度，或者是优先级高的程序，其使用的时间片也比较长。调度程序总是选择时间片 没有用尽且优先级最高的进程来运行。 Linux有两种不同的优先级范围： 1)nice值:其范围为-20～19,默认值为0;nice值越大，代表优先级越低(可以理解，越nice，对其他的程序越友好，更容易让路，优先级越低)。在不同的Unix系统中，nice值的含义代表有所不同，在Mac OS X中，nice值代表了分配给进程的时间片的绝对值;Linux中，nice值代表了时间片的比例。使用ps -el看到的进程列表中的NI，就代表了时间片。 123456happyhls@happy-desktop:~$ ps -elF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD4 S 0 1 0 0 80 0 - 6117 poll_s ? 00:00:00 init1 S 0 2 0 0 80 0 - 0 kthrea ? 00:00:00 kthreadd1 S 0 3 2 0 80 0 - 0 run_ks ? 00:00:00 ksoftirqd/01 S 0 6 2 0 -40 - - 0 cpu_st ? 00:00:00 migration/0 2)实时优先级：实时优先级的范围是0～99,与nice相反，实时优先级的数值，数值越大，代表了其进程优先级也就越高。还有一点， 任何实时进程的优先级都要高于普通的进程。实时优先级和nice互不相干。调用 ps -eo state,uid,pid,ppid,rtprio,time,comm 12345678happyhls@happy-desktop:~$ ps -eo state,uid,pid,ppid,rtprio,time,commS UID PID PPID RTPRIO TIME COMMANDS 0 1 0 - 00:00:00 initS 0 2 0 - 00:00:00 kthreaddS 0 3 2 - 00:00:00 ksoftirqd/0S 0 6 2 99 00:00:00 migration/0S 0 7 2 99 00:00:00 watchdog/0S 0 8 2 99 00:00:00 migration/1 其中的RTPRIO就代表了实时优先级。如果为-，则代表不是实时优先级。 四、时间片时间片，表明进程在被抢占之前所能够持续运行的时间。调度策略需要规定一个默认的时间片，其中有一个相对的问题：如果时间片过长，会带来系统对交互响应的滞后，如果时间片过短，会带来更多的进程切换所带来的处理器耗时;同时I/O消耗型和处理器消耗型也有不同的需求，I/O消耗型，希望频繁的调度，但每次只要运行很短的时间，而处理器消耗型则希望每一个调度之后，都能够运行的时间越长越好，比如可以更好的提高高速缓存的命中。 一般的系统中，为了保证交互的流畅，一般都把时间片设置的比较小，而在Linux中，CFS调度是分配的比例给时间片，而非具体的时间。同时时间片还会受到nice值大小的影响。优先级更高的程序会有高的权重，而优先级比较低的程序，其时间片的权重也会比较低。 在大多数系统当中，一个进程是否可以进入运行状态，是其时间片和优先级决定的。而在Linux的CFS当中，抢占的时机取决于新的可运行程序使用了多少的处理器使用比，如果消耗的使用比当前的进程要小，新的进程立刻投入运行，否则则会推迟其运行。 五、调度策略的初步认识CFS在书的P38页，大体说明一下，有两个任务，一个是文本编辑器，另外一个任务是视频播放，可以明白的是，文本编辑器的任务是I/O消耗型的任务，而视频播放显然是处理器消耗型的任务。假设说这两个任务的优先级相同，nice值相同，那CFS是怎么调度的？ 其任务调度如下所示： 首先，两者优先级和nice均相同，因此系统会给这两个分配相同的CPU时间，都是50%，但是每次文本编辑器被唤醒之后，只运行很少的时间，就会放弃CPU，而视频播放则会在其被调度的时候，全力工作。因此运行一段时间后，CFS会发现，给文本处理器的时间是50%，但实际上其使用的时间要远远小于50%,为了保证公平，当文本编辑器被唤醒的时候，CFS会立刻抢占视频编码的进程，让文本处理器运行。简单的理解，给你的这次用不完，下次让你提前用。 六、Linux调度算法1、调度器类Linux调度器以模块化的方式提供，模块化结构称为调度器类(scheduler classes)，允许多种不同的可动态添加的调度算法并存，调度属于自己的范畴的进程。每一个调度器都有一个优先级，基础调度器(位于kernel/sched.c)会按照优先级遍历调度类，然后进行调度。CFS为针对普通进程的调度类，Linux称为SCHED_NORMAL，CFS算法实现在kernel/sched_fair.c 2、Unix传统进程调度的问题1)如果要将nice值对应到时间片上去，需要将nice单位值对应到处理器的绝对时间：这就会带来问题，比如是nice=0对应的时间为100ms，而nice=+20的时候，对应的是5ms，那么当两个任务的分别优先级为0和20的时候，两个任务的优先级分配是合理的;但如果此时两个任务都是nice=+20,这时候就会带来问题，这时候满足我们的初衷，就是两个任务都能够获得50%的任务时间，但这个时候的问题是，由于其nice值为+20;因此其5ms就会被调度一次，此时调度非常频繁，开销变大，而其nice很大，本身可能就是后台任务，这个时候这样频繁调度是不合理的。 2)相对nice值的问题。如果两个nice值分别为0和1,那么他们的时间片为100ms和95ms，几乎一样，但如果两个nice值为18和19,那么他们分别获得10ms和5ms的nice值，相差两倍的时间。(因此，一般nice都是使用相对值) 解决的办法就是：将nice值呈几何增加而不是算数增加 3)绝对的时间片是依赖于系统定时器的，而由于平台的不同，其系统定时器可能是10ms，也有可能是5ms，而且相邻的时间片的差值应该是系统定时器的整数倍。 解决的办法是：将nice值到时间片的映射与定时器节拍分离开来。 3、公平调度（CFS）CFS的出发点为：进程调度的效果应该就像系统具备一个理想中的完美的多任务处理器。 但由于系统调度时的任务抢占必然会有代价，因此CFS首先考虑任务调度系统性能不会受损。CFS的做法是允许每一个进程运行一段时间、循环轮转选择运行最小的进程作为一个运行的进程，而不是再采用分配给每个进程时间片的做法，CFS在所有的可运行进程总数的基础上计算出一个进程应该运行多久，而不是依靠nice的值来计算时间片。nice值在CFS中被作为进程获得的处理器运行比的权重：越高的nice(优先级越低)获得更低的处理器使用权重。相反，更低的nice值的进程获得更高的处理器使用权重。 CFS为了完美多任务中无线小调度周期的近似值设立了一个目标。称作“目标延时”，越小的调度周期有越好的交互性，同时也更加接近完美的多任务。但也要承担更高的切换代价和更差的系统总吞吐能力。（e.g如果目标延迟值为20ms，有两个任务，那么每个任务在抢占之前会运行10ms，如果有10个任务，那么每个任务在抢占之前会运行2ms） 此时又需要考虑一个问题，如果任务接近无线多个，那么每个任务的使用时间将无限接近于0,因此CFS引入了每个进程获得的时间片底线，也称作是最小粒度。默认情况下为1ms。 同时可以看到，nice值对于时间片是几何加权，而不是算数加权。任何nice值对应的是处理器的使用比，而不是绝对值。","categories":[{"name":"Linux内核设计与实现","slug":"Linux内核设计与实现","permalink":"http://yoursite.com/categories/Linux内核设计与实现/"},{"name":"读书笔记","slug":"Linux内核设计与实现/读书笔记","permalink":"http://yoursite.com/categories/Linux内核设计与实现/读书笔记/"}],"tags":[]},{"title":"Ubuntu 64位 android adb 无法使用的解决办法","slug":"ubuntu-adb-failed","date":"2013-07-01T02:36:51.000Z","updated":"2018-10-03T15:10:59.804Z","comments":true,"path":"2013/07/01/ubuntu-adb-failed/","link":"","permalink":"http://yoursite.com/2013/07/01/ubuntu-adb-failed/","excerpt":"","text":"实验室换了台电脑，配置高了，直接安装的64为的12.04的Ubuntu，慢慢的配置起来，但在配置Android的开发环境的时候却遇到了问题。 在执行adb命令的时候，一直无法执行，提示 No such file 一开始的时候，一直以为是usb的设备没有被识别到，因此才会无法链接设备，就参考Android Reference http://developer.android.com/tools/device.html 重新配置了一边，但还是各种问题。 后来file了一下adb，查看了一下属性，发现结果如下 happyhls@happy-desktop:~/tools/adt-bundle-linux-x86_64-20130522/sdk/platform-tools$ file adbadb: setuid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.8, not stripped 明白原因了，我下载的虽然是选中的64bit Linux的版本，但其中的adb工具仍然是32位的，当然无法正常运行的，找到原因了，问题也就好办起来。只需要安装ia32库就可以。 sudo apt-get install ia32-libs 好了，搞定，收工。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[]},{"title":"关于UNIX和Linux系统下SUID、SGID的解析(转载)","slug":"linux-suid-sgid","date":"2013-06-21T10:01:16.000Z","updated":"2018-10-03T14:53:16.550Z","comments":true,"path":"2013/06/21/linux-suid-sgid/","link":"","permalink":"http://yoursite.com/2013/06/21/linux-suid-sgid/","excerpt":"","text":"一篇写的很好的关于Linux用户权限的文章，原文地址 http://www.linuxeden.com/html/unix/20071031/36892.html 感谢原作者！ 由于用户在UNIX下经常会遇到SUID、SGID的概念，而且SUID和SGID涉及到系统安全，所以用户也比较关心这个问题。关于SUID、SGID的问题也经常有人提问，但回答的人一般答得不够详细，加上曾经回答过两个网友的问题，还查了一些资料，决定整理成本文，以供大家参考。限于本人的水平问题，文章中如果有不当之处，请广大网友指正。 一、UNIX下关于文件权限的表示方法和解析SUID 是 Set User ID, SGID 是 Set Group ID的意思。 UNIX下可以用ls -l 命令来看到文件的权限。用ls命令所得到的表示法的格式是类似这样的：-rwxr-xr-x 。下面解析一下格式所表示的意思。这种表示方法一共有十位： 9 8 7 6 5 4 3 2 1 0- r w x r - x r - x 第9位表示文件类型,可以为p、d、l、s、c、b和-： p表示命名管道文件 d表示目录文件 l表示符号连接文件 -表示普通文件 s表示socket文件 c表示字符设备文件 b表示块设备文件 第8-6位、5-3位、2-0位分别表示文件所有者的权限，同组用户的权限，其他用户的权限，其形式为rwx： r表示可读，可以读出文件的内容 w表示可写，可以修改文件的内容 x表示可执行，可运行这个程序 没有权限的位置用-表示 例子： ls -l myfile显示为： -rwxr-x— 1 foo staff 7734 Apr 05 17:07 myfile 表示文件myfile是普通文件，文件的所有者是foo用户，而foo用户属于staff组，文件只有1个硬连接，长度是7734个字节，最后修改时间4月5日17:07。 所有者foo对文件有读写执行权限，staff组的成员对文件有读和执行权限，其他的用户对这个文件没有权限。 如果一个文件被设置了SUID或SGID位，会分别表现在所有者或同组用户的权限的可执行位上。例如： 1、-rwsr-xr-x 表示SUID和所有者权限中可执行位被设置 2、-rwSr–r– 表示SUID被设置，但所有者权限中可执行位没有被设置 3、-rwxr-sr-x 表示SGID和同组用户权限中可执行位被设置 4、-rw-r-Sr– 表示SGID被设置，但同组用户权限中可执行位没有被社 其实在UNIX的实现中，文件权限用12个二进制位表示，如果该位置上的值是 1，表示有相应的权限： 11 10 9 8 7 6 5 4 3 2 1 0S G T r w x r w x r w x 第11位为SUID位，第10位为SGID位，第9位为sticky位，第8-0位对应于上面的三组rwx位。 11 10 9 8 7 6 5 4 3 2 1 0 上面的-rwsr-xr-x的值为： 1 0 0 1 1 1 1 0 1 1 0 1 -rw-r-Sr–的值为： 0 1 0 1 1 0 1 0 0 1 0 0 给文件加SUID和SUID的命令如下： chmod u+s filename #设置SUID位chmod u-s filename #去掉SUID设置chmod g+s filename #设置SGID位chmod g-s filename #去掉SGID设置 另外一种方法是chmod命令用八进制表示方法的设置。如果明白了前面的12位权限表示法也很简单。 二、SUID和SGID的详细解析由于SUID和SGID是在执行程序（程序的可执行位被设置）时起作用，而可执行位只对普通文件和目录文件有意义，所以设置其他种类文件的SUID和SGID位是没有多大意义的。 首先讲普通文件的SUID和SGID的作用。例子： 如果普通文件myfile是属于foo用户的，是可执行的，现在没设SUID位，ls命令显示如下： -rwxr-xr-x 1 foo staff 7734 Apr 05 17:07 myfile 任何用户都可以执行这个程序。UNIX的内核是根据什么来确定一个进程对资源的访问权限的呢？是这个进程的运行用户的（有效）ID，包括user id和group id。用户可以用id命令来查到自己的或其他用户的user id和group id。 除了一般的user id 和group id外，还有两个称之为effective 的id，就是有效id，上面的四个id表示为：uid，gid，euid，egid。内核主要是根据euid和egid来确定进程对资源的访问权限。 一个进程如果没有SUID或SGID位，则euid=uid egid=gid，分别是运行这个程序的用户的uid和gid。例如kevin用户的uid和gid分别为204和202，foo用户的uid和gid为200，201，kevin运行myfile程序形成的进程的euid=uid=204，egid=gid=202，内核根据这些值来判断进程对资源访问的限制，其实就是kevin用户对资源访问的权限，和foo没关系。 如果一个程序设置了SUID，则euid和egid变成被运行的程序的所有者的uid和gid，例如kevin用户运行myfile，euid=200，egid=201，uid=204，gid=202，则这个进程具有它的属主foo的资源访问权限。 SUID的作用就是这样：让本来没有相应权限的用户运行这个程序时，可以访问他没有权限访问的资源。passwd就是一个很鲜明的例子。 SUID的优先级比SGID高，当一个可执行程序设置了SUID，则SGID会自动变成相应的egid。 下面讨论一个例子： UNIX系统有一个/dev/kmem的设备文件，是一个字符设备文件，里面存储了核心程序要访问的数据，包括用户的口令。所以这个文件不能给一般的用户读写，权限设为：cr–r—– 1 root system 2, 1 May 25 1998 kmem 但ps等程序要读这个文件，而ps的权限设置如下： -r-xr-sr-x 1 bin system 59346 Apr 05 1998 ps 这是一个设置了SGID的程序，而ps的用户是bin，不是root，所以不能设置SUID来访问kmem，但大家注意了，bin和root都属于system组，而且ps设置了SGID，一般用户执行ps，就会获得system组用户的权限，而文件kmem的同组用户的权限是可读，所以一般用户执行ps就没问题了。但有些人说，为什么不把ps程序设置为root用户的程序，然后设置SUID位，不也行吗？这的确可以解决问题，但实际中为什么不这样做呢？因为SGID的风险比SUID小得多，所以出于系统安全的考虑，应该尽量用SGID代替SUID的程序，如果可能的话。下面来说明一下SGID对目录的影响。SUID对目录没有影响。如果一个目录设置了SGID位，那么如果任何一个用户对这个目录有写权限的话，他在这个目录所建立的文件的组都会自动转为这个目录的属主所在的组，而文件所有者不变，还是属于建立这个文件的用户。 三、关于SUID和SGID的编程和SUID和SGID编程比较密切相关的有以下的头文件和函数： uid_t getuid(void);uid_t geteuid(void);gid_t getgid (void);gid_t getegid (void);int setuid (uid_t UID);int setruid (uid_t RUID);int seteuid (uid_t EUID);int setreuid (uid_t RUID,uid_t EUID);int setgid (gid_t GID);int setrgid (gid_t RGID);int setegid (git_t EGID);int setregid (gid_t RGID, gid_t EGID); 具体这些函数的说明在这里就不详细列出来了,要用到的可以用man查。 SUID/SGID : 假如你有文件a.txt #ls -l a.txt-rwxrwxrwx #chmod 4777 a.txt-rwsrwxrwx ======&gt;注意s位置 #chmod 2777 a.txt-rwxrwsrwx ======&gt;注意s位置 #chmod 7777 a.txt-rwsrwxswt ======&gt;出现了t,t的作用在内存中尽量保存a.txt,节省系统再加载的时间. 现在再看前面设置 SUID/SGID作用: #cd /sbin #./lsusb… #su aaa(普通用户)$./lsusb… 是不是现在显示出错？ $su #chmod 4755 lsusb #su aaa$./lsusb … 现在明白了吗？本来是只有root用户才能执行的命令，加了SUID后,普通用户就可以像root一样的用，权限提升了。上面是对于文件来说的，对于目录也差不多！ 目录的S属性使得在该目录下创建的任何文件及子目录属于该目录所拥有的组，目录的T属性使得该目录的所有者及root才能删除该目录。还有对于s与S，设置SUID/SGID需要有运行权限，否则用ls -l后就会看到S,证明你所设置的SUID/SGID没有起作用。 Why we need suid,how do we use suid? r – 读访问 w – 写访问 x – 执行许可 s – SUID/SGID t – sticky位 那么 suid/sgid是做什么的？ 为什么会有suid位呢？ 要想明白这个，先让我们看个问题：如果让每个用户更改自己的密码？ 用户修改密码，是通过运行命令passwd来实现的。最终必须要修改/etc/passwd文件，而passwd的文件的属性是： #ls -l /etc/passwd -rw-r–r– 1 root root 2520 Jul 12 18:25 passwd 我们可以看到passwd文件只有对于root用户是可写的，而对于所有的他用户来说都是没有写权限的。 那么一个普通的用户如何能够通过运行passwd命令修改这个passwd文件呢？ 为了解决这个问题，SUID/SGID便应运而生。而且AT&amp;T对它申请了专利。 呵呵。 SUID和SGID是如何解决这个问题呢？ 首先，我们要知道一点：进程在运行的时候，有一些属性，其中包括 实际用户ID,实际组ID,有效用户ID,有效组ID等。 实际用户ID和实际组ID标识我们是谁，谁在运行这个程序,一般这2个字段在登陆时决定，在一个登陆会话期间， 这些值基本上不改变。 而有效用户ID和有效组ID则决定了进程在运行时的权限。内核在决定进程是否有文件存取权限时，是采用了进程的有效用户ID来进行判断的。 知道了这点，我们来看看SUID的解决途径： 当一个程序设置了为SUID位时，内核就知道了运行这个程序的时候，应该认为是文件的所有者在运行这个程序。即该程序运行的时候，有效用户ID是该程序的所有者。举个例子： [root@sgrid5 bin]# ls -l passwd -r-s–s–x 1 root root 16336 Feb 14 2003 passwd 虽然你以test登陆系统，但是当你输入passwd命令来更改密码的时候，由于passwd设置了SUID位，因此虽然进程的实际用户ID是test对应的ID，但是进程的有效用户ID则是passwd文件的所有者root的ID,因此可以修改/etc/passwd文件。 让我们看另外一个例子。 ping命令应用广泛，可以测试网络是否连接正常。ping在运行中是采用了ICMP协议，需要发送ICMP报文。但是只有root用户才能建立ICMP报文，如何解决这个问题呢？同样，也是通过SUID位来解决。 [root@sgrid5 bin]# ls -l /bin/ping -rwsr-sr-x 1 root root 28628 Jan 25 2003 /bin/ping 我们可以测试一下，如果去掉ping的SUID位，再用普通用户去运行命令，看会怎么样。 [root@sgrid5 bin]#chmod u-s /bin/ping[root@sgrid5 bin]# ls -l ping-rwxr-xr-x 1 root root 28628 Jan 25 2003 ping[root@sgrid5 bin]#su test[test@sgrid5 bin]$ ping byhh.netping: icmp open socket: Operation not permitted SUID虽然很好了解决了一些问题，但是同时也会带来一些安全隐患。 因为设置了 SUID 位的程序如果被攻击(通过缓冲区溢出等方面),那么hacker就可以拿到root权限。 因此在安全方面特别要注意那些设置了SUID的程序。 通过以下的命令可以找到系统上所有的设置了suid的文件： [root@sgrid5 /]# find / -perm -04000 -type f -ls 对于这里为什么是4000，大家可以看一下前面的st_mode的各bit的意义就明白了。 在这些设置了suid的程序里，如果用不上的，就最好取消该程序的suid位。","categories":[{"name":"Linux编程","slug":"Linux编程","permalink":"http://yoursite.com/categories/Linux编程/"}],"tags":[]},{"title":"Ubuntu下adb no permissions 问题解决办法","slug":"ubuntu-adb-no-permission","date":"2013-06-21T08:29:43.000Z","updated":"2018-10-03T15:12:07.870Z","comments":true,"path":"2013/06/21/ubuntu-adb-no-permission/","link":"","permalink":"http://yoursite.com/2013/06/21/ubuntu-adb-no-permission/","excerpt":"","text":"问题描述：不知道什么时候开始，在Ubuntu上执行adb的命令的时候，怎么也不成功，使用 adb devices 命令，发现结果如下： happy@happy-HP-Compaq-dx7518-MT:~$ adb devicesList of devices attached???????????? no permissions 查询发现，原来是adb没有权限的原因。 解决办法： 方法一：这个方案的比较简单sudo ./adb kill-serversudo ./adb start-server 给其赋予root权限就可以了。 方法二：更改adb权限方法一的办法确实比较简单，但每次都要这样操作就会变得比较麻烦，在http://stackoverflow.com上搜索，得到一下的解决方案，贴过来。原文 http://stackoverflow.com/questions/14460656/android-debug-bridge-adb-device-no-permissions 1.Setting ownership of the adb binary (owner – root, owner group - user_group): chown root:user_group adb 2.Setting permissions with SUID: chmod 4550 adb This should result something similar to this (ls -llh): -r-sr-x—. 1 root user_name 1.2M Jan 8 11:42 adb After that you will be able to run adb as a root, event though you’ll be using your normal user account. You can run Eclipse as a normal user and your HTC should be discovered properly. 简单说明，上面2个步骤就是提供了一种在普通用户权限执行时，也能拿到root权限的方法 第一步中，将adb程序的owner更改为root，用户组更改为自己的用户组。比如我自己的电脑用户名是happy，那么user_group的位置就写上happy 第二步中，设置程序的SUID 关于SUID的配置，可以详细见总结的文章 http://blog.happyhls.me/?p=453 这样子以后每次在普通用户下面运行adb程序的时候，都能够以root权限来运行。上面的方法在我的电脑上是可以的，我的系统是 No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 12.04.2 LTS Release: 12.04 Codename: precise","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[]},{"title":"Django admin 过滤数据 小结","slug":"django-admin-filter","date":"2013-06-18T10:27:20.000Z","updated":"2018-10-03T14:39:52.207Z","comments":true,"path":"2013/06/18/django-admin-filter/","link":"","permalink":"http://yoursite.com/2013/06/18/django-admin-filter/","excerpt":"","text":"最近时间在折腾Django，使用Django的主要原因是在于看中了其中的admin管理系统，其中好几处需要根据不同的账户过滤数据，现在总结一下： 1、models.Model过滤，根据用户过滤整个条目，只显示当前用户的内容，在admin.py的admin配置文件中： def queryset(self, request): qs = super(TaskAdmin, self).queryset(request) print qs\\[0\\].name if request.user.is_superuser: return qs return qs.filter(user=request.user) 该代码的作用：如果帐号是superuser的话，那么会显示所有的清单，但如果帐号不是superuser的话，则会只显示request.user的清单，此处 request.user就是登录的账户。 2、ManyToManyField过滤，主要是根据用户的不同，过滤model中的ManyToManyField ,只显示符合要求的内容 def formfield\\_for\\_manytomany(self, db_field, request, **kwargs): permission = UserAreaPermission.objects.filter(user=request.user) if db_field.name == &quot;area&quot; and len(permission): kwargs\\[&apos;queryset&apos;\\] = permission\\[0\\].area.all() if db_field.name == &quot;equipmentType&quot; and len(permission): kwargs\\[&apos;queryset&apos;\\] = permission\\[0\\].equipment.all() return super(TaskAdmin, self).formfield\\_for\\_manytomany(db_field, request, **kwargs) 该代码同样放在自定义的admin配置类中，该代码作用是过滤area和equipmentType","categories":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/categories/Django/"}],"tags":[]},{"title":"Django中给model增加view权限的方法","slug":"django-add-permission-check-to-view","date":"2013-06-18T10:23:26.000Z","updated":"2018-10-03T14:41:07.337Z","comments":true,"path":"2013/06/18/django-add-permission-check-to-view/","link":"","permalink":"http://yoursite.com/2013/06/18/django-add-permission-check-to-view/","excerpt":"","text":"django中的model默认有3中权限，add、change、del权限，但在使用中需要使用view权限，也就是只读(read only)权限，网上查了好多资料，现在将解决方法贴在这里，以备查询，参考链接 http://www.forrestliu.com/2011/03/25/Django-Admin-add-read-only-prem Django的权限是在admin.ModelAdmin中设置的，因此我们需要继承该类，并实现只读效果 首先，在工程中添加 view_model_admin.py，内容如下： from django.contrib import adminfrom django.contrib.auth.models import Permission class CustomModelAdmin(admin.ModelAdmin): def has\\_view\\_permission(self, request, obj=None): opts = self.opts view\\_permission = &apos;view\\_%s&apos; %self.model.\\_meta.module\\_name return request.user.has\\_perm(opts.app\\_label + &apos;.&apos; + view_permission) def has\\_change\\_permission(self, request, obj=None): if hasattr(self,&apos;has_change&apos;): if self.has_change: return True return super(CustomModelAdmin,self).has\\_change\\_permission(request, obj) def get\\_model\\_perms(self, request): value = super(CustomModelAdmin,self).get\\_model\\_perms(request) value\\[&apos;view&apos;\\] = self.has\\_view\\_permission(request) return value def changelist\\_view(self, request, extra\\_context=None): if self.has\\_view\\_permission(request, None): self.has_change = True result = super(CustomModelAdmin,self).changelist\\_view(request, extra\\_context) self.has_change = False return result 同时，在admin.py中，继承的类由 admin.ModelAdmin改为CustomModelAdmin 就可以了～ 后记：根据朋友的回复，我补充一下，在完成上面的步骤之后，权限的控制部分已经完成了，但这时候在后台中我们是没有办法看到只读权限的，这时候，需要我们进行一些手工操作。 打开数据库，有 auth_permission这样一个Table，观察会发现，默认情况下，Django已经为我们设计的每一个model都分配了 add ， change ，del权限，如： id name content_type_id codename19 Can add 区域 7 add_area20 Can change 区域 7 change_area21 Can delete 区域 7 delete_area 我们只要手动添加上View权限就可以，可以添加这样一个字段 id自动增长，不管;name = Can view 区域 ; content_type_id = 7 ; codename = view_area 解释一下，其中name是在后台中权限中看到的部分，content_type_id是Django为model分配的Id，在django_content_type中也可以查到，codename是在Django代码中作为识别权限用的，绝对不能填写错误。 根据文章的代码可以发现，此处是用view作为只读权限的关键字的，所有codename中，添加的是 view_area，其他以此类推。 写入数据库，再次登入后台，就可以看到该权限，并且使用了。 有一个使用环境，比如在后台中，如果字段中没有数据，而拥有add权限的话，是可以点击+立即添加的，但如果我们只给他分配view权限，那么就不会出现这个加号。","categories":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/categories/Django/"}],"tags":[]},{"title":"数组和指针的区别","slug":"c-difference-between-array-and-pointer","date":"2013-06-17T08:39:03.000Z","updated":"2018-10-03T16:12:52.545Z","comments":true,"path":"2013/06/17/c-difference-between-array-and-pointer/","link":"","permalink":"http://yoursite.com/2013/06/17/c-difference-between-array-and-pointer/","excerpt":"","text":"一：数组和指针可以相互替代吗？有这样两个定义： char *p = “abcd”; char data[] = “abcd”; 一直以来，以为数组和指针其实是相通的，也就是说，*(p+1)和data[1]是一样的，都能够取到字符’b’，从来没有考虑过内部是怎么实现的，这两天在看《C专家编程》，里面第4章的标题便是《令人震惊的事实：数组和指针并不相通》，那么实际上到底是怎么样的？大体归纳一下。 里面举了这样一个例子 文件1中有这样的定义： int mango[100]; 文件2中有这样的声明： extern int *mango; 到底能不能正常工作呢？按照之前的理解，数组和指针是通用的，所以感觉应该是一样的，但实际上去并不是这样，这段程序没办法得到理想的结果，怎么回事？ 这样分析： 对于数组来说，定义了变量 int mango[100];那么就意味着访问mango的时候，mango获取的地址指向的就是一个int的整数，而如果定义的是int * mango;的话，那么访问的时候，mango首先获取一个地址，该地址的内存中存有一个地址A，地址A中才是存放了int类型的变量。也就是说，适用指针来访问的时候，要多经过一步，才能够获取到实际的数据。 当然，其实上面这个例子在gcc下面是无法编译通过的，但可以更好的帮我们理解这个问题， int mango[100];和 extern int *mango;其类型是不相同的，不能够互相替代。 二、声明和定义到底有什么区别？1、声明和定义的区别在于：定义：只能出现在一个地方，确定对象的类型，并且为其分配内存，用来创建新的对象。 声明：可以多次出现，描述对象的类型，用来指代其他地方定义的对象。 换句话讲： 声明相当于普通的声明，其说明的并不是其本身，而是描述的其他的地方创建的对象 定义相当于特殊的声明，是为内存分配内存的。 理解： 因为声明不需要为内存分配空间，所以对于 int data[100];的声明 extern int data[];和extern int data[100]，其本质上是一样的。 2、左值和右值：有赋值表达式： X = Y;X是左值，在编译的时候可以知道，标识存储结果的地方; Y是右值，在运行的时候才能够知道，如果没有特殊的说明，标识“Y的内容”; 左值可以分为：可修改的左值 和 不可修改的左值，比如数组名，是不能被修改的，因此不能直接给数组名赋值。只能够给可以修改的东西来赋值。 3、如果定义的指针，但以数组来引用如果说有定义 char *p = “abcdefgh”; 那么在引用 *(p+i)的时候的，流程为 1、首先取得p的内存单元所保存的值，即5081,将5081作为地址 2、将5081+i作为新的地址 3、使用步骤2中得到的新的地址来获取数据内容 所以，这就很容易理解标题中出现的，如果定义成指针，但是一数组方式来引用的时候，会出现什么情况。 如上图所示，定义成指针的时候，p中保存的是保存这一组数据的内存单元的地址，但如果用数组的方式来引用的话，那么就会直接把4624作为数据的地址，那么如果取p[3]的时候，是从4624+3=4627的位置将数据取出，而此处的存储单元的定义是不明确的，因此也就不能确定程序到底取出了什么数据。就会出先莫名其妙的错误。 因此我们在使用的时候，要保证声明和定义是相互匹配的。 3、其他区别指针 数组 保存数据的地址 保存数据 间接的访问数据，首先取得指针的内容，把它作为地址，然后从这个地址提取数据。如果指针如果有一个下标[I]，将指针的内容加上I作为地址，从中提取数据 直接访问数据，a[I]只是简单的以a+I为地址取得数据 通常用于动态的数据结构 通常用于存储固定数目且数据类型相同的元素 相关的函数为malloc()，free() 隐式的分配和删除 通常指向匿名数据 自身就是数据名 在定义指针的时候，编译器不会为其指向的对象分配内存空间，仅仅分配的是内存本身的空间，当然除了一种情况。（在定义指针的时候，同时赋值给它一个字符串常量来初始化，除此之外没有其他情况）。 比如 char *p = “abcdefg”;编译器会为其分配存储空间的 但是float *p = 3.1415;编译器会报错！ 如下段代码 #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; int main(void){ char p = “abcdefgh”; float pp = 3.1415; return 0;} 在编译的时候会提示： test.c:7:14: 错误： 用‘double’初始化‘float *’时类型不兼容。","categories":[{"name":"C专家编程","slug":"C专家编程","permalink":"http://yoursite.com/categories/C专家编程/"},{"name":"读书笔记","slug":"C专家编程/读书笔记","permalink":"http://yoursite.com/categories/C专家编程/读书笔记/"}],"tags":[]},{"title":"一、进程管理","slug":"linux-process-management","date":"2013-06-09T08:12:20.000Z","updated":"2018-10-03T14:43:05.088Z","comments":true,"path":"2013/06/09/linux-process-management/","link":"","permalink":"http://yoursite.com/2013/06/09/linux-process-management/","excerpt":"","text":"一：进程和线程的概念：进程：是执行期间的程序，不仅仅局限于一段可执行的代码(text section)，还要包含其他的资源,eg.文件、挂起的信号量，数据，处理器状态等等。还有一个或者多个具有内存映射的内存地址空间或者一个或者多个执行线程(thread of execution)。全局变量的数据端。。。等等。进程也称做task 线程(thread)：进程中活动的对象，每个线程都有一个独立的程序计数器、进程栈、进程寄存器。线程是内核调度的对象。在Linux中，并不严格的区分线程和进程，一般而言，把线程看作一种特殊的进程。 二、进程描述符&amp;&amp;任务结构内核将进程列表放入任务队列中(task list)，为一个双向循环列表，每一项都是进程描述符(process descriptor)结构，类型为task_struct，该结构的定义位于 &lt;linux/sched.h&gt;，包含进程运行时的所有信息，占据内存1.7KB 1、分配进程描述符(1)、内容Linux通过slab分配器分配task_struct结构，slab在于实现快速进程创建，关于slab的详细介绍，有篇文章，记录一下https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/ 在&lt;asm/thread_info.h&gt;中有如下定义： struct thread_info { struct pcb_struct pcb; / palcode state / struct task_struct \\*task; /\\* main task structure */ unsigned int flags; /* low level flags */ unsigned int ieee_state; /* see fpu.h */ struct exec\\_domain \\*exec\\_domain; /\\* execution domain */ mm\\_segment\\_t addr_limit; /* thread address space */ unsigned cpu; /* current CPU */ int preempt_count; /* 0 =&gt; preemptable, &lt;0 =&gt; BUG */ int bpt_nsaved; unsigned long bpt_addr\\[2\\]; /* breakpoint handling */ unsigned int bpt_insn\\[2\\]; struct restart\\_block restart\\_block; }; slab分配器动态生成时，只需在(相应进程的内核进程栈)的栈顶(栈向上增长)或者栈底(栈向下增长)创建新的struct thread_info就可以。 e.g(向下增长) ___________________________________ |栈顶 | | |____ （当前堆栈指针） | | |struct task_struct *task （current_thread_info） (2)、存放系统需保存当前进程的task_struct，以备适用，因此在系统中提供了 current的宏，用来获取当前运行进程的task_struct结构体，但current的具体实现是不一样的，在X86之类 Reg比较紧张的处理器上，是在内核栈尾端创建thread_info结构，通过计算偏移，查找出task，而在PowerPC中，是通过专门寄存器来实现。 PID：Process Identification Value，用来标识唯一进程，在&lt;linux/threads.h&gt;中定义最大的数值，一般为32768, #define PID_MAX_DEFAULT (CONFIG_BASE_SMALL ? 0x1000 : 0x8000) 在使用中，可以通过修改 /proc/sys/kernel/pid_max来修改上限 2、进程的状态(1)、定义进程状态是task_struct中的一个定义，描述了该task的运行状态，定义如下： volatile long state; / -1 unrunnable, 0 runnable, &gt;0 stopped / 关于具体的状态，有如下定义 /* * Task state bitmask. NOTE! These bits are also * encoded in fs/proc/array.c: get_task_state(). * * We have two separate sets of flags: task-&gt;state * is about runnability, while task-&gt;exit_state are * about the task exiting. Confusing, but this way * modifying one set can’t modify the other one by * mistake. */ #define TASK_RUNNING 0 #define TASK_INTERRUPTIBLE 1 #define TASK_UNINTERRUPTIBLE 2 #define __TASK_STOPPED 4 #define __TASK_TRACED 8/* in tsk-&gt;exit_state */ #define EXIT_ZOMBIE 16 #define EXIT_DEAD 32/* in tsk-&gt;state again */ #define TASK_DEAD 64 #define TASK_WAKEKILL 128 #define TASK_WAKING 256 #define TASK_STATE_MAX 512 一一对应来看，Linux使用一个long类型的state数据来标识状态，如果为0,则说明当前的task是可执行的，如果state的值大于0,说明当前进程是停止的，通过和不同的状态相与就能找到具体是什么状态。其中，每一层的含义为: TASK_RUNNING /进程是可执行的：即程序或许正在执行，或者在运行队列中等待调度，是进程在用户空间中唯一可能的状态/ TASK_INTERRUPTIBLE /进程被阻塞，正在睡眠，并且是可中断的。当接收到相应的信号，就可以被唤醒并随时准备投入运行/ TASK_UNINTERRUPTIBLE /与TASK_INTERRUPTIBLE状态类似，但该种状态的时候，进程是不会对信号进行相应的，此时进程可能在进行必要的任务，必须等待/ 设置进程的状态，可以使用set_task_state(task,state)命令来实现。 注意：一般的程序在用户空间中执行，当程序执行了系统调用或者触发异常之后，该进程就陷入内核空间，称 内核“代表进程执行”并处于进程上下文中，在此时current宏是有效的，除非调度器调度了优先级更高的进程，否则内核退出时，会回复在用户空间继续执行。 (2)、进程家族树系统中，所有的进程都是PID为1的init进程的后代。系统中的每一个进程都有一个相应的父进程，同时，有可以拥有零个或者多个子进程。在&lt;linux/sched.h&gt;中的struct task_struct结构体的定义中，有这样一部分 /\\* \\* pointers to (original) parent process, youngest child, younger sibling, \\* older sibling, respectively. (p-&gt;father can be replaced with \\* p-&gt;real_parent-&gt;pid) */ struct task\\_struct \\*real\\_parent; /\\* real parent process */ struct task_struct \\*parent; /\\* recipient of SIGCHLD, wait4() reports */ /\\* \\* children/sibling forms the list of my natural children */ struct list_head children; /* list of my children */ struct list_head sibling; /* linkage in my parent&apos;s children list */ struct task\\_struct \\*group\\_leader; /\\* threadgroup leader */ 因此我们可以使用 struct task_struct *my_parent = current-&gt;parent; 来获取其父进程的进程描述符。 3、进程的创建1、总述：Unix进程的创建，将整个进程分解为fork()和exec()两个步骤，fork()通过拷贝当前的进程创建一个子进程。其与父进程的区别仅仅在于PID，PPID，一些资源和统计量(挂起的信号等等)。exec负责读取可执行文件并将其在于地址空间中运行， 2、写时拷贝传统的fork()是将所有的资源复制给新创建的进程。效率太低，比方说在子进程立刻创建新进程的时候，拷贝的这些数据都没有意义。Linux的fork()使用了写时拷贝的技术，所谓的写时拷贝，就是说，在复制的时候，内核不会复制整个进程的地址空间，在开始时候，数据都是只读方式共享的，只有在数据需要写入的时候，数据才会被复制到子进程当中，从而实现各个进程拥有自己的拷贝。这样以来，fork()函数的实际开销就在于复制父进程的页表，以及给子线程分配唯一 的进程描述符。 3、fork()Linux通过clone()系统调用去实现fork(),包括vfork(),__clone()也是如此，然后clone()去调用do_fork()，do_fork()负责完成权限的检查，然后调用copy_process()函数，再然后，开始运行程序。do_fork()代码如下 /* * Ok, this is the main fork-routine. * * It copies the process, and if successful kick-starts * it and waits for it to finish using the VM if required. /long do_fork(unsigned long clone_flags, unsigned long stack_start, struct pt_regs regs, unsigned long stack_size, int __user parent_tidptr, int __user child_tidptr){ struct task_struct *p; int trace = 0; long nr; /\\* \\* Do some preliminary argument and permissions checking before we \\* actually start allocating stuff */ if (clone\\_flags &amp; CLONE\\_NEWUSER) { if (clone\\_flags &amp; CLONE\\_THREAD) return -EINVAL; /\\* hopefully this check will go away when userns support is \\* complete */ if (!capable(CAP\\_SYS\\_ADMIN) || !capable(CAP_SETUID) || !capable(CAP_SETGID)) return -EPERM; } /\\* \\* Determine whether and which event to report to ptracer. When \\* called from kernel\\_thread or CLONE\\_UNTRACED is explicitly \\* requested, no event is reported; otherwise, report if the event \\* for the type of forking is enabled. */ if (likely(user\\_mode(regs)) &amp;&amp; !(clone\\_flags &amp; CLONE_UNTRACED)) { if (clone\\_flags &amp; CLONE\\_VFORK) trace = PTRACE\\_EVENT\\_VFORK; else if ((clone_flags &amp; CSIGNAL) != SIGCHLD) trace = PTRACE\\_EVENT\\_CLONE; else trace = PTRACE\\_EVENT\\_FORK; if (likely(!ptrace\\_event\\_enabled(current, trace))) trace = 0; } p = copy\\_process(clone\\_flags, stack\\_start, regs, stack\\_size, child_tidptr, NULL, trace); /\\* \\* Do this prior waking up the new thread - the thread pointer \\* might get invalid after that point, if the thread exits quickly. */ if (!IS_ERR(p)) { struct completion vfork; trace\\_sched\\_process_fork(current, p); nr = task\\_pid\\_vnr(p); if (clone\\_flags &amp; CLONE\\_PARENT_SETTID) put\\_user(nr, parent\\_tidptr); if (clone\\_flags &amp; CLONE\\_VFORK) { p-&gt;vfork_done = &amp;vfork; init_completion(&amp;vfork); } audit\\_finish\\_fork(p); /\\* \\* We set PF_STARTING at creation in case tracing wants to \\* use this to distinguish a fully live task from one that \\* hasn&apos;t finished SIGSTOP raising yet. Now we clear it \\* and set the child going. */ p-&gt;flags &amp;= ~PF_STARTING; wake\\_up\\_new_task(p); /\\* forking complete and child started to run, tell ptracer */ if (unlikely(trace)) ptrace_event(trace, nr); if (clone\\_flags &amp; CLONE\\_VFORK) { freezer\\_do\\_not_count(); wait\\_for\\_completion(&amp;vfork); freezer_count(); ptrace\\_event(PTRACE\\_EVENT\\_VFORK\\_DONE, nr); } } else { nr = PTR_ERR(p); } return nr; } 在copy_process()中， 完成以下的工作： (1)调用dup_task_struct()创建新的内核栈、thread_info、task_struct结构，并且与父进程相同 (2)各种检查数据范围 (3)设置子进程状态为TASK_UNINTERRUPTIBLE; (4)copy——process更新task_struct的flags成员 (5)alloc_pid为新进程分配有效PID (7)传递clone参数标志，扫尾工作，并返回指向子进程的指针。 4、vfork()除了不拷贝父进程的页表项，其他与fork相同 4、线程Linux中，没有单独的线程的概念，所有的线程都是特殊的进程 1、线程的创建其创建与进程一样，同样是调用clone系统调用来实现，只是在调用的时候，会通过传入一些标志参数来指明要共享的资源。 其系统调用为 clone(CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND,0) 而对比下的普通的fork()的实现是: clone(SIGCHLD,0) vfork()的实现是 clone(CLONE_VFORK|CLONE_VM|SIGCHLD,0) 所有的参数说明为。 /* * cloning flags: */ #define CSIGNAL 0x000000ff / signal mask to be sent at exit / #define CLONE_VM 0x00000100 / set if VM shared between processes / #define CLONE_FS 0x00000200 / set if fs info shared between processes / #define CLONE_FILES 0x00000400 / set if open files shared between processes / #define CLONE_SIGHAND 0x00000800 / set if signal handlers and blocked signals shared / #define CLONE_PTRACE 0x00002000 / set if we want to let tracing continue on the child too / #define CLONE_VFORK 0x00004000 / set if the parent wants the child to wake it up on mm_release / #define CLONE_PARENT 0x00008000 / set if we want to have the same parent as the cloner / #define CLONE_THREAD 0x00010000 / Same thread group? / #define CLONE_NEWNS 0x00020000 / New namespace group? / #define CLONE_SYSVSEM 0x00040000 / share system V SEM_UNDO semantics / #define CLONE_SETTLS 0x00080000 / create a new TLS for the child / #define CLONE_PARENT_SETTID 0x00100000 / set the TID in the parent / #define CLONE_CHILD_CLEARTID 0x00200000 / clear the TID in the child / #define CLONE_DETACHED 0x00400000 / Unused, ignored / #define CLONE_UNTRACED 0x00800000 / set if the tracing process can’t force CLONE_PTRACE on this clone / #define CLONE_CHILD_SETTID 0x01000000 / set the TID in the child //* 0x02000000 was previously the unused CLONE_STOPPED (Start in stopped state) and is now available for re-use. */ #define CLONE_NEWUTS 0x04000000 / New utsname group? / #define CLONE_NEWIPC 0x08000000 / New ipcs / #define CLONE_NEWUSER 0x10000000 / New user namespace / #define CLONE_NEWPID 0x20000000 / New pid namespace / #define CLONE_NEWNET 0x40000000 / New network namespace / #define CLONE_IO 0x80000000 / Clone io context / 2、内核线程(1)、创建内核线程 #define kthread_create(threadfn, data, namefmt, arg…) \\kthread_create_on_node(threadfn, data, -1, namefmt, ##arg) (2)、启动内核线程 #define kthread_run(threadfn, data, namefmt, …) \\({ \\struct task_struct *__k \\= kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \\if (!IS_ERR(__k)) \\wake_up_process(k); \\ k; \\})","categories":[{"name":"Linux内核设计与实现","slug":"Linux内核设计与实现","permalink":"http://yoursite.com/categories/Linux内核设计与实现/"},{"name":"读书笔记","slug":"Linux内核设计与实现/读书笔记","permalink":"http://yoursite.com/categories/Linux内核设计与实现/读书笔记/"}],"tags":[]},{"title":"Django 笔记：一、工程部署;模板(template)的使用","slug":"django-template-useage","date":"2013-04-23T06:28:11.000Z","updated":"2018-10-03T14:41:39.630Z","comments":true,"path":"2013/04/23/django-template-useage/","link":"","permalink":"http://yoursite.com/2013/04/23/django-template-useage/","excerpt":"","text":"最近在捣腾Django，把过程记录一下，方便以后查找 1、新建工程和部署 django installdjango-admin.py startproject Testdjango-admin.py startapp blogvim settings.py app add—–&gt;blogvim urls.py add—&gt;url(r’^blog/index/$’,’blog.views.index’)vim blog/views.py from django.http import HttpResponse def index(req): return HttpResponse(&apos;&lt;h1&gt;Hello&lt;/h1&gt;&apos;) 笔记： django的安装比较简单，下载源代码后，解压，sudo python setup.py install 就可以完成 django-admin.py startproject Test 该命令是为了建立一个新的django工程 名字为Test django-admin.py startapp blog 该命令则是在在当前目录下面建立新的app，名字为blog 剩下部分则是django的核心，首先，我们要在当前的project中，加入新建的app，主要是在setting.py中进行设置。当django接受到Http请求之后，会首先分析其URL，就是我们在urls.py中所配置的，然后根据配置，找到相应的view，然后将内容显示出来。 既然分析到这，好好看一下官方的documents，https://docs.djangoproject.com/en/1.5/topics/http/urls/ http://www.w3.org/Provider/Style/URI该链接里面一个讲URL规范的，怎么的URL才叫好的URL，现在自己太搓，记一下，回头再看。 2、第二个视频，则主要讲了django的模板， 里面有一个工具特别好用，bluefish，后来一搜索，原来是很多搞Web专用的。 模板的主要用法，则是，首先新建一个模板 比如 blog/templates/index.html，其内容如下： &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; TitleBody Here 然后修改 blog目录下的view.py，方法一为 from django.http import HttpResponsefrom django.template import loader,Context def index(req): t=loader.get_template(&apos;index.html&apos;) c=Context({}) return HttpResponse(t.render(c)); 简单理解，就是导入模板，导入上下文，然后使用模板中的render函数进行渲染，然后呈现出来。 方法二 from django.http import HttpResponsefrom django.shortcuts import render_to_response def index(req): return render_to_response(‘index.html’,{}) 该方法则是上面方法的简化，使用django.shortcuts类中的render_to_response方法，第一个参数为模板文件，而第二个函数为渲染的上下文。 3、模板的变量 在模板文件(一般*.html文件中)使用{ {}}来表示变量，然后在render中传递过去如，首先将模板文件修改为： &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; { {title}}Hello { {user}} 而视图文件views.py from django.http import HttpResponsefrom django.shortcuts import render_to_response def index(req): c={‘title’:”title”,’user’:’Happy’} return render_to_response(‘index.html’,c) 注意到，这是后，我们传进去的是一个字典，而html中都是直接显示的，而字典中中的值，有可以是字典，所以我们进一步修改。 同样的，作为基本类型，列表也是可以被作为参数传入模板中， 同样的，还可以将类的方法传入模板，需要注意的，此时的方法，为无参方法，同时，该方法需要有返回值，综合以上几个，可以进行以下的修改。 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Strict//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; { {title}}Hello { {user.name}}Age: { {user.age}}Sex: { {user.sex}}{ {user.name}} say:{ {user.say}}List0:{ {list.0}}List1:{ {list.1}} 视图文件为 from django.http import HttpResponsefrom django.shortcuts import render_to_response class Person: def \\_\\_init\\_\\_(self,name,age,sex): self.name=name self.age=age self.sex=sex def say(self): return &quot;Haha!&quot; def index(req): tom=Person(‘Tom’,2,’Male’) mylist=[‘list1’,’list2’] c={‘title’:”title”,’user’:tom,’list’:mylist} return render_to_response(‘index.html’,c) 最终运行的程序结果为： Hello Tom Age: 2 Sex: Male Tom say:Haha! List0:list1 List1:list2","categories":[{"name":"Django","slug":"Django","permalink":"http://yoursite.com/categories/Django/"}],"tags":[]},{"title":"Python正则表达式指南(转载)","slug":"python-regex-repost","date":"2013-04-20T13:14:33.000Z","updated":"2018-10-03T15:10:01.860Z","comments":true,"path":"2013/04/20/python-regex-repost/","link":"","permalink":"http://yoursite.com/2013/04/20/python-regex-repost/","excerpt":"","text":"感谢原作者，这是写的超级好的一篇Python的正则表达式，转载过来，以备查找。 原文链接 http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html 本文介绍了Python对于正则表达式的支持，包括正则表达式基础以及Python正则表达式标准库的完整介绍及使用示例。本文的内容不包括如何编写高效的正则表达式、如何优化正则表达式，这些主题请查看其他教程。 注意：本文基于Python2.4完成；如果看到不明白的词汇请记得百度谷歌或维基，whatever。 尊重作者的劳动，转载请注明作者及原文地址 1. 正则表达式基础1.1. 简单介绍正则表达式并不是Python的一部分。正则表达式是用于处理字符串的强大工具，拥有自己独特的语法以及一个独立的处理引擎，效率上可能不如str自带的方法，但功能十分强大。得益于这一点，在提供了正则表达式的语言里，正则表达式的语法都是一样的，区别只在于不同的编程语言实现支持的语法数量不同；但不用担心，不被支持的语法通常是不常用的部分。如果已经在其他语言里使用过正则表达式，只需要简单看一看就可以上手了。 下图展示了使用正则表达式进行匹配的流程： 正则表达式的大致匹配过程是：依次拿出表达式和文本中的字符比较，如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。如果表达式中有量词或边界，这个过程会稍微有一些不同，但也是很好理解的，看下图中的示例以及自己多使用几次就能明白。 下图列出了Python支持的正则表达式元字符和语法： 1.2. 数量词的贪婪模式与非贪婪模式正则表达式通常用于在文本中查找匹配的字符串。Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。例如：正则表达式”ab“如果用于查找”abbbc”，将找到”abbb”。而如果使用非贪婪的数量词”ab?”，将找到”a”。 1.3. 反斜杠的困扰与大多数编程语言相同，正则表达式里使用”\\“作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符”\\“，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\\\\\\“：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r”\\\\”表示。同样，匹配一个数字的”\\\\d”可以写成r”\\d”。有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。 1.4. 匹配模式正则表达式提供了一些可用的匹配模式，比如忽略大小写、多行匹配等，这部分内容将在Pattern类的工厂方法re.compile(pattern[, flags])中一起介绍。 2. re模块2.1. 开始使用rePython通过re模块提供对正则表达式的支持。使用re的一般步骤是先将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。 # encoding: UTF-8import re # 将正则表达式编译成Pattern对象pattern = re.compile(r’hello’) # 使用Pattern匹配文本，获得匹配结果，无法匹配时将返回Nonematch = pattern.match(‘hello world!’) if match: # 使用Match获得分组信息 print match.group() ### 输出 #### hello re.compile(strPattern[, flag]): 这个方法是Pattern类的工厂方法，用于将字符串形式的正则表达式编译为Pattern对象。 第二个参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如re.I | re.M。另外，你也可以在regex字符串中指定模式，比如re.compile(‘pattern’, re.I | re.M)与re.compile(‘(?im)pattern’)是等价的。 可选值有： re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同） M(MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图） S(DOTALL): 点任意匹配模式，改变’.’的行为 L(LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定 U(UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性 X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。以下两个正则表达式是等价的： a = re.compile(r”””\\d + # the integral part \\. # the decimal point \\d # some fractional digits”””, re.X)b = re.compile(r”\\d+\\.\\d“) re提供了众多模块方法用于完成正则表达式的功能。这些方法可以使用Pattern实例的相应方法替代，唯一的好处是少写一行re.compile()代码，但同时也无法复用编译后的Pattern对象。这些方法将在Pattern类的实例方法部分一起介绍。如上面这个例子可以简写为： m = re.match(r’hello’, ‘hello world!’)print m.group() re模块还提供了一个方法escape(string)，用于将string中的正则表达式元字符如*/+/?等之前加上转义符再返回，在需要大量匹配元字符时有那么一点用。 2.2. MatchMatch对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。 属性： string: 匹配时使用的文本。 re: 匹配时使用的Pattern对象。 pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。 endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。 lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。 lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。 方法： group([group1, …]): 获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。 groups([default]): 以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。 groupdict([default]): 返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。 start([group]): 返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。 end([group]): 返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。 span([group]): 返回(start(group), end(group))。 expand(template): 将匹配到的分组代入template中然后返回。template中可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\\id与\\g是等价的；但\\10将被认为是第10个分组，如果你想表达\\1之后是字符’0’，只能使用\\g0。 import rem = re.match(r’(\\w+) (\\w+)(?P.*)’, ‘hello world!’) print “m.string:”, m.stringprint “m.re:”, m.reprint “m.pos:”, m.posprint “m.endpos:”, m.endposprint “m.lastindex:”, m.lastindexprint “m.lastgroup:”, m.lastgroup print “m.group(1,2):”, m.group(1, 2)print “m.groups():”, m.groups()print “m.groupdict():”, m.groupdict()print “m.start(2):”, m.start(2)print “m.end(2):”, m.end(2)print “m.span(2):”, m.span(2)print r”m.expand(r’\\2 \\1\\3’):”, m.expand(r’\\2 \\1\\3’) ### output #### m.string: hello world!# m.re: &lt;_sre.SRE_Pattern object at 0x016E1A38&gt;# m.pos: 0# m.endpos: 12# m.lastindex: 3# m.lastgroup: sign# m.group(1,2): (‘hello’, ‘world’)# m.groups(): (‘hello’, ‘world’, ‘!’)# m.groupdict(): {‘sign’: ‘!’}# m.start(2): 6# m.end(2): 11# m.span(2): (6, 11)# m.expand(r’\\2 \\1\\3’): world hello! 2.3. PatternPattern对象是一个编译好的正则表达式，通过Pattern提供的一系列方法可以对文本进行匹配查找。 Pattern不能直接实例化，必须使用re.compile()进行构造。 Pattern提供了几个可读属性用于获取表达式的相关信息： pattern: 编译时用的表达式字符串。 flags: 编译时用的匹配模式。数字形式。 groups: 表达式中分组的数量。 groupindex: 以表达式中有别名的组的别名为键、以该组对应的编号为值的字典，没有别名的组不包含在内。 import rep = re.compile(r’(\\w+) (\\w+)(?P.*)’, re.DOTALL) print “p.pattern:”, p.patternprint “p.flags:”, p.flagsprint “p.groups:”, p.groupsprint “p.groupindex:”, p.groupindex ### output #### p.pattern: (\\w+) (\\w+)(?P.*)# p.flags: 16# p.groups: 3# p.groupindex: {‘sign’: 3} 实例方法[ | re模块方法]： match(string[, pos[, endpos]]) | re.match(pattern, string[, flags]): 这个方法将从string的pos下标处起尝试匹配pattern；如果pattern结束时仍可匹配，则返回一个Match对象；如果匹配过程中pattern无法匹配，或者匹配未结束就已到达endpos，则返回None。 pos和endpos的默认值分别为0和len(string)；re.match()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。 注意：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符’$’。 示例参见2.1小节。 search(string[, pos[, endpos]]) | re.search(pattern, string[, flags]): 这个方法用于查找字符串中可以匹配成功的子串。从string的pos下标处起尝试匹配pattern，如果pattern结束时仍可匹配，则返回一个Match对象；若无法匹配，则将pos加1后重新尝试匹配；直到pos=endpos时仍无法匹配则返回None。 pos和endpos的默认值分别为0和len(string))；re.search()无法指定这两个参数，参数flags用于编译pattern时指定匹配模式。 # encoding: UTF-8import re # 将正则表达式编译成Pattern对象pattern = re.compile(r’world’) # 使用search()查找匹配的子串，不存在能匹配的子串时将返回None# 这个例子中使用match()无法成功匹配match = pattern.search(‘hello world!’) if match: # 使用Match获得分组信息 print match.group() ### 输出 #### world split(string[, maxsplit]) | re.split(pattern, string[, maxsplit]): 按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。 import re p = re.compile(r’\\d+’)print p.split(‘one1two2three3four4’) ### output #### [‘one’, ‘two’, ‘three’, ‘four’, ‘’] findall(string[, pos[, endpos]]) | re.findall(pattern, string[, flags]): 搜索string，以列表形式返回全部能匹配的子串。 import re p = re.compile(r’\\d+’)print p.findall(‘one1two2three3four4’) ### output #### [‘1’, ‘2’, ‘3’, ‘4’] finditer(string[, pos[, endpos]]) | re.finditer(pattern, string[, flags]): 搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。 import re p = re.compile(r’\\d+’)for m in p.finditer(‘one1two2three3four4’): print m.group(), ### output #### 1 2 3 4 sub(repl, string[, count]) | re.sub(pattern, repl, string[, count]): 使用repl替换string中每一个匹配的子串后返回替换后的字符串。 当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。 当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。 count用于指定最多替换次数，不指定时全部替换。 import re p = re.compile(r’(\\w+) (\\w+)’)s = ‘i say, hello world!’ print p.sub(r’\\2 \\1’, s) def func(m): return m.group(1).title() + &apos; &apos; + m.group(2).title() print p.sub(func, s) ### output #### say i, world hello!# I Say, Hello World! subn(repl, string[, count]) |re.sub(pattern, repl, string[, count]): 返回 (sub(repl, string[, count]), 替换次数)。 import re p = re.compile(r’(\\w+) (\\w+)’)s = ‘i say, hello world!’ print p.subn(r’\\2 \\1’, s) def func(m): return m.group(1).title() + &apos; &apos; + m.group(2).title() print p.subn(func, s) ### output #### (‘say i, world hello!’, 2)# (‘I Say, Hello World!’, 2) 以上就是Python对于正则表达式的支持。熟练掌握正则表达式是每一个程序员必须具备的技能，这年头没有不与字符串打交道的程序了。笔者也处于初级阶段，与君共勉，^_^ 另外，图中的特殊构造部分没有举出例子，用到这些的正则表达式是具有一定难度的。有兴趣可以思考一下，如何匹配不是以abc开头的单词，^_^ 全文结束","categories":[{"name":"Python编程","slug":"Python编程","permalink":"http://yoursite.com/categories/Python编程/"}],"tags":[]},{"title":"Java IO 之三:File、RandomAccessFile、重定向输入输出","slug":"java-io-file-randomaccessfile","date":"2013-04-05T13:07:43.000Z","updated":"2018-10-03T15:09:02.790Z","comments":true,"path":"2013/04/05/java-io-file-randomaccessfile/","link":"","permalink":"http://yoursite.com/2013/04/05/java-io-file-randomaccessfile/","excerpt":"","text":"一、File类 在Java中，有一个File类，专门用来处理和文件或者文件夹相关的事情，其包含的方法有很多，这里就不一一列出，链接在http://docs.oracle.com/javase/7/docs/api/java/io/File.html ，在前两篇文章中也很多地方用到了File类，不多提，有时间将平时封装好的File类贴过来。 二、RandomAccessFile 该类就是说，我们可以随机读写文件的数据。我们要注意，该类不是InputStream的子类！其构造函数有两个 **[RandomAccessFile](http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html#RandomAccessFile(java.io.File, java.lang.String))**([File](http://docs.oracle.com/javase/7/docs/api/java/io/File.html &quot;class in java.io&quot;) file, [String](http://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) mode) Creates a random access file stream to read from, and optionally to write to, the file specified by the File argument. **[RandomAccessFile](http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html#RandomAccessFile(java.lang.String, java.lang.String))**([String](http://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) name, [String](http://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) mode) Creates a random access file stream to read from, and optionally to write to, a file with the specified name. 查看RandomAccessFile的源文件，我们可以发现 public RandomAccessFile(String name, String mode) throws FileNotFoundException { this(name != null ? new File(name) : null, mode); } **[RandomAccessFile](http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html#RandomAccessFile(java.lang.String, java.lang.String))**([String](http://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) name, [String](http://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) mode)构造函数也是调用的第一个构造函数。 传入的mode一个有4中选择 Value Meaning “r” Open for reading only. Invoking any of the write methods of the resulting object will cause an IOException to be thrown. “rw” Open for reading and writing. If the file does not already exist then an attempt will be made to create it. “rws” Open for reading and writing, as with “rw”, and also require that every update to the file’s content or metadata be written synchronously to the underlying storage device. “rwd” Open for reading and writing, as with “rw”, and also require that every update to the file’s content be written synchronously to the underlying storage device. 其中’r’,’rw’两个参数比较容易理解，主要是看一下 ‘rws’,’rwd’的区别是什么？ 看定义来说，都是rws是要求每一个更新或者元数据都要同步到底层的存储设备，而rwd是同步每一个更新到底层的存储设备，还是不明白到底区别是什么？从源码里面找一找。 在**[RandomAccessFile](http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html#RandomAccessFile(java.io.File, java.lang.String))**([File](http://docs.oracle.com/javase/7/docs/api/java/io/File.html &quot;class in java.io&quot;) file, [String](http://docs.oracle.com/javase/7/docs/api/java/lang/String.html &quot;class in java.lang&quot;) mode)构造函数中，我们发现 字符类型的mode传入之后，首先会被处理一下，其关系如下： ‘r’ :O_RDONLY=1=(byte)00000001 ‘rw’:O_RDWR=2=(byte)00000010 ‘rws’:O_RDWR|O_SYNC=2|4=(byte)00000110 ‘rwd’:O_RDWR|O_DSYNC=2|8=(byte)00001010 有些眉目了吧，再往下看，在构造函数的最后，程序调用了一个 open(name,imode) 看一下该函数的声明吧 private native void open(String name, int mode) throws FileNotFoundException; 调用了底层函数，好了，下一步不知道怎么找了，不过再仔细想想，底层的话，Linux自带的系统库中也有open函数，别的不说，mode的属性定义应该是相似的把，我们查查，调用 man 2 open 看到里面找到这么一段 POSIX provides for three different variants of synchronized I/O, corresponding to the flags O_SYNC, O_DSYNC, and O_RSYNC. Currently (2.6.31), Linux only implements O_SYNC, but glibc maps O_DSYNC and O_RSYNC to the same numerical value as O_SYNC. Most Linux file systems don’t actually implement the POSIX O_SYNC semantics, which require all metadata updates of a write to be on disk on returning to userspace, but only the O_DSYNC semantics, which require only actual file data and metadata necessary to retrieve it to be on disk by the time the system call returns. 好了，大体明白了，POSIX标准中总共只是三种不同的I/O同步模式，O_SYNC,O_DSYNC,O_RSYNC,并且在Linux2.6.31版本的内核上，该三种同步模式，其实际上的实现是一致的，大体明白了，就是同步的属性，但是有metadata和没有这个的区别在于什么呢？ 但还是不太明白到底是怎么回事，继续谷歌，关键字 POSIX，O_SYNC,O_DSYNC,找到这样一片文章 http://www.taobaodba.com/html/326_innodb_flush_method-%E4%B8%8E-linux-file-io.html 里面有一段： O_DSYNC告诉内核，当向文件写入数据的时候，只有当数据写到了磁盘时，写入操作才算完成（write才返回成功）。和O_DSYNC同类的文件标志，还有O_SYNC,O_RSYNC，O_DIRECT。 O_SYNC比O_DSYNC更严格，不仅要求数据已经写到了磁盘，而且对应的数据文件的属性（例如文件长度等）也需要更新完成才算write操作成功。可见O_SYNC较之O_DSYNC要多做一些操作。 O_RSYNC表示文件读取时，该文件的OS cache必须已经全部flush到磁盘了【附录3】； 如果使用O_DIRECT打开文件，则读/写操作都会跳过OS cache，直接在device（disk）上读/写。因为没有了OS cache，所以会O_DIRECT降低文件的顺序读写的效率。 好了，这样子就搞懂是怎么回事了，搞定。（心里面有个小小的疑问，Java的底层native库编译的库是怎么编译的呢？在Linux基础上是不是就是依赖于Linux的系统库呢？那是不是实际在Linux上使用Java的时候 O_DSYNC,和O_SYNC也是没有区别的呢？）。 在RandomAccessFile的其他方法中，我们基本上都比较熟悉，注意下面几个 RandomAccessFile实际上是使用Channel来实现的，而Channel和Buffer是Java NIO中重要的一个内容，有时间继续写一些，getFilePointer()函数则返回当前的指针。 [FileChannel](http://docs.oracle.com/javase/7/docs/api/java/nio/channels/FileChannel.html &quot;class in java.nio.channels&quot;) **[getChannel](http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html#getChannel())**() Returns the unique FileChannel object associated with this file. [FileDescriptor](http://docs.oracle.com/javase/7/docs/api/java/io/FileDescriptor.html &quot;class in java.io&quot;) **[getFD](http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html#getFD())**() Returns the opaque file descriptor object associated with this stream. long **[getFilePointer](http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html#getFilePointer())**() Returns the current offset in this file. RandomAccessFile顾名思义，关键就在于要随机读写，不能制定位置怎么行，下面几个就可以用的到。 void **[seek](http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html#seek(long))**(long pos) Sets the file-pointer offset, measured from the beginning of this file, at which the next read or write occurs. void **[setLength](http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html#setLength(long))**(long newLength) Sets the length of this file. int **[skipBytes](http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html#skipBytes(int))**(int n) Attempts to skip over n bytes of input discarding the skipped bytes. read和readFullly的区别是什么，除了表面上的意思有什么什么细微的区别， int **[read](http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html#read(byte[]))**(byte[] b) Reads up to b.length bytes of data from this file into an array of bytes. int **[read](http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html#read(byte[], int, int))**(byte[] b, int off, int len) Reads up to len bytes of data from this file into an array of bytes. void **[readFully](http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html#readFully(byte[]))**(byte[] b) Reads b.length bytes from this file into the byte array, starting at the current file pointer. void **[readFully](http://docs.oracle.com/javase/7/docs/api/java/io/RandomAccessFile.html#readFully(byte[], int, int))**(byte[] b, int off, int len) Reads exactly len bytes from this file into the byte array, starting at the current file pointer. 看一下定义 public int read(byte[] b) throws IOException Reads up to b.length bytes of data from this file into an array of bytes. This method blocks until at least one byte of input is available.Although RandomAccessFile is not a subclass of InputStream, this method behaves in exactly the same way as the InputStream.read(byte[])) method ofInputStream. 虽然说RandomAccessFile不是InputStream的子类，但在read(byte[] b)使用上和InputStream中的该函数是一样的，调用该函数后会读取数据到数组中，如果没有数据便会一直阻塞，知道有数据过来。 public final void readFully(byte[] b) throws IOException Reads b.length bytes from this file into the byte array, starting at the current file pointer. This method reads repeatedly from the file until the requested number of bytes are read. This method blocks until the requested number of bytes are read, the end of the stream is detected, or an exception is thrown. 看到这里就明白了，该方法会一直阻塞，知道byte[] b这个数组读满了，看看源文件呢？里面调用的是本地库，我们现在主要是去学习Java，所以JVM里面怎么实现的我们就先不去关注了，好了，明白区别也就可以放心的使用了。 package InputStream; import java.io.EOFException;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.RandomAccessFile; public class TestRandomAccessFile { public static void main(String[] args) { RandomAccessFile randomAccessFile; try { long startTime; File file=new File(“TestRandomAccessFile.data”); if(file.exists()) file.delete(); randomAccessFile=new RandomAccessFile(“TestRandomAccessFile.data”,”rwd”); startTime=System.currentTimeMillis(); randomAccessFile.writeChar(&apos;A&apos;); System.out.println(&quot;打开同步，每个char类型，写入耗时：&quot;+(System.currentTimeMillis()-startTime)+&quot;ms&quot;); startTime=System.currentTimeMillis(); for(char i=33;i&lt;127;i++) { randomAccessFile.writeChar(i); } System.out.println(&quot;打开同步，写入127-33个字符耗时：&quot;+(System.currentTimeMillis()-startTime)+&quot;ms&quot;); startTime=System.currentTimeMillis(); randomAccessFile.close(); System.out.println(&quot;打开同步，关闭文件耗时：&quot;+(System.currentTimeMillis()-startTime)+&quot;ms&quot;); file=new File(&quot;TestRandomAccessFile.data&quot;); randomAccessFile=new RandomAccessFile(file,&quot;rw&quot;); startTime=System.currentTimeMillis(); randomAccessFile.writeChar(&apos;A&apos;); System.out.println(&quot;关闭同步，每个char类型，写入耗时：&quot;+(System.currentTimeMillis()-startTime)+&quot;ms&quot;); startTime=System.currentTimeMillis(); for(char i=33;i&lt;127;i++) { randomAccessFile.writeChar(i); } System.out.println(&quot;关闭同步，写入127-33个字符耗时：&quot;+(System.currentTimeMillis()-startTime)+&quot;ms&quot;); startTime=System.currentTimeMillis(); randomAccessFile.close(); System.out.println(&quot;关闭同步，关闭文件耗时：&quot;+(System.currentTimeMillis()-startTime)+&quot;ms&quot;); file=new File(&quot;TestRandomAccessFile.data&quot;); System.out.println(&quot;File length:&quot;+file.length()); randomAccessFile=new RandomAccessFile(file, &quot;r&quot;); while(true) { char tmp=randomAccessFile.readChar(); System.out.print(tmp); } } catch (FileNotFoundException e) { // TODO: handle exception } catch (EOFException e) { System.out.println(&quot;\\\\n数据读取完毕！&quot;); } catch (IOException e) { } finally{ System.out.println(&quot;Finished!!!&quot;); } } } 运行结果为 打开同步，每个char类型，写入耗时：69ms打开同步，写入127-33个字符耗时：6582ms打开同步，关闭文件耗时：0ms关闭同步，每个char类型，写入耗时：0ms关闭同步，写入127-33个字符耗时：0ms关闭同步，关闭文件耗时：0msFile length:190A!”#$%&amp;’()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~数据读取完毕！Finished!!! 在上面的程序中，主要完成了将数据写入某一个文件之后，重新打开文件，并从文件尾部追加数据。同时还统计了在打开同步和关闭同步模式的情况下，所消耗时间的统计。可以看出，当打开同步之后，每次写入数据都会同步到磁盘，该过程消耗了时间，是我们需要注意的，在条件不严格不苛刻的时候，没有必要打开同步功能。 三、System.in\\System.out 在System中，有标准输入、标准输出、错误输出3个流， static [PrintStream](http://docs.oracle.com/javase/7/docs/api/java/io/PrintStream.html &quot;class in java.io&quot;) **[err](http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#err)** The “standard” error output stream. static [InputStream](http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html &quot;class in java.io&quot;) **[in](http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#in)** The “standard” input stream. static [PrintStream](http://docs.oracle.com/javase/7/docs/api/java/io/PrintStream.html &quot;class in java.io&quot;) **[out](http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#out)** The “standard” output stream. 而且这三个流我们都可以手动设置，也比较简单，留个标签，关于这边遇到好玩的过来填上。 四、获取其他进程的输入输出流 在Process类中，定义了3个方法 abstract [InputStream](http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html &quot;class in java.io&quot;) **[getErrorStream](http://docs.oracle.com/javase/7/docs/api/java/lang/Process.html#getErrorStream())**() Returns the input stream connected to the error output of the subprocess. abstract [InputStream](http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html &quot;class in java.io&quot;) **[getInputStream](http://docs.oracle.com/javase/7/docs/api/java/lang/Process.html#getInputStream())**() Returns the input stream connected to the normal output of the subprocess. abstract [OutputStream](http://docs.oracle.com/javase/7/docs/api/java/io/OutputStream.html &quot;class in java.io&quot;) **[getOutputStream](http://docs.oracle.com/javase/7/docs/api/java/lang/Process.html#getOutputStream())**() Returns the output stream connected to the normal input of the subprocess. 这样我们就能从相关的进程中拿到输入输出流，从而控制程序的运行，简单哈。ACM比赛评分的工作也可以用这个来完成。","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Vim命令速查卡（转载）","slug":"vim-cmds-card","date":"2013-04-05T11:17:10.000Z","updated":"2018-10-03T16:12:52.604Z","comments":true,"path":"2013/04/05/vim-cmds-card/","link":"","permalink":"http://yoursite.com/2013/04/05/vim-cmds-card/","excerpt":"","text":"这是个标签，这边有个Vim命令速查卡，比较好，放过来，用的时候看看。感谢作者分享 ：http://jrmiii.com/ PDF文件地址：Vim","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"global命令详解(转载)","slug":"linux-global","date":"2013-04-05T10:58:47.000Z","updated":"2018-10-03T15:07:59.186Z","comments":true,"path":"2013/04/05/linux-global/","link":"","permalink":"http://yoursite.com/2013/04/05/linux-global/","excerpt":"","text":"发信人: vale (浅谷), 信区: VIM 标 题: global命令详解 发信站: 水木社区 (Fri Jun 15 17:05:55 2007), 站内 global命令是Vim最强大的命令之一（个人认为是No.1），将其摸透用熟可以事半功倍， 本文总结了版上的一些经典问题，结合自己的使用和理解，试图通过实例详细介绍一下 其用法。示例难度不一，有些并没有多少实用性，为题而生，读者各取所需吧。示例说 明并不非常细致，以免罗唆。每节标题下列出了所涉及的内容在Vim help中的位置，以 供查找。文中用词未必标准（我没看过Vim中文帮助），观点也难免有错，请大家指正。 |1.| global命令形式 |2.| global与substitute |3.| global标志的[range]用法 |4.| global与Vim脚本 |5.| 小结 ============================================================================== *1.* global命令形式 :h :g :h 12.4 :[range]global/{pattern}/{command} global命令在[range]指定的文本范围内（缺省为整个文件）查找{pattern}，然后对匹 配到的行执行命令{command}，如果希望对没匹配上的行执行命令，则使用global!或 vglobal命令。 先来看Vim用户手册里的一个经典例子。 【例1】倒序文件行（即unix下的tac命令） :g/^/m 0 这条命令用行首标记/^/匹配文件的所有行（这是查找的一个常用技巧，如果用/./则是 匹配非空行，不满足本例要求），然后用move命令依次将每行移到第一行（第0行的下一 行），从而实现了倒序功能。 global命令实际上是分成两步执行：首先扫描[range]指定范围内的所有行，给匹配{pa ttern}的行打上标记；然后依次对打有标记的行执行{command}命令，如果被标记的行在 对之前匹配行的命令操作中被删除、移动或合并，则其标记自动消失，而不对该行执行 {command}命令。{command}可以是一个ex命令，也可以是用|分隔的多个ex命令，这样我 们就可以对被标记行，或从标记行寻址到的行进行多种不同的操作。 标记的概念很重要，现以例说明。 【例2】删除偶数行 :g/^/+1 d 这条命令也是匹配所有行，然后隔行删除（其中+1用以定位于当前行的下一行）。为什 么是隔行呢？因为在对第一行执行+1 d命令时删除的是第二行，而第二行虽然也被标记 了，但已不存在了，因此不会执行删除第三行的命令。 本例也可以用normal命令实现： :%norm jdd %指定整个文件，然后依次执行普通模式下的jdd，即下移删除一行。与global命令不同 之处在于，%norm是按照行号顺序执行，在第一行时删除了第二行，后面的所有行号都减 一，因此在第二行执行jdd时删除的是原来的第四行。也就是说，global命令是通过偶数 行标记的消失实现的，而normal命令是通过后续行的自动前移实现的。 【例3】删除奇数行 :g/^/d|m. 光是:g/^/d显然不行，这会删除所有行，我们需要用move命令把偶数行的标记去掉。当 然，本例可以很简单的转换成【例2】，在此只是用来强调标记的概念。 本例若想用normal命令实现比较有意思，%norm dd也同样会删除整个文件，%norm jkdd 就可以，我不知道两者为什么不同，可能和normal命令内部的运行机制有关。 ============================================================================== *2.* global与substitute :h 10.4 :helpg ms-word/c 不少vimmer觉得这两个命令差不多，的确，它们的形式很相似，都是要进行查找匹配， 只不过substitute执行的是替换而global执行的其它命令（当然，substitute缺省的[r ange]是当前行，这点也不同）。先看两个例子，体会一下:s和:g不同的思维方式。 【例4】double所有行 :%s/./&amp;/r&amp;/ :g/^/t. substitue是查找任意行，然后替换为两行夹回车；global是将每一行复制（:t就是:co py）到自己下面，更加清晰明了。 【例5】把以回车排版、以空行分段的文本变成以回车分段的文本 很多txt格式的ebook，以及像vim help这样的文本，每行的字符数受限，段之间用空行 分隔。若把它们拷贝到word里，那些硬回车和空行就比较讨厌了，虽然word里也有自动 调整格式的功能，不过在Vim里搞定更是小菜一碟。先看看用替换如何实现。 :%s//n/n/@!/ / /n/n/@!是查找后面不跟回车的回车（关于/@!的用法请:h //@!，在此不多说了），然后 替换为空格，也就是去掉用于排版的回车。global命令则完全是另一种思路。 :g/./,/^$/j /./标记非空行，/^$/查找其后的空行，然后对二者之间的行进行合并操作。也许有人会 问，段中的每一行会不会都执行了j命令？前面已经说过，在之前操作中消失掉的标记行 不执行操作命令，在处理每段第一行时已经把段内的其余行都合并了，所以每段只会执 行一次j命令。这条命令使用global标记做为[range]的起始行，这样的用法后面还会详 述。 如果想要保留段落间的空行呢？若用替换实现，需要查找的是前后都没有回车的回车： :%s//n/@&lt;!/n/n/@!/ / 这样的正则表达式可能会令很多vimmer头大了。而对于global命令则只需要将合并范围 的结束位置上移一行就行了，由此可见global命令的方便之处。 :g/./,/^$/-1j global经常与substitute组合使用，用前者定位满足一定条件的行，用后者在这些行中 进行查找替换。如： 【例6】将aaa替换成bbb，除非该行中有ccc或者ddd :v/ccc/|ddd/s/aaa/bbb/g 【例7】将aaa替换成bbb，条件是该行中有ccc但不能有ddd 如何写出一个匹配aaa并满足行内有ccc但不能有ddd的正则表达式？我不知道。即便能写 出来，也必定极其复杂。用global命令则并不困难： :g/ccc/if getline(‘.’) !~ ‘ddd’ | s/aaa/bbb/g 该命令首先标记匹配ccc的行，然后执行if命令（if也是ex命令！），getline函数取得 当前行，然后判断是否匹配ddd，如果不匹配（!~的求值为true）则执行替换。要掌握这 样的用法需要对ex命令、Vim函数和表达式有一定了解才行，实际上，这条命令已经是一 个快捷版的脚本了。可能有人会想，把g和v连起来用不就行了么，可惜global命令不支 持（恐怕也没法支持）嵌套。 ============================================================================== \\3.* global标志的[range]用法 :h range 在global命令第一步中所设的标记，可以被用来为{command}命令设定各种形式的[rang e]。在【例2】和【例5】中都已使用了这一技巧，灵活使用[range]，是一项重要的基本 功。先看看【例2】和【例3】的一般化问题。 【例8】每n行中，删除前/后m行（例如，每10行删除前/后3行） :g/^/d 3 | ,+6 m -1 :g/^/,+6 m -1 | +1 d 3 这两个命令还是利用move来清除保留行的标志，需要注意的是执行第二个命令时的当前 行是第一个命令寻址并执行后的位置。再看两个更实用点的例子。 【例9】提取条件编译内容。例如，在一个多平台的C程序里有大量的条件编译代码： #ifdef WIN32 XXX1 XXX2 #endif … #ifdef WIN32 XXX3 XXX4 #else YYY1 YYY2 #endif 现在用global命令把Win32平台下代码提取出来，拷贝到文件末： :g/#ifdef WIN32/+1,/#else/|#endif/-1 t $ t命令的[range]是由逗号分隔，起始行是/#ifdef WIN32/标记行的下一行，结束行是一 个查找定位，是在起始行后面出现的#endif或#else的上一行，t将二者间的内容复制到 末尾。 【例10】提取上述C程序中的非Win32平台的代码（YYY部分） 首先说明一下，这个例子比前例要复杂的多，主要涉及的是[range]的操作，已经和 global命令没多少关系，大可不看。加到这的目的是把问题说完，供喜欢细抠的朋友参考。 本例的复杂性在于：首先，不能简单的用#else和#endif定位，因为代码中可能有其它的 条件编译，我们必须要将查找范围限定在#ifdef WIN32的block中；另外，在block中可 能并没有#else部分，这会给定位带来很大麻烦。解决方法是： :try | g/#ifdef WIN32//#else/+1, /#endif/-1 t $ | endtry 先不管try和endtry，只看中间的global部分：找到WIN32，再向后找到#else，将其下一 行作为[range]的起始行，然后从当前的光标（WIN32所在行，而非刚找到的#else的下一 行）向下找到#endif，将其上一行作为[range]的结束行，然后执行t命令。但对于没有 #else的block，如第一段代码，[range]的起始行是YYY1，而结束行是XXX2（因为查找 #endif时是从第一行开始的，而不是从YYY1开始），这是一个非法的[range]，会引起 exception，如果不放在try里面global命令就会立刻停止。 与逗号(,)不同，如果[range]是用分号(;)分隔的，则会使得当前光标移至起始行，在查 找#endif时是从#else的下一行开始，就不会产生非法[range]，用不着try，但带来的问 题是：没有#else的block会错误的把后面block中的#else部分找出来。 ============================================================================== *4.* global与Vim脚本 :h script :h expression 经常有人问：XxEditor有个什么功能，Vim支持么？很可能不支持，因为Vim不大会为特 定用户群提供非一般化的功能，但很少有什么功能不能在Vim定制出来，如果是你常用， 就加到你的vimrc或者plugin里。脚本就是定制Vim的一种利器。本文不讨论脚本的编写， 而是介绍如何实用global实现类似脚本的功能，实际上，就是利用命令提供的机制，做 一个简化的脚本。 【例11】计算文件中数字列之和（或其它运算） :let i=0 :g/^/let i+=str2nr(getline(‘.’)) :echo i 首先定义变量i并清零，然后用str2nr函数把当前行转成数字累加到i中，注意Vim不支持 浮点数。global在这里实际上是替代了脚本里的for循环。 Vim中最常见的一个问题是如何产生一列递增数字，有很多解决办法，调用外部命令，录 宏，用substitute命令，还有专门的插件，而用global命令，可以实现一些更高级的功 能。见下例。 【例12】给有效代码行添加标号 在_Data Structures and Algorithm Analysis in C_一书中，作者为了便于讨论，将代 码中的有效行加上注释标号，例如： / 1 / unsigned int factorial( unsigned int n ) { / 2 / if( n &lt;= 1 ) / 3 / return 1; / 4 / return( n factorial(n-1) ); } 为了在添加标号后能对齐，我们预先在每行代码前面插入足够多的空格（这当然很简单）， 然后用global命令自动添加标号： :let i=1 | g//a/s/ /{8}//=printf(“// %2d //“,i)/ | let i+=1 其中变量i用来记录标号，g命令查找有字母的行，然后把前8个空格替换成注释标号，每 行处理完成后标号加一。替换中用到了//=，一个非常有用的功能。 最后我们再回到删除特定行的例子，用变量来搞定。 【例13】每n行中，删除前/后m行 :let n=10 | let m=3 :let i=-1 | g/^/let i+=1 | if i%n&lt;m | d :let i=-1 | g/^/let i+=1 | if i%n&gt;(n-m-1) | d 我们用i来记录处理行的位置，通过i的值与m和n的关系决定何时进行删除操作，这样的处 理方式比【例8】的方法要清晰明了很多，而且更加通用。 ============================================================================== \\5.* 小结 要用好global命令并非易事，命令中的每一部分都值得仔细研究：只有掌握了range原理 ，才能自如的在文件中定位；只有精通pattern，才能有效的匹配到想要找的行；只有熟 悉ex命令，才能选用最合适的功能进行操作；只有对变量、表达式、函数等内容有一定 了解，才更能让global命令实现脚本的功能。总之，global是一个非常好的框架，对Vim 越是熟悉，就越能将其种种武器架设在其上使用，发挥更大的威力。 global当然并非万能，功能也有所欠缺，最主要的问题是只能用正则表达式来标志匹配 行，如果能用任意表达式来标记（或者从另一个角度，如前mv版主runsnake所说，引入 求值正则表达式），则可实现更加方便功能。比如前述的几个删除特定行的问题，将会 有简单而统一的解决方法。上述例子如果用sed、awk等专门的文本处理工具，或者perl 之类的script语言也非难事，有些实现起来会更加方便。本文提供的Vim解决方法未必简 单，甚至可能是难于理解，目的在于介绍global的使用。对于那些不会或者不能使用其 它工具的朋友，参考价值可能更大一些。其实Vim的功能实在很丰富，值得我们深入学习。 少林七十二绝技固然高妙，会的越多自然功力越强，不过只要会上一门六脉神剑或小无 相功，也足以独步江湖了。 ============================================================================== vim:tw=78:fo=tcq2:isk=!-~,^,^/|,^/“:ts=8:ft=help:norl: ※ 修改:·vale 于 Sep 27 12:26:18 修改本文·[FROM: 219.143.141.] ※ 来源:·水木社区 newsmth.net·[FROM: 219.143.156.*]","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Vim命令合集（转载）","slug":"vim-cmds","date":"2013-04-05T10:51:01.000Z","updated":"2018-10-03T15:12:22.601Z","comments":true,"path":"2013/04/05/vim-cmds/","link":"","permalink":"http://yoursite.com/2013/04/05/vim-cmds/","excerpt":"","text":"转自http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html 命令历史以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。 启动vim在命令行窗口中输入以下命令即可 vim 直接启动vim vim filename 打开vim并创建名为filename的文件 文件命令打开单个文件 vim file 同时打开多个文件 vim file1 file2 file3 … 在vim窗口中打开一个新文件 :open file 在新窗口中打开文件 :split file 切换到下一个文件 :bn 切换到上一个文件 :bp 查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。 :args 打开远程文件，比如ftp或者share folder :e ftp://192.168.10.76/abc.txt :e \\\\qadrive\\test\\1.txt vim的模式正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空 插入模式（按i键进入） 左下角显示–INSERT– 可视模式（不知道如何进入） 左下角显示–VISUAL– 导航命令% 括号匹配 插入命令i 在当前位置生前插入 I 在当前行首插入 a 在当前位置后插入 A 在当前行尾插入 o 在当前行之后插入一行 O 在当前行之前插入一行 查找命令/text 查找text，按n健查找下一个，按N健查找前一个。 ?text 查找text，反向查找，按n健查找下一个，按N健查找前一个。 vim中有一些特殊字符在查找时需要转义 .[]^%/?~$ :set ignorecase 忽略大小写的查找 :set noignorecase 不忽略大小写的查找 查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。 :set hlsearch 高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。 :set nohlsearch 关闭高亮搜索显示 :nohlsearch 关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。 :set incsearch 逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。 :set wrapscan 重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。 替换命令ra 将当前字符替换为a，当期字符即光标所在字符。 s/old/new/ 用old替换new，替换当前行的第一个匹配 s/old/new/g 用old替换new，替换当前行的所有匹配 %s/old/new/ 用old替换new，替换所有行的第一个匹配 %s/old/new/g 用old替换new，替换整个文件的所有匹配 :10,20 s/^/ /g 在第10行知第20行每行前面加四个空格，用于缩进。 ddp 交换光标所在行和其下紧邻的一行。 移动命令h 左移一个字符 l 右移一个字符，这个命令很少用，一般用w代替。 k 上移一个字符 j 下移一个字符 以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！，这里的Esc是必须的，否则命令不生效。 w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。 b 向后移动一个单词 2b 向后移动2个单词 e，同w，只不过是光标停在单词尾部 ge，同b，光标停在单词尾部。 ^ 移动到本行第一个非空白字符上。 0（数字0）移动到本行第一个字符上， 移动到本行第一个字符。同0健。 $ 移动到行尾 3$ 移动到下面3行的行尾 gg 移动到文件头。 = [[ G（shift + g） 移动到文件尾。 = ]] f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。 F 同f，反向查找。 跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。 Ctrl + e 向下滚动一行 Ctrl + y 向上滚动一行 Ctrl + d 向下滚动半屏 Ctrl + u 向上滚动半屏 Ctrl + f 向下滚动一屏 Ctrl + b 向上滚动一屏 撤销和重做u 撤销（Undo） U 撤销对整行的操作 Ctrl + r 重做（Redo），即撤销的撤销。 删除命令x 删除当前字符 3x 删除当前光标开始向后三个字符 X 删除当前字符的前一个字符。X=dh dl 删除当前字符， dl=x dh 删除前一个字符 dd 删除当前行 dj 删除上一行 dk 删除下一行 10d 删除当前行开始的10行。 D 删除当前字符至行尾。D=d$ d$ 删除当前字符之后的所有字符（本行） kdgg 删除当前行之前所有行（不包括当前行） jdG（jd shift + g） 删除当前行之后所有行（不包括当前行） :1,10d 删除1-10行 :11,$d 删除11行及以后所有的行 :1,$d 删除所有行 J(shift + j) 删除两行之间的空行，实际上是合并两行。 拷贝和粘贴yy 拷贝当前行 nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。 p 在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。 shift+p 在当前行前粘贴 :1,10 co 20 将1-10行插入到第20行之后。 :1,$ co $ 将整个文件复制一份并添加到文件尾部。 正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制 ddp交换当前行和其下一行 xp交换当前字符和其后一个字符 剪切命令正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切 ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴 :1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。 :1, 10 m 20 将第1-10行移动到第20行之后。 退出命令:wq 保存并退出 ZZ 保存并退出 :q! 强制退出并忽略所有更改 :e! 放弃所有修改，并打开原来文件。 窗口命令:split或new 打开一个新窗口，光标停在顶层的窗口上 :split file或:new file 用新窗口打开文件 split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。 Ctrl+ww 移动到下一个窗口 Ctrl+wj 移动到下方的窗口 Ctrl+wk 移动到上方的窗口 关闭窗口 :close 最后一个窗口不能使用此命令，可以防止意外退出vim。 :q 如果是最后一个被关闭的窗口，那么将退出vim。 ZZ 保存并退出。 关闭所有窗口，只保留当前窗口 :only 录制宏 按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。 执行shell命令:!command :!ls 列出当前目录下文件 :!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。 :!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。 :suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。 注释命令perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入# 3,5 s/^/#/g 注释第3-5行 3,5 s/^#//g 解除3-5行的注释 1,$ s/^/#/g 注释整个文档。 :%s/^/#/g 注释整个文档，此法更快。 帮助命令:help or F1 显示整个帮助 :help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。 :help ‘number’ Vim选项的帮助用单引号括起 :help 特殊键的帮助用&lt;&gt;扩起 :help -t Vim启动参数的帮助用- ：help i_ 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式 帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回 其他非编辑命令. 重复前一次命令 :set ruler? 查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看 :scriptnames 查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。 :set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。 Vim教程 在Unix系统上 $ vimtutor 在Windows系统上 :help tutor :syntax 列出已经定义的语法项 :syntax clear 清除已定义的语法规则 :syntax case match 大小写敏感，int和Int将视为不同的语法元素 :syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Java IO 之二：传统IO (2)Reader,Writer","slug":"java-io-reader-writer","date":"2013-04-04T14:38:43.000Z","updated":"2018-10-03T16:12:52.604Z","comments":true,"path":"2013/04/04/java-io-reader-writer/","link":"","permalink":"http://yoursite.com/2013/04/04/java-io-reader-writer/","excerpt":"","text":"Reader Writer Reader和Writer是和InputStream/OutputStream想平行的输入输出流，其和InputStream/OutputStream的最大的区别在于，Reader/Writer是针对于16位的字符的，而InputStream/OutputStream则是针对于8bit字节的，因此，在处理文字等字符时，最好使用Reader/Writer。同时Java中还拥有类InputStreamReader和OutputStreamWriter两个不同的类来完成Strem/Reader的转化。 (一)BufferedReader/BufferedWriter (二)CharArrayReader/CharArrayWriter (三)PushbackReader (四)InputStreamReader/OutputStreamWriter (五)FileReader/FileWriter (六)PipedReader/PipedWriter (七)StringReader/StringWriter 上述类的使用方法基本上和上一篇博客InputSteram/OutputStream中的大体上使用都差不多。这里就不多做介绍，主要来试一下InputStreamReader和OutputStreamWriter，程序如下： package ReaderWriter; import java.io.InputStreamReader;import java.io.OutputStreamWriter; public class TestInputStreamReader { public static void main(String[] args) { InputStreamReader inputStreamReader=new InputStreamReader(System.in); OutputStreamWriter outputStreamWriter=new OutputStreamWriter(System.out); char\\[\\] buffer=new char\\[8192\\]; int count=0; try { while((count=inputStreamReader.read(buffer))!=-1) outputStreamWriter.write(buffer); } catch(Exception e) { e.printStackTrace(); } } } 使用InputStreamReader和OutputStreamWriter对System.in和System.out做了简单的封装，运行结果如下： 测试InputStreamReader/OutputStreamWriter测试InputStreamReader/OutputStreamWriter 程序会打印出我们输入的内容。 其他的类别区别基本不大，可以参阅上一篇博客：Java IO 之一：传统IO (1)InputStream,OutputStream","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Java IO 之一：传统IO (1)InputStream,OutputStream","slug":"java-io-inputstream-outputstream","date":"2013-04-04T04:52:12.000Z","updated":"2018-10-03T16:12:52.547Z","comments":true,"path":"2013/04/04/java-io-inputstream-outputstream/","link":"","permalink":"http://yoursite.com/2013/04/04/java-io-inputstream-outputstream/","excerpt":"","text":"InputStream,OutputStreamIO是最常用的组件之一，也想写一篇关于IO的，总结下，也方便自己查找，主要分三个部分来写，1、传统IO，2、NIO ，3、Java7中的NIO.2 首先是传统的IO操作，这是Java IO的基础，在Java中，所有的IO操作以流的方式存在，如果从流的角度来分来，在我们使用的时候，分为输出流/输入流，字节流/字符流，节点流/处理流。其中输出流和输入流不用多说，指的就是数据的流向，要从硬盘中读入内存，那必然是输入流，要从内存中写到硬盘等外部设备中，那就是输出流。 字节流/字符流：其实两者的区别在于其数据单元的大小上，字节流，每次处理的都是8bit的字节，而字符流，处理的都是16bit的字符，因此我们可以容易理解，在处理汉字的时候，大多数用的字符流而并非字节流。 节点流/处理流：简单的理解，节点流是一种较低级别的数据流，是直接从硬盘、网络等I/O设备中获取数据的流，处理流是节点流的一个封装，通过对节点流的封装，可以大大简化我们在操作Java的IO的时候的编程的复杂性。同时，在面向对象设计中，使用处理流可以使我们的程序能够更加容易的适配不同的I/O设备，降低程序对I/O具体操作的依赖。 Java的I/O有4个处理流的基类，InputStream、OutputStream、Reader、Writer，在该4个基类的基础之上派生出很多的子类，我用下面这样一张图来梳理一下。 InputStream 先看看InputStream public abstract class InputStreamextends Objectimplements Closeable This abstract class is the superclass of all classes representing an input stream of bytes. Applications that need to define a subclass of InputStream must always provide a method that returns the next byte of input. InputStream是所有输入字节流的父类，而要继承InputStream必须实现一个返回下一个字节的方法，同时我们也注意到，在Java 7中，该类实现了Closeable接口，所以我们可以直接在try后面打开文件，从而减少了手动关闭的麻烦。既然是所有字节输入流的父类，那我们就看一看里面声明的主要的方法有那些。 Modifier and Type Method and Description int **[available](http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#available())**() Returns an estimate of the number of bytes that can be read (or skipped over) from this input stream without blocking by the next invocation of a method for this input stream. void **[close](http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#close())**() Closes this input stream and releases any system resources associated with the stream. void **[mark](http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#mark(int))**(int readlimit) Marks the current position in this input stream. boolean **[markSupported](http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#markSupported())**() Tests if this input stream supports the mark and reset methods. abstract int **[read](http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#read())**() Reads the next byte of data from the input stream. int **[read](http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#read(byte[]))**(byte[] b) Reads some number of bytes from the input stream and stores them into the buffer array b. int **[read](http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#read(byte[], int, int))**(byte[] b, int off, int len) Reads up to len bytes of data from the input stream into an array of bytes. void **[reset](http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#reset())**() Repositions this stream to the position at the time the mark method was last called on this input stream. long **[skip](http://docs.oracle.com/javase/7/docs/api/java/io/InputStream.html#skip(long))**(long n) Skips over and discards n bytes of data from this input stream. 我们查看源文件也可以发现，InputStream中，有一个抽象方法 read()，而read(byte[] b,),read)(byte[] b, int off, int len)都在read()方法上实现。然而向其他的available()、close()、mark()、等等都是需要在子类中去重载的。 OutputStream OutputStream与InputStream一样，是基于字节流的处理，是ByteArrayOutputStream, FileOutputStream, FilterOutputStream, ObjectOutputStream, OutputStream, PipedOutputStream的父类，其中提供了 void **[close](http://docs.oracle.com/javase/7/docs/api/java/io/OutputStream.html#close())**() Closes this output stream and releases any system resources associated with this stream. void **[flush](http://docs.oracle.com/javase/7/docs/api/java/io/OutputStream.html#flush())**() Flushes this output stream and forces any buffered output bytes to be written out. void **[write](http://docs.oracle.com/javase/7/docs/api/java/io/OutputStream.html#write(byte[]))**(byte[] b) Writes b.length bytes from the specified byte array to this output stream. void **[write](http://docs.oracle.com/javase/7/docs/api/java/io/OutputStream.html#write(byte[], int, int))**(byte[] b, int off, int len) Writes len bytes from the specified byte array starting at offset off to this output stream. abstract void **[write](http://docs.oracle.com/javase/7/docs/api/java/io/OutputStream.html#write(int))**(int b) Writes the specified byte to this output stream. (一)AudioInputStream该类是音频输入流，我们一般很少用到，这里不是讨论的重点。 (二)ByteArrayInputStream &amp;&amp; ByteArrayOutputStream这两个方法是将数组封装成Stream的类。package InputStream; import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException; public class TestByteArrayStream { public static void main(String[] args) throws IOException { //Default Constructor:Size is set to 32 On OpenJDK7 / Ubuntu12.04 ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream(); for(int i=0;i&lt;100;i++) byteArrayOutputStream.write(i); try { FileOutputStream fileOutputStream=new FileOutputStream(new File(“TestByteArrayStream.data”)); byteArrayOutputStream.writeTo(fileOutputStream); } catch (FileNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } byte data\\[\\]=new byte\\[100\\]; for(byte i=0;i&lt;100;i++) data\\[i\\]=i; ByteArrayInputStream byteArrayInputStream=new ByteArrayInputStream(data); int tmp; //the next byte of data, or -1 if the end of the stream has been reached. while((tmp=byteArrayInputStream.read())!=-1) { System.out.print(tmp+&quot; &quot;); if(byteArrayInputStream.available()==6) { byteArrayInputStream.skip(10); } } byteArrayInputStream.close(); byteArrayOutputStream.close(); } } 该两个类比较简单，即使将数组这一节点流封装成处理流丢给上层处理，需要注意的是，可以发现在ByteArrayInputStream或者ByteArrayOutputStream中，关于读、写方法都是同步的，可以保证数据的完整性。 (三)FileInputStream\\FileOutputStreampackage InputStream; import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException; public class TestFileStream { public static void main(String[] args) throws IOException { try { FileInputStream fileInputStream=new FileInputStream(“src/InputStream/TestFileStream.java”); byte buf[]=new byte[1024]; FileOutputStream fileOutputStream=new FileOutputStream(“TestFileStream.data”); while(fileInputStream.available()&gt;0) { int count=fileInputStream.read(buf); fileOutputStream.write(buf,0,count); } fileInputStream.close(); fileOutputStream.close(); }catch (FileNotFoundException e) { // TODO: handle exception e.printStackTrace(); }catch (IOException e) { e.printStackTrace(); } } } (四)FilterInputStream\\FilterOutputStream从上面的类的继承关系上来看，都有很多子类，我们来看一下这两个类的作用。 FilterInputStreamA FilterInputStream contains some other input stream, which it uses as its basic source of data, possibly transforming the data along the way or providing additional functionality. The class FilterInputStream itself simply overrides all methods of InputStream with versions that pass all requests to the contained input stream. Subclasses of FilterInputStream may further override some of these methods and may also provide additional methods and fields. FilterOutputStreamThis class is the superclass of all classes that filter output streams. These streams sit on top of an already existing output stream (the underlying output stream) which it uses as its basic sink of data, but possibly transforming the data along the way or providing additional functionality.The class FilterOutputStream itself simply overrides all methods of OutputStream with versions that pass all requests to the underlying output stream. Subclasses ofFilterOutputStream may further override some of these methods as well as provide additional methods and fields. 从Java的API文档中我们可以看到，这两个类只是实现了对InputStream和OutputStream的简单封装，在类里面都分别定义了一个protected Inputstream in;protected OutputStream out;通过这两个类及其子类，我们可以更好的优化程序数据流通路。 BufferedInputStream/BufferedOutputStreamA BufferedInputStream adds functionality to another input stream-namely, the ability to buffer the input and to support the mark and reset methods. When the BufferedInputStream is created, an internal buffer array is created. As bytes from the stream are read or skipped, the internal buffer is refilled as necessary from the contained input stream, many bytes at a time. The mark operation remembers a point in the input stream and the reset operation causes all the bytes read since the most recent mark operation to be reread before new bytes are taken from the contained input stream. 顾名思义，BufferedInputStream就是将我们(三)FileInputStream\\FileOutputStream中写的程序那样，在外面使用的buffer缓冲区，内建在类中，查看源文件我们可以看到，默认的buffer大小为8192byte，同时还提供了一个mark和reset的方法，因此，要搞明白这两个类的使用方法，我们需要好好注意这两个方法的使用，下面是一个小小的demo。 package InputStream; import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException; public class TestBufferedStream { public static void main(String[] args) { try { FileInputStream fileInputStream=new FileInputStream(“src/InputStream/TestBufferedStream.java”); FileOutputStream fileOutputStream=new FileOutputStream(“TestBufferedStream.data”); BufferedInputStream bufferedInputStream=new BufferedInputStream(fileInputStream); BufferedOutputStream bufferedOutputStream=new BufferedOutputStream(fileOutputStream); int times=0; int marktimes=0; int count=0; bufferedInputStream.mark(1000); while(bufferedInputStream.available()&gt;0) { byte\\[\\] buff; if(marktimes&lt;3) buff=new byte\\[1000\\]; else{ if(marktimes==3) bufferedInputStream.mark(1000); buff=new byte\\[8192\\]; } marktimes++; int counttmp=bufferedInputStream.read(buff); count=counttmp+count; //for(byte tmp:buff) // System.out.print(String.valueOf(tmp)); bufferedOutputStream.write(buff,0,counttmp); if(bufferedInputStream.available()&lt;100 &amp;&amp; times&lt;5) { System.out.println(&quot;\\\\n上一次读取: &quot;+count+&quot; bytes&quot;); count=0; bufferedInputStream.reset(); times++; } } System.out.println(&quot;\\\\n上一次读取: &quot;+count+&quot; bytes&quot;); //注意！应该先关闭BufferedInputStream/BufferedOutputStream，在关闭InputStream/OutStream //或者只关闭BufferedStream即刻，因为在BufferedStream的close方法中，会将构造函数中传入的InputStream/OutputStream自动关闭。 bufferedInputStream.close(); bufferedOutputStream.close(); //fileInputStream.close(); //fileOutputStream.close(); }catch (FileNotFoundException e) { // TODO: handle exception e.printStackTrace(); }catch (IOException e) { e.printStackTrace(); } } } 比较简单，就不加注释了，主要是讲讲其中的mark(int readlimit)其中的readlimit - the maximum limit of bytes that can be read before the mark position becomes invalid.就是说，在读到readlimit个字节之前，可以保证该mark有效的。 mark函数和reset()函数是一起的，当mark之后，调用reset函数，则再读取数据的时候，读取到的就是mark时所在的位置，上图。同时要注意到，在mark函数运行之前，不能调用reset函数，否则会引发IOException错误([IOException](http://docs.oracle.com/javase/7/docs/api/java/io/IOException.html &quot;class in java.io&quot;) - if this stream has not been marked or, if the mark has been invalidated, or the stream has been closed by invoking its close()) method, or an I/O error occurs.) 同时，我们还应该注意到的时候，我们使用处理流之后，就不需要去关闭我们包装的流，当我们直接关闭处理流的时候，传入的被包装的流会被自动关闭。 上述程序的运行结果为 上一次读取: 1987 bytes上一次读取: 1987 bytes上一次读取: 987 bytes上一次读取: 987 bytes上一次读取: 987 bytes上一次读取: 987 bytes 最初的时候，我们设置的mark为开始的位置，所以那时我们调用reset，便会回到文章开头，所以我们看到执行的结果中，头两次都是1987 bytes，当我们在文件读写过程中设置标签的时候，可以发现，此时读取便会从我们设置标签的位置开始，程序中设置的是1000,我们查看生成的文件，也是这样的效果。 (2)CheckedInputStream/CheckedOutputStreamCheckedInputStream:An input stream that also maintains a checksum of the data being read. The checksum can then be used to verify the integrity of the input data. CheckedOutputStream:An output stream that also maintains a checksum of the data being written. The checksum can then be used to verify the integrity of the output data. CheckedInputStream和CheckedInputStream的源码在 java/util/zip/目录下，其作用是为了校验数据的准确行，其构造函数为 CheckedInputStream(InputStream in, Checksum cksum)Creates an input stream using the specified Checksum. CheckedOutputStream(OutputStream out, Checksum cksum)Creates an output stream with the specified Checksum. 需要我们传入InputStream/OutputStream流，和一个Checksum接口，查看zip下的源文件，发现Java已经为我们写好了两个可以用的继承了Checksum接口的源程序。Adler32/CRC32,我们以CRC32为例，来看看怎么使用。 package InputStream; import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.InputStream;import java.util.zip.CRC32;import java.util.zip.CheckedInputStream;import java.util.zip.CheckedOutputStream; public class TestCheckedStream{ public static void main(String[] args) { FileInputStream fileInputStream; FileOutputStream fileOutputStream; CheckedInputStream checkedInputStream; CheckedOutputStream checkedOutputStream; CRC32 crc32=new CRC32(); try{ fileInputStream=new FileInputStream(&quot;src/InputStream/TestCheckedStream.java&quot;); fileOutputStream=new FileOutputStream(&quot;TestCheckedStream.data&quot;); checkedInputStream=new CheckedInputStream(fileInputStream,crc32); checkedOutputStream=new CheckedOutputStream(fileOutputStream, crc32); System.out.println(&quot;CheckedInputStream:CheckSum:&quot;+checkedInputStream.getChecksum().getValue()); System.out.println(&quot;CheckedOutStream:CheckSum:&quot;+checkedOutputStream.getChecksum().getValue()); byte\\[\\] buffer=new byte\\[1024\\]; while(checkedInputStream.available()&gt;0) { int count=checkedInputStream.read(buffer); checkedOutputStream.write(buffer, 0, count); } System.out.println(&quot;CheckedInputStream:CheckSum:&quot;+checkedInputStream.getChecksum().getValue()); System.out.println(&quot;CheckedOutStream:CheckSum:&quot;+checkedOutputStream.getChecksum().getValue()); checkedInputStream.close(); checkedOutputStream.close(); } catch(Exception ex) { } } } 运行程序，得到结果为： CheckedInputStream:CheckSum:0CheckedOutStream:CheckSum:0CheckedInputStream:CheckSum:280008503CheckedOutStream:CheckSum:280008503 可以发现，CheckedSum是根据流过的数据流来计算的。在实际使用中，我们可以使用这个办法来简单的判断文件是否完整。 (3)CipherInputStream/CipherOutputStream该子类是Java中的加密类 A CipherInputStream is composed of an InputStream and a Cipher so that read() methods return data that are read in from the underlying InputStream but have been additionally processed by the Cipher. The Cipher must be fully initialized before being used by a CipherInputStream. 之前用过，回去翻翻代码，再补充一下相关的内容，可单独作为一篇来仔细理解。 (4)DataInputStream/DataOutputStream该两个类主要的作用在于帮助我们省去格式转换的麻烦，我们可以直接将特定格式的内容写入输出流或者从输入流中读到信息，使用起来也比较简单，直接上代码吧。 package InputStream; import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.util.ArrayList; import javax.swing.text.StyledEditorKit.ForegroundAction; public class TestDataStream { public static void main(String[] args) { ArrayList arrayList=new ArrayList(); for(int i=0;i&lt;10;i++) { Fruit tmp=new Fruit(“Apple”+i, i); arrayList.add(tmp); } try{ FileOutputStream fileOutputStream=new FileOutputStream(&quot;TestDataStream.data&quot;); DataOutputStream dataOutputStream=new DataOutputStream(fileOutputStream); for(Fruit tmp:arrayList) { dataOutputStream.writeUTF(tmp.kind); dataOutputStream.writeInt(tmp.price); } FileInputStream fileInputStream=new FileInputStream(&quot;TestDataStream.data&quot;); DataInputStream dataInputStream=new DataInputStream(fileInputStream); while(dataInputStream.available()&gt;0){ System.out.println(&quot;Get: Kind:&quot;+dataInputStream.readUTF()+&quot; Price:&quot;+dataInputStream.readInt()); } dataInputStream.close(); dataOutputStream.close(); } catch(Exception ex) { ex.printStackTrace(); } } } class Fruit{ public String kind; public int price; public Fruit(String kind,int price){ this.kind=kind; this.price=price; }} 程序的运行结果为： Get: Kind:Apple0 Price:0Get: Kind:Apple1 Price:1Get: Kind:Apple2 Price:2Get: Kind:Apple3 Price:3Get: Kind:Apple4 Price:4Get: Kind:Apple5 Price:5Get: Kind:Apple6 Price:6Get: Kind:Apple7 Price:7Get: Kind:Apple8 Price:8Get: Kind:Apple9 Price:9 至于文件内容中具体是怎么保存的，我们不去做仔细的追求。 (5)DeflaterInputStream/InflaterOutputStream AND InflaterInputStream/DeflaterOutputStream这是两组输入输出流，其实都是用的DEFLATE的加密解密算法，具体的大家可以参阅维基百科 https://zh.wikipedia.org/wiki/DEFLATE，使用这两组输入输出流，可以直接在输出的时候将我们的数据进行加密、解密。这里我们使用 InflaterInputStream/DeflaterOutputStream来实验以下其用法，我们选择一个文件进行读取，压缩，解压。好了，开工。 package InputStream; import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.zip.Deflater;import java.util.zip.DeflaterInputStream;import java.util.zip.DeflaterOutputStream;import java.util.zip.Inflater;import java.util.zip.InflaterInputStream;import java.util.zip.InflaterOutputStream; public class TestDeflaterStream { public static void main(String[] args){ try{ File file=new File(“src/InputStream/TestDeflaterStream.java”); FileInputStream fileInputStream=new FileInputStream(file); FileOutputStream fileOutputStream=new FileOutputStream(“TestDeflaterStream.data”); Deflater deflater=new Deflater(); deflater.setLevel(Deflater.BEST_COMPRESSION); DeflaterOutputStream deflaterOutputStream=new DeflaterOutputStream(fileOutputStream, deflater); byte\\[\\] buffer=new byte\\[8192\\]; System.out.println(&quot;文件 原始长度：&quot;+file.length()); while(fileInputStream.available()&gt;0){ int count=fileInputStream.read(buffer); deflaterOutputStream.write(buffer, 0, count); } deflaterOutputStream.close(); fileInputStream.close(); file=new File(&quot;TestDeflaterStream.data&quot;); fileInputStream=new FileInputStream(file); InflaterInputStream inflaterInputStream=new InflaterInputStream(fileInputStream); fileOutputStream=new FileOutputStream(&quot;TestDeflaterStream.java.data&quot;); System.out.println(&quot;压缩后文件长度：&quot;+file.length()); while(inflaterInputStream.available()&gt;0){ int chardata=inflaterInputStream.read(); fileOutputStream.write(chardata); } fileOutputStream.close(); inflaterInputStream.close(); } catch(FileNotFoundException ex) { ex.printStackTrace(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 程序会加密后保存到一个文件中 TestDeflaterStream.data中，然后解密，放入TestDeflaterStream.java.data 文件大小： 文件 原始长度：1893压缩后文件长度：622 对于文本文档，压缩比还是很不错的，当然，这里选择的是最高的压缩比。 (6)LineNumberInputStream该类在Java中已经是被标志为deprecation，是因为不能准确的对字符统计行数，更好的方法是使用character流的类。如下所说： This class incorrectly assumes that bytes adequately represent characters. As of JDK 1.1, the preferred way to operate on character streams is via the new character-stream classes, which include a class for counting line numbers. 而且提供的功能也比较简单， This class is an input stream filter that provides the added functionality of keeping track of the current line number. A line is a sequence of bytes ending with a carriage return character (&#39;\\r&#39;), a newline character (&#39;\\n&#39;), or a carriage return character followed immediately by a linefeed character. In all three cases, the line terminating character(s) are returned as a single newline character. 只是增加了一个行的标记，比较简单，不多探究。 (7)PushbackInputStreamA PushbackInputStream adds functionality to another input stream, namely the ability to “push back” or “unread” one byte. This is useful in situations where it is convenient for a fragment of code to read an indefinite number of data bytes that are delimited by a particular byte value; after reading the terminating byte, the code fragment can “unread” it, so that the next read operation on the input stream will reread the byte that was pushed back. For example, bytes representing the characters constituting an identifier might be terminated by a byte representing an operator character; a method whose job is to read just an identifier can read until it sees the operator and then push the operator back to be re-read. 顾名思义，该类的主要目的在于帮助我们，可以将读过的数据再推送回去，下次读数据的时候，这些被推送回去的数据就可以被读到。用个小例子来看看其用法。 package InputStream; import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.LineNumberInputStream;import java.io.PushbackInputStream; public class TestPushBackInputStream { public static void main(String[] args){ try{ FileInputStream fileInputStream=new FileInputStream(&quot;src/InputStream/TestPushBackInputStream.java&quot;); PushbackInputStream pushbackInputStream=new PushbackInputStream(fileInputStream,1024); //默认情况下，buf为1 byte\\[\\] buffer=new byte\\[10\\]; int count=0; boolean status=false; while(pushbackInputStream.available()&gt;0) { int tmpcount=pushbackInputStream.read(buffer); count=tmpcount+count; if(count&gt;=20 &amp;&amp; !status) { pushbackInputStream.unread(buffer); status=true; } System.out.print(new String(buffer)); } } catch(FileNotFoundException ex) { ex.printStackTrace(); } catch (IOException e) { // TODO: handle exception e.printStackTrace(); } } } 在文章中，buffer大小为10，当读了两次之后，退回去一次，所以看到运行结果为 package InputStream;putStream; import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.LineNumberInputStream;… 特别注意第一行，发现确实是有效的，同时，我们要注意到一个问题，在程序中，我有这样一条注释 PushbackInputStream pushbackInputStream=new PushbackInputStream(fileInputStream,1024); //默认情况下，buf为1 最开始的时候，我调用的构造函数是 PushbackInputStream pushbackInputStream=new PushbackInputStream(fileInputStream); 即不指定buffer大小，但后来发现一个问题，在unread调用的时候，只能操作一个字节，否则就会报错： java.io.IOException: Push back buffer is full at java.io.PushbackInputStream.unread(Unknown Source) at java.io.PushbackInputStream.unread(Unknown Source) at InputStream.TestPushBackInputStream.main(TestPushBackInputStream.java:25) 最早的时候，以为程序写的有问题，后来查看 PushbackInputStream.java的源代码才发现，其不指定buffer大小的时候，传入的buffer大小为： public PushbackInputStream(InputStream in) { this(in, 1); } public PushbackInputStream(InputStream in, int size) { super(in); if (size &lt;= 0) { throw new IllegalArgumentException(&quot;size &lt;= 0&quot;); } this.buf = new byte\\[size\\]; this.pos = size; } 好了，这就明白了，buffer大小默认为1，我那样用当然会出错啦，这里也给大家提个醒，一定要好好注意。 (五)ObjectInputStream/ObjectOutputStream对于ObjectInputStream和ObjectOuptStream主要是用于Java中对象序列化，单独关于Java的序列化就要探究好长时间，这里不多做分析，留着，等有时间了，专门好好从源代码看看这一部分内容。http://blog.happyhls.me/?p=368 (六)PipedInputStream/PipedOutputStream管道的概念，就是水管一样，尤其是在不同线程的时候，我这个线程放水，然后另外一个线程用来接水，我们看看怎么用就可以，在程序中，我开了两个线程，分别是Sender和Receiver，然后将其中的PipedInputStream和PipedOutputStrem链接到一起。 代码如下： package InputStream; import java.io.IOException;import java.io.PipedInputStream;import java.io.PipedOutputStream; public class TestPipedStream { public static void main(String[] args) { Sender sender = new Sender(); Receiver receiver = new Receiver(); try { sender.getPipedOutputStrem().connect(receiver.getPipedInputStrem()); new Thread(sender).start(); new Thread(receiver).start(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } class Sender extends Thread { private PipedOutputStream pipedOutputStream = new PipedOutputStream(); public PipedOutputStream getPipedOutputStrem() { return pipedOutputStream; } public void run() { while (true) { try { System.out.println(System.currentTimeMillis() \\+ &quot;:Piped 准备写入数据...即将阻塞进程&quot;); pipedOutputStream.write(&quot;发送数据Sender&quot;.getBytes()); System.out.println(System.currentTimeMillis() \\+ &quot;:Piped 写入数据完毕...休眠1s&quot;); Thread.sleep(2000); } catch (IOException e) { e.printStackTrace(); } catch (InterruptedException e) { // TODO: handle exception e.printStackTrace(); } } } } class Receiver extends Thread { private PipedInputStream pipedInputStream = new PipedInputStream(); public PipedInputStream getPipedInputStrem() { return pipedInputStream; } public void run() { while (true) { try { System.out.println(System.currentTimeMillis() \\+ &quot;:Piped 等待数据中...即将阻塞进程&quot;); byte\\[\\] buffer = new byte\\[8192\\]; int count = pipedInputStream.read(buffer); System.out.println(System.currentTimeMillis() + &quot;:接收到数据:&quot; \\+ new String(buffer, 0, count)); Thread.sleep(1000); } catch (IOException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } } } } 运行结果： 1365048086265:Piped 等待数据中…即将阻塞进程1365048086265:Piped 准备写入数据…即将阻塞进程1365048086265:Piped 写入数据完毕…休眠1s1365048087265:接收到数据:发送数据Sender1365048088265:Piped 准备写入数据…即将阻塞进程1365048088265:Piped 写入数据完毕…休眠1s1365048088265:Piped 等待数据中…即将阻塞进程1365048088265:接收到数据:发送数据Sender (七)SequenceInputStreamA SequenceInputStream represents the logical concatenation of other input streams. It starts out with an ordered collection of input streams and reads from the first one until end of file is reached, whereupon it reads from the second one, and so on, until end of file is reached on the last of the contained input streams. SequenceInputStream是将多个输入流合并到一起，形成一个输入流，然后我们就可以对这一个输入流进行访问，从而大大方便了我们的编程。 我们看SequenceInputStream的构造函数 SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e)Initializes a newly created SequenceInputStream by remembering the argument, which must be an Enumeration that produces objects whose run-time type is InputStream.SequenceInputStream(InputStream s1, InputStream s2)Initializes a newly created SequenceInputStream by remembering the two arguments, which will be read in order, first s1 and then s2, to provide the bytes to be read from this SequenceInputStream. 可以看到，只要是InputStream的子类，那我们都可以使用这个累，将其合成一个输入流，从而进行读写，这里我们写这样一个demo package InputStream; import java.io.ByteArrayInputStream;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.io.SequenceInputStream;import java.util.ArrayList;import java.util.Collections;import java.util.Enumeration; public class TestSequenceInputStream { public static void main(String\\[\\] args) throws Exception { ArrayList&lt;InputStream&gt; inputStreams=new ArrayList&lt;InputStream&gt;(); byte\\[\\] tmp=new byte\\[100\\]; for(byte i=0;i&lt;100;i++) { tmp\\[i\\]=i; } inputStreams.add(new ByteArrayInputStream(tmp)); inputStreams.add(new FileInputStream(&quot;src/InputStream/TestSequenceInputStream.java&quot;)); Enumeration&lt;InputStream&gt; enumeration=Collections.enumeration(inputStreams); SequenceInputStream sequenceInputStream=new SequenceInputStream(enumeration); byte\\[\\] buffer=new byte\\[1024\\]; while(true){ int count=sequenceInputStream.read(buffer); if(count==-1) break; System.out.println(new String(buffer,0,count)); } } } 需要注意的一个问题是，在下面的程序段中： while(true){ int count=sequenceInputStream.read(buffer); if(count==-1) break; System.out.println(new String(buffer,0,count)); } 最初使用的是之前的方法： while(sequenceInputStrem.available()&gt;0) 来判断是否还有数据，但在这段的执行过程中，发现第二个数据流不会被读取，但在之前的程序中运行一直正常，我的理解是因为，SequenceInputStream包装了多个InputStream，但 available()函数的时候，调用的是第一个输入流中的available函数，所以会出现退出循环的问题，为了验证这个想法，修改了一下代码 byte\\[\\] buffer=new byte\\[1024\\]; while(sequenceInputStream.available()&gt;0){ int count=sequenceInputStream.read(buffer); System.out.println(new String(buffer,0,count)); } sequenceInputStream.read();//多读数据一次 while(sequenceInputStream.available()&gt;0){ int count=sequenceInputStream.read(buffer); System.out.println(new String(buffer,0,count)); } 看到这句了吧，当两个数据流切换的时候，让其多读了一次，如果不加这一语句，程序依然只打印第一个InputStream流的信息 sequenceInputStream.read();//多读数据一次 加入这句之后，执行正常，当然，会丢失下一个输入流的第一个字符数据。当然可以保存下来，但还是比较麻烦，还是用count是否为-1来判断是否到输入流的结尾比较妥当。 (八) StringBufferInputStream该输入流也被取消掉了，看定义是将字符串转化为输入流的类，既然JDK都摒弃了，那我们也就不做探究，如果用到，再来仔细查看。 This class allows an application to create an input stream in which the bytes read are supplied by the contents of a string. Applications can also read bytes from a byte array by using a ByteArrayInputStream. (九) PrintStreamPrintStream在Java中是一个非常重要的处理流，要知道，我们常用的System.out其本质上就是封装了个PrintStream，该类非常强大，支持各种格式化输出，使用起来比较简单，而且由于System.out的缘故，我们用的也比较熟悉，有什么新颖的功能，用到的时候再添加进来。","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"How Android get information of installed app?","slug":"how-android-get-information-of-installed-app","date":"2013-03-31T02:29:41.000Z","updated":"2018-10-03T14:31:22.638Z","comments":true,"path":"2013/03/31/how-android-get-information-of-installed-app/","link":"","permalink":"http://yoursite.com/2013/03/31/how-android-get-information-of-installed-app/","excerpt":"","text":"做Android开发也已经很久了，但发现到现在为止，需要什么功能的时候，仍然需要查来查去，即使是之前做过的也是这样，所以干脆在blog里面加个分类，记录一下自己用过的内容。 本文章主要是记录一下，怎么去获取已经安装的应用程序的各种信息。 首先先定位到相关的API，在Android的Reference中，我们可以看到官方是这样对PackageManager进行介绍的 Class for retrieving various kinds of information related to the application packages that are currently installed on the device. You can find this class through [getPackageManager()](http://developer.android.com/reference/android/content/Context.html#getPackageManager()). 由此可见，该类是用来获取在设备上的安装的程序的各种信息，使用Context类中的 getPackageManager()可以获取类的一个实例。看看下面都有什么成员变量和方法，在成员变量中，我们注意到有这些： int GET_ACTIVITIES PackageInfo flag: return information about activities in the package in activities.int GET_CONFIGURATIONS PackageInfo flag: return information about hardware preferences in PackageInfo.configPreferences and requested features in PackageInfo.reqFeatures.int GET_DISABLED_COMPONENTS PackageInfo flag: include disabled components in the returned info.int GET_GIDS PackageInfo flag: return the group ids that are associated with an application.int GET_INSTRUMENTATION PackageInfo flag: return information about instrumentation in the package in instrumentation.int GET_INTENT_FILTERS PackageInfo flag: return information about the intent filters supported by the activity.int GET_META_DATA ComponentInfo flag: return the metaData data Bundles that are associated with a component.int GET_PERMISSIONS PackageInfo flag: return information about permissions in the package in permissions.int GET_PROVIDERS PackageInfo flag: return information about content providers in the package in providers.int GET_RECEIVERS PackageInfo flag: return information about intent receivers in the package in receivers.int GET_RESOLVED_FILTER ResolveInfo flag: return the IntentFilter that was matched for a particular ResolveInfo in filter.int GET_SERVICES PackageInfo flag: return information about services in the package in services.int GET_SHARED_LIBRARY_FILES ApplicationInfo flag: return the paths to the shared libraries that are associated with an application.int GET_SIGNATURES PackageInfo flag: return information about the signatures included in the package.int GET_UNINSTALLED_PACKAGES Flag parameter to retrieve some information about all applications (even uninstalled ones) which have data directories.int GET_URI_PERMISSION_PATTERNS ProviderInfo flag: return the URI permission patterns that are associated with a content provider. 似乎接近了，里面有GET_ACTIVITIES，GET_INTENT_FILTERS等等，都是我们很熟悉的，猜想便是用这些来作为标志，获取不同的信息，再看看方法。 abstract Drawable getActivityIcon(Intent intent)Retrieve the icon associated with an Intent.abstract Drawable getActivityIcon(ComponentName activityName)Retrieve the icon associated with an activity.abstract ActivityInfo getActivityInfo(ComponentName component, int flags)Retrieve all of the information we know about a particular activity class.abstract Drawable getActivityLogo(Intent intent)Retrieve the logo associated with an Intent.abstract Drawable getActivityLogo(ComponentName activityName)Retrieve the logo associated with an activity.abstract List getAllPermissionGroups(int flags)Retrieve all of the known permission groups in the system.abstract int getApplicationEnabledSetting(String packageName)Return the the enabled setting for an application.abstract Drawable getApplicationIcon(String packageName)Retrieve the icon associated with an application.abstract Drawable getApplicationIcon(ApplicationInfo info)Retrieve the icon associated with an application.abstract ApplicationInfo getApplicationInfo(String packageName, int flags)Retrieve all of the information we know about a particular package/application.abstract CharSequence getApplicationLabel(ApplicationInfo info)Return the label to use for this application.abstract Drawable getApplicationLogo(String packageName)Retrieve the logo associated with an application.abstract Drawable getApplicationLogo(ApplicationInfo info)Retrieve the logo associated with an application.abstract int getComponentEnabledSetting(ComponentName componentName)Return the the enabled setting for a package component (activity, receiver, service, provider).abstract Drawable getDefaultActivityIcon()Return the generic icon for an activity that is used when no specific icon is defined.abstract Drawable getDrawable(String packageName, int resid, ApplicationInfo appInfo)Retrieve an image from a package.abstract List getInstalledApplications(int flags)Return a List of all application packages that are installed on the device.abstract List getInstalledPackages(int flags)Return a List of all packages that are installed on the device. 看到里面那些以get开头的函数，注意到里面有两个返回值为List的函数， abstract List&lt;ApplicationInfo&gt; getInstalledApplications)(int flags) Return a List of all application packages that are installed on the device. abstract List&lt;PackageInfo&gt; getInstalledPackages)(int flags) Return a List of all packages that are installed on the device. 貌似这两个函数都能满足我们的需求，那么他们有什么不同呢？其介绍，一个返回的all application packages，一个返回的all packages，看不出什么区别，我们再看看返回值ApplicationInfo和PackageInfo的区别吧： ApplicationInfo：Information you can retrieve about a particular application. This corresponds to information collected from the AndroidManifest.xml’s tag. PackageInfo： Overall information about the contents of a package. This corresponds to all of the information collected from AndroidManifest.xml. 发现了，原来都是从AndroidManifest.xml中读取的，但一个读的是application标签，一个全部读取。进一步查看其成员变量等，发现PackageInfo要比Application信息要全一下，好了，那明白区别之后，我们就开始写吧，这里用的是PackageInfo。 首先我们需要获取PackageInfo的List List listPackageInfos=context.getPackageManager().getInstalledPackages(PackageManager.GET_ACTIVITIES); 这样我们就拿到了一个包含所有安装程序信息的List，这个工作耗时比较长，因此在实际使用的时候，要新开一个线程，否则会将主线程阻塞。然后我们看看PackageInfo都有什么？ public ApplicationInfo applicationInfo Information collected from the tag, or null if there was none. （从这里可以看出，确实从getInstalledPackages函数读到的信息更全面一写） public String packageName The name of this package. public int versionCode The version number of this package, as specified by the tag’s [versionCode](http://developer.android.com/reference/android/R.styleable.html#AndroidManifest_versionCode) attribute. public String versionName The version name of this package, as specified by the tag’s[versionName](http://developer.android.com/reference/android/R.styleable.html#AndroidManifest_versionName) attribute. 我大体列了几个，但发现里面没有Application的图标啥的，从哪找？我们去看看ApplicationInfo里面有什么？ void dumpBack)(Printer pw, String prefix) void dumpFront)(Printer pw, String prefix) Drawable loadIcon)(PackageManager pm) Retrieve the current graphical icon associated with this item. CharSequenceloadLabel)(PackageManager pm) Retrieve the current textual label associated with this item. DrawableloadLogo)(PackageManager pm) Retrieve the current graphical logo associated with this item. XmlResourceParserloadXmlMetaData)(PackageManager pm, String name) Load an XML resource attached to the meta-data of this item. voidwriteToParcel)(Parcel dest, int parcelableFlags)看到了吧，其从 From class android.content.pm.PackageItemInfo继承过来了这些函数，我们就可以读到图标的信息，好了，万事具备了，开工！ 12345678910111213141516171819202122public ArrayList&lt;PackManagerHelperApplicationInfo&gt; getUserApplicationInfos()&#123; ArrayList&lt;PackManagerHelperApplicationInfo&gt; applicationInfos=new ArrayList&lt;PackManagerHelperApplicationInfo&gt;(); List&lt;PackageInfo&gt; listPackageInfos=context.getPackageManager().getInstalledPackages(PackageManager.GET_ACTIVITIES); for(int i=0;i&lt;listPackageInfos.size();i++) &#123; if((listPackageInfos.get(i).applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM)!=0) &#123; continue; &#125; PackManagerHelperApplicationInfo tmpApplicationInfo=new PackManagerHelperApplicationInfo(); tmpApplicationInfo.appName=listPackageInfos.get(i).applicationInfo.loadLabel(context.getPackageManager()).toString(); tmpApplicationInfo.packageName=listPackageInfos.get(i).packageName; tmpApplicationInfo.versionName=listPackageInfos.get(i).versionName; tmpApplicationInfo.versionCode=listPackageInfos.get(i).versionCode; tmpApplicationInfo.appIcon=listPackageInfos.get(i).applicationInfo.loadIcon(context.getPackageManager()); applicationInfos.add(tmpApplicationInfo); &#125; return applicationInfos; &#125; 大家可能注意到， if((listPackageInfos.get(i).applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM)!=0 这句子用来干嘛呢？是用来去掉系统自带的程序的，这个有很多flag，不一一尝试了。 上面这样一折腾，就搞明白了怎么读取信息，也蛮简单。 后记：还有一个小细节，使用 public abstract Intent getLaunchIntentForPackage (String packageName) 可以获取到Launcher中启动的action。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"PackageManaer","slug":"PackageManaer","permalink":"http://yoursite.com/tags/PackageManaer/"}]},{"title":"Python读书笔记-文件","slug":"python-file-notes","date":"2013-03-29T06:37:10.000Z","updated":"2018-10-03T15:10:20.177Z","comments":true,"path":"2013/03/29/python-file-notes/","link":"","permalink":"http://yoursite.com/2013/03/29/python-file-notes/","excerpt":"","text":"好久没写了，回来继续。最近在看Python，记一下，要不以后用的时候，又忘记了。这次看的是Python的文件。 1、打开文件 open函数 help(open） 命令，可以看到open的信息 Help on built-in function open in module __builtin__: open(…)open(name[, mode[, buffering]]) -&gt; file object Open a file using the file() type, returns a file object. This is thepreferred way to open a file. See file.__doc__ for further information.(END) 可以看到，该函数执行会返回一个file类型的变量，是推荐的打开file方式。进一步查看 file.__doc__ mode种类有，‘r’(default)、’w’、’a’ 如果不存在，则会创建新的文件，’b’ 可以以二进制形式打开，’+’可允许同时读和写，’U’可以使python支持通用的回车符，但是‘U’不能和‘w’,’+’，共同使用。对于bufsize来将，0：无buff; 1：一行一行缓冲，再大，就是具体的bufsize了， 2、如果要从标准控制台读入流，可以使用 sys.stdin.read() import systext=sys.stdin.read()words=text.split()print “Count:”,len(words) 执行结果为 echo “This is a test” | python test3_stdin.pyCount: 4 3、文件的关闭:close() #Open a filetry: #Do Somthing finally: file.close() with语句可以自动关闭，需要引入 with_statement模块 from __future__ import with_statement with open(‘somefile.txt’) as somefile: do_something(somefile) 4、迭代文件内容： import sysimport fileinputfilename=sys.argv[1] print ‘by bytes’fileID=open(filename)try: while True: buf=fileID.read(1) if buf: print buf, else: break;finally: fileID.close() print ‘\\nby lines’fileID=open(filename)try: while(True): buf=fileID.readline() if buf: print buf, else: breakfinally: fileID.close() print ‘\\nread all’fileID=open(filename)try: buf=fileID.read() print buf,finally: fileID.close() print ‘\\nfileinput iterator’for line in fileinput.input(filename): print line, print ‘\\nfile iterator’fileID=open(filename)try: for line in fileID: print line,finally: fileID.close() 执行： python test4_file.py test3_stdin.pyby bytesi m p o r t s y st e x t = s y s . s t d i n . r e a d ( )w o r d s = t e x t . s p l i t ( )p r i n t “ C o u n t : “ , l e n ( w o r d s ) by linesimport systext=sys.stdin.read()words=text.split()print “Count:”,len(words) read allimport systext=sys.stdin.read()words=text.split()print “Count:”,len(words) fileinput iteratorimport systext=sys.stdin.read()words=text.split()print “Count:”,len(words) file iteratorimport systext=sys.stdin.read()words=text.split()print “Count:”,len(words)","categories":[{"name":"Python编程","slug":"Python编程","permalink":"http://yoursite.com/categories/Python编程/"}],"tags":[]},{"title":"一篇不错的讲解Java异常的文章(转载）","slug":"repost-excellent-java-exception","date":"2013-03-04T02:08:39.000Z","updated":"2018-10-03T14:48:54.275Z","comments":true,"path":"2013/03/04/repost-excellent-java-exception/","link":"","permalink":"http://yoursite.com/2013/03/04/repost-excellent-java-exception/","excerpt":"","text":"六种异常处理的陋习 你觉得自己是一个Java专家吗？是否肯定自己已经全面掌握了Java的异常处理机制？在下面这段代码中，你能够迅速找出异常处理的六个问题吗？ OutputStreamWriter out = …java.sql.Connection conn = …try { // ⑸ Statement stat = conn.createStatement(); ResultSet rs = stat.executeQuery( “select uid, name from user”); while (rs.next()) { out.println(“ID：” + rs.getString(“uid”) // ⑹ “，姓名：” + rs.getString(“name”)); } conn.close(); // ⑶ out.close(); } catch(Exception ex) // ⑵ { ex.printStackTrace(); //⑴，⑷ } 本文讨论的不是Java异常处理的一般性原则，因为这些原则已经被大多数人熟知。我们要做的是分析各种可称为“反例”（anti-pattern）的违背优秀编码规范的常见坏习惯，帮助读者熟悉这些典型的反面例子，从而能够在实际工作中敏锐地察觉和避免这些问题。 作为一个Java程序员，你至少应该能够找出两个问题。但是，如果你不能找出全部六个问题，请继续阅读本文。 反例之一：丢弃异常 代码：15行-18行。 这段代码捕获了异常却不作任何处理，可以算得上Java编程中的杀手。从问题出现的频繁程度和祸害程度来看，它也许可以和C/C++程序的一个恶名远播的问题相提并论??不检查缓冲区是否已满。如果你看到了这种丢弃（而不是抛出）异常的情况，可以百分之九十九地肯定代码存在问题（在极少数情况下，这段代码有存在的理由，但最好加上完整的注释，以免引起别人误解）。 这段代码的错误在于，异常（几乎）总是意味着某些事情不对劲了，或者说至少发生了某些不寻常的事情，我们不应该对程序发出的求救信号保持沉默和无动于衷。调用一下printStackTrace算不上“处理异常”。不错，调用printStackTrace对调试程序有帮助，但程序调试阶段结束之后，printStackTrace就不应再在异常处理模块中担负主要责任了。 丢弃异常的情形非常普遍。打开JDK的ThreadDeath类的文档，可以看到下面这段说明：“特别地，虽然出现ThreadDeath是一种‘正常的情形’，但ThreadDeath类是Error而不是Exception的子类，因为许多应用会捕获所有的Exception然后丢弃它不再理睬。”这段话的意思是，虽然ThreadDeath代表的是一种普通的问题，但鉴于许多应用会试图捕获所有异常然后不予以适当的处理，所以JDK把ThreadDeath定义成了Error的子类，因为Error类代表的是一般的应用不应该去捕获的严重问题。可见，丢弃异常这一坏习惯是如此常见，它甚至已经影响到了Java本身的设计。 那么，应该怎样改正呢？主要有四个选择： 1、处理异常。针对该异常采取一些行动，例如修正问题、提醒某个人或进行其他一些处理，要根据具体的情形确定应该采取的动作。再次说明，调用printStackTrace算不上已经“处理好了异常”。 2、重新抛出异常。处理异常的代码在分析异常之后，认为自己不能处理它，重新抛出异常也不失为一种选择。 3、把该异常转换成另一种异常。大多数情况下，这是指把一个低级的异常转换成应用级的异常（其含义更容易被用户了解的异常）。 4、不要捕获异常。 结论一：既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。 反例之二：不指定具体的异常 代码：15行。 许多时候人们会被这样一种“美妙的”想法吸引：用一个catch语句捕获所有的异常。最常见的情形就是使用catch(Exception ex)语句。但实际上，在绝大多数情况下，这种做法不值得提倡。为什么呢？ 要理解其原因，我们必须回顾一下catch语句的用途。catch语句表示我们预期会出现某种异常，而且希望能够处理该异常。异常类的作用就是告诉Java编译器我们想要处理的是哪一种异常。由于绝大多数异常都直接或间接从java.lang.Exception派生，catch(Exception ex)就相当于说我们想要处理几乎所有的异常。 再来看看前面的代码例子。我们真正想要捕获的异常是什么呢？最明显的一个是SQLException，这是JDBC操作中常见的异常。另一个可能的异常是IOException，因为它要操作OutputStreamWriter。显然，在同一个catch块中处理这两种截然不同的异常是不合适的。如果用两个catch块分别捕获SQLException和IOException就要好多了。这就是说，catch语句应当尽量指定具体的异常类型，而不应该指定涵盖范围太广的Exception类。 另一方面，除了这两个特定的异常，还有其他许多异常也可能出现。例如，如果由于某种原因，executeQuery返回了null，该怎么办？答案是让它们继续抛出，即不必捕获也不必处理。实际上，我们不能也不应该去捕获可能出现的所有异常，程序的其他地方还有捕获异常的机会??直至最后由JVM处理。 结论二：在catch语句中尽可能指定具体的异常类型，必要时使用多个catch。不要试图处理所有可能出现的异常。 反例之三：占用资源不释放 代码：3行-14行。 异常改变了程序正常的执行流程。这个道理虽然简单，却常常被人们忽视。如果程序用到了文件、Socket、JDBC连接之类的资源，即使遇到了异常，也要正确释放占用的资源。为此，Java提供了一个简化这类操作的关键词finally。 finally是样好东西：不管是否出现了异常，Finally保证在try/catch/finally块结束之前，执行清理任务的代码总是有机会执行。遗憾的是有些人却不习惯使用finally。 当然，编写finally块应当多加小心，特别是要注意在finally块之内抛出的异常??这是执行清理任务的最后机会，尽量不要再有难以处理的错误。 结论三：保证所有资源都被正确释放。充分运用finally关键词。 反例之四：不说明异常的详细信息 代码：3行-18行。 仔细观察这段代码：如果循环内部出现了异常，会发生什么事情？我们可以得到足够的信息判断循环内部出错的原因吗？不能。我们只能知道当前正在处理的类发生了某种错误，但却不能获得任何信息判断导致当前错误的原因。 printStackTrace的堆栈跟踪功能显示出程序运行到当前类的执行流程，但只提供了一些最基本的信息，未能说明实际导致错误的原因，同时也不易解读。 因此，在出现异常时，最好能够提供一些文字信息，例如当前正在执行的类、方法和其他状态信息，包括以一种更适合阅读的方式整理和组织printStackTrace提供的信息。 结论四：在异常处理模块中提供适量的错误原因信息，组织错误信息使其易于理解和阅读。 反例之五：过于庞大的try块 代码：3行-14行。 经常可以看到有人把大量的代码放入单个try块，实际上这不是好习惯。这种现象之所以常见，原因就在于有些人图省事，不愿花时间分析一大块代码中哪几行代码会抛出异常、异常的具体类型是什么。把大量的语句装入单个巨大的try块就象是出门旅游时把所有日常用品塞入一个大箱子，虽然东西是带上了，但要找出来可不容易。 一些新手常常把大量的代码放入单个try块，然后再在catch语句中声明Exception，而不是分离各个可能出现异常的段落并分别捕获其异常。这种做法为分析程序抛出异常的原因带来了困难，因为一大段代码中有太多的地方可能抛出Exception。 结论五：尽量减小try块的体积。 反例之六：输出数据不完整 代码：7行-11行。 不完整的数据是Java程序的隐形杀手。仔细观察这段代码，考虑一下如果循环的中间抛出了异常，会发生什么事情。循环的执行当然是要被打断的，其次，catch块会执行??就这些，再也没有其他动作了。已经输出的数据怎么办？使用这些数据的人或设备将收到一份不完整的（因而也是错误的）数据，却得不到任何有关这份数据是否完整的提示。对于有些系统来说，数据不完整可能比系统停止运行带来更大的损失。 较为理想的处置办法是向输出设备写一些信息，声明数据的不完整性；另一种可能有效的办法是，先缓冲要输出的数据，准备好全部数据之后再一次性输出。 结论六：全面考虑可能出现的异常以及这些异常对执行流程的影响。 改写后的代码 根据上面的讨论，下面给出改写后的代码。也许有人会说它稍微有点?嗦，但是它有了比较完备的异常处理机制。 OutputStreamWriter out = …java.sql.Connection conn = …try {Statement stat = conn.createStatement();ResultSet rs = stat.executeQuery(“select uid, name from user”);while (rs.next()){out.println(“ID：” + rs.getString(“uid”) + “，姓名: “ + rs.getString(“name”));}}catch(SQLException sqlex){out.println(“警告：数据不完整”);throw new ApplicationException(“读取数据时出现SQL错误”, sqlex);}catch(IOException ioex){throw new ApplicationException(“写入数据时出现IO错误”, ioex);}finally{if (conn != null) {try {conn.close();}catch(SQLException sqlex2){System.err(this.getClass().getName() + “.mymethod - 不能关闭数据库连接: “ + sqlex2.toString());}} if (out != null) {try {out.close();}catch(IOException ioex2){System.err(this.getClass().getName() + “.mymethod - 不能关闭输出文件” + ioex2.toString());}}} 本文的结论不是放之四海皆准的教条，有时常识和经验才是最好的老师。如果你对自己的做法没有百分之百的信心，务必加上详细、全面的注释。 另一方面，不要笑话这些错误，不妨问问你自己是否真地彻底摆脱了这些坏习惯。即使最有经验的程序员偶尔也会误入歧途，原因很简单，因为它们确确实实带来了“方便”。所有这些反例都可以看作Java编程世界的恶魔，它们美丽动人，无孔不入，时刻诱惑着你。也许有人会认为这些都属于鸡皮蒜毛的小事，不足挂齿，但请记住：勿以恶小而为之，勿以善小而不为。 ——————————————————————下面是一些java异常集——————————————————————————————- 算术异常类：ArithmeticExecption 空指针异常类：NullPointerException 类型强制转换异常：ClassCastException 数组负下标异常：NegativeArrayException 数组下标越界异常：ArrayIndexOutOfBoundsException 违背安全原则异常：SecturityException 文件已结束异常：EOFException 文件未找到异常：FileNotFoundException 字符串转换为数字异常：NumberFormatException 操作数据库异常：SQLException 输入输出异常：IOException 方法未找到异常：NoSuchMethodException java.lang.AbstractMethodError 抽象方法错误。当应用试图调用抽象方法时抛出。 java.lang.AssertionError 断言错。用来指示一个断言失败的情况。 java.lang.ClassCircularityError 类循环依赖错误。在初始化一个类时，若检测到类之间循环依赖则抛出该异常。 java.lang.ClassFormatError 类格式错误。当Java虚拟机试图从一个文件中读取Java类，而检测到该文件的内容不符合类的有效格式时抛出。 java.lang.Error 错误。是所有错误的基类，用于标识严重的程序运行问题。这些问题通常描述一些不应被应用程序捕获的反常情况。 java.lang.ExceptionInInitializerError 初始化程序错误。当执行一个类的静态初始化程序的过程中，发生了异常时抛出。静态初始化程序是指直接包含于类中的static语句段。 java.lang.IllegalAccessError 违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。 java.lang.IncompatibleClassChangeError 不兼容的类变化错误。当正在执行的方法所依赖的类定义发生了不兼容的改变时，抛出该异常。一般在修改了应用中的某些类的声明定义而没有对整个应用重新编译而直接运行的情况下，容易引发该错误。 java.lang.InstantiationError 实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常. java.lang.InternalError 内部错误。用于指示Java虚拟机发生了内部错误。 java.lang.LinkageError 链接错误。该错误及其所有子类指示某个类依赖于另外一些类，在该类编译之后，被依赖的类改变了其类定义而没有重新编译所有的类，进而引发错误的情况。 java.lang.NoClassDefFoundError 未找到类定义错误。当Java虚拟机或者类装载器试图实例化某个类，而找不到该类的定义时抛出该错误。 java.lang.NoSuchFieldError 域不存在错误。当应用试图访问或者修改某类的某个域，而该类的定义中没有该域的定义时抛出该错误。 java.lang.NoSuchMethodError 方法不存在错误。当应用试图调用某类的某个方法，而该类的定义中没有该方法的定义时抛出该错误。 java.lang.OutOfMemoryError 内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。 java.lang.StackOverflowError 堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误。 java.lang.ThreadDeath 线程结束。当调用Thread类的stop方法时抛出该错误，用于指示线程结束。 java.lang.UnknownError 未知错误。用于指示Java虚拟机发生了未知严重错误的情况。 java.lang.UnsatisfiedLinkError 未满足的链接错误。当Java虚拟机未找到某个类的声明为native方法的本机语言定义时抛出。 java.lang.UnsupportedClassVersionError 不支持的类版本错误。当Java虚拟机试图从读取某个类文件，但是发现该文件的主、次版本号不被当前Java虚拟机支持的时候，抛出该错误。 java.lang.VerifyError 验证错误。当验证器检测到某个类文件中存在内部不兼容或者安全问题时抛出该错误。 java.lang.VirtualMachineError 虚拟机错误。用于指示虚拟机被破坏或者继续执行操作所需的资源不足的情况。 java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。 java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。 java.lang.ArrayStoreException 数组存储异常。当向数组中存放非数组声明类型对象时抛出。 java.lang.ClassCastException 类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为强制类型转换异常。 java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 java.lang.CloneNotSupportedException 不支持克隆异常。当没有实现Cloneable接口或者不支持克隆方法时,调用其clone()方法则抛出该异常。 java.lang.EnumConstantNotPresentException 枚举常量不存在异常。当应用试图通过名称和枚举类型访问一个枚举对象，但该枚举对象并不包含常量时，抛出该异常。 java.lang.Exception 根异常。用以描述应用程序希望捕获的情况。 java.lang.IllegalAccessException 违法的访问异常。当应用试图通过反射方式创建某个类的实例、访问该类属性、调用该类方法，而当时又无法访问类的、属性的、方法的或构造方法的定义时抛出该异常。 java.lang.IllegalMonitorStateException 违法的监控状态异常。当某个线程试图等待一个自己并不拥有的对象（O）的监控器或者通知其他线程等待该对象（O）的监控器时，抛出该异常。 java.lang.IllegalStateException 违法的状态异常。当在Java环境和应用尚未处于某个方法的合法调用状态，而调用了该方法时，抛出该异常。 java.lang.IllegalThreadStateException 违法的线程状态异常。当县城尚未处于某个方法的合法调用状态，而调用了该方法时，抛出异常。 java.lang.IndexOutOfBoundsException 索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。 java.lang.InstantiationException 实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。 java.lang.InterruptedException 被中止异常。当某个线程处于长时间的等待、休眠或其他暂停状态，而此时其他的线程通过Thread的interrupt方法终止该线程时抛出该异常。 java.lang.NegativeArraySizeException 数组大小为负值异常。当使用负数大小值创建数组时抛出该异常。 java.lang.NoSuchFieldException 属性不存在异常。当访问某个类的不存在的属性时抛出该异常。 java.lang.NoSuchMethodException 方法不存在异常。当访问某个类的不存在的方法时抛出该异常。 java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。 java.lang.NumberFormatException 数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。 java.lang.RuntimeException 运行时异常。是所有Java虚拟机正常操作期间可以被抛出的异常的父类。 java.lang.SecurityException 安全异常。由安全管理器抛出，用于指示违反安全情况的异常。 java.lang.StringIndexOutOfBoundsException 字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。 java.lang.TypeNotPresentException 类型不存在异常。当应用试图以某个类型名称的字符串表达方式访问该类型，但是根据给定的名称又找不到该类型是抛出该异常。该异常与ClassNotFoundException的区别在于该异常是unchecked（不被检查）异常，而ClassNotFoundException是checked（被检查）异常。 java.lang.UnsupportedOperationException 不支持的方法异常。指明请求的方法不被支持情况的异常。 异常 javax.servlet.jsp.JspException: Cannot retrieve mapping for action /Login （/Login是你的action名字） 可能原因 action没有再struts-config.xml 中定义，或没有找到匹配的action，例如在JSP文件中使用 &lt;html:form action=”Login.do”.将表单提交给Login.do处理，如果出现上述异常，请查看struts-config.xml中的定义部分，有时可能是打错了字符或者是某些不符合规则，可以使用strutsconsole工具来检查。 —————————————————————————————————————– 异常 org.apache.jasper.JasperException: Cannot retrieve definition for form bean null 可能原因 这个异常是因为Struts根据struts-config.xml中的mapping没有找到action期望的form bean。大部分的情况可能是因为在form-bean中设置的name属性和action中设置的name属性不匹配所致。换句话说，action和form都应该各自有一个name属性，并且要精确匹配，包括大小写。这个错误当没有name属性和action关联时也会发生，如果没有在action中指定name属性，那么就没有name属性和action相关联。当然当action制作某些控制时，譬如根据参数值跳转到相应的jsp页面，而不是处理表单数据，这是就不用name属性，这也是action的使用方法之一。 —————————————————————————————————————– 异常 No action instance for path /xxxx could be created 可能原因 特别提示：因为有很多中情况会导致这个错误的发生，所以推荐大家调高你的web服务器的日志/调试级别，这样可以从更多的信息中看到潜在的、在试图创建action类时发生的错误，这个action类你已经在struts-config.xml中设置了关联（即添加了标签）。 在struts-config.xml中通过action标签的class属性指定的action类不能被找到有很多种原因，例如：定位编译后的.class文件失败。Failure to place compiled .class file for the action in the classpath (在web开发中，class的的位置在r WEB-INF/classes，所以你的action class必须要在这个目录下。例如你的action类位于WEB-INF/classes/action/Login.class,那么在struts-config.xml中设置action的属性type时就是action.Login). 拼写错误，这个也时有发生，并且不易找到，特别注意第一个字母的大小写和包的名称。 —————————————————————————————————————– 异常 javax.servlet.jsp.JspException: No getter method for property username of bean org.apache.struts.taglib.html.BEAN 可能原因 没有位form bean中的某个变量定义getter 方法 这个错误主要发生在表单提交的FormBean中，用struts标记&lt;html:text property=”username”&gt;时，在FormBean中必须有一个getUsername()方法。注意字母“U”。 —————————————————————————————————————– 异常 java.lang.NoClassDefFoundError: org/apache/struts/action/ActionForm 可能原因 这个错误主要发生在在classpath中找不到相应的Java .class文件。如果这个错误发生在web应用程序的运行时，主要是因为指定的class文件不在web server的classpath中（/WEB-INF/classes 和 /WEB-INF/lib）。在上面的错误中，原因是找不到ActionForm类。 —————————————————————————————————————– 异常 javax.servlet.jsp.JspException: Exception creating bean of class org.apache.struts.action.ActionForm: {1} 可能原因 Instantiating Struts-provided ActionForm class directly instead of instantiating a class derived off ActionForm. This mightoccur implicitly if you specify that a form-bean is this Struts ActionForm class rather than specifying a child of this classfor the form-bean. Not associating an ActionForm-descended class with an action can also lead to this error. —————————————————————————————————————– 异常 javax.servlet.jsp.JspException: Cannot find ActionMappings or ActionFormBeans collection 可能原因 不是标识Struts actionServlet的标记就是映射.do扩展名的标记或者两者都没有在web.xml中声明。 在struts-config.xml中的打字或者拼写错误也可导致这个异常的发生。例如缺少一个标记的关闭符号/&gt;。最好使用struts console工具检查一下。 另外，load-on-startup必须在web.xml中声明，这要么是一个空标记，要么指定一个数值，这个数值用来表servlet运行的优先级，数值越大优先级越低。 还有一个和使用load-on-startup有关的是使用Struts预编译JSP文件时也可能导致这个异常。 —————————————————————————————————————– 异常 java.lang.NullPointerException at org.apache.struts.util.RequestUtils.forwardURL(RequestUtils.java:1223) 可能原因 在struts-config.xml中的forward元素缺少path属性。例如应该是如下形式： —————————————————————————————————————– 异常 javax.servlet.jsp.JspException: Cannot find bean org.apache.struts.taglib.html.BEAN in any scope Probable Causes 试图在Struts的form标记外使用form的子元素。这常常发生在你在&lt;/html:form&gt;后面使用Struts的html标记。另外要注意可能你不经意使用的无主体的标记，如&lt;html:form … /&gt;，这样web 服务器解析时就当作一个无主体的标记，随后使用的所有标记都被认为是在这个标记之外的，如又使用了&lt;html:text property=”id”&gt;还有就是在使用taglib引入HTML标记库时，你使用的prefix的值不是html。 —————————————————————————————————————– 异常 javax.servlet.jsp.JspException: Missing message for key xx.xx.xx Probable Causes 这个key的值对没有在资源文件ApplicationResources.properties中定义。如果你使用eclipse时经常碰到这样的情况，当项目重新编译时，eclipse会自动将classes目录下的资源文件删除。 资源文件ApplicationResources.properties 不在classpath中应将资源文件放到 WEB-INF/classes 目录下，当然要在struts-config.xml中定义) —————————————————————————————————————– 异常 Cannot find message resources under key org.apache.struts.action.MESSAGE 可能原因 很显然，这个错误是发生在使用资源文件时，而Struts没有找到资源文件。 Implicitly trying to use message resources that are not available (such as using empty html:options tag instead of specifyingthe options in its body – this assumes options are specified in ApplicationResources.properties file) XML parser issues – too many, too few, incorrect/incompatible versions —————————————————————————————————————– 异常 Strange and seemingly random characters in HTML and on screen, but not in original JSP or servlet. 可能原因 混和使用Struts的html:form标记和标准的HTML标记不正确。 使用的编码样式在本页中不支持。 —————————————————————————————————————– 异常 “Document contained no data” in Netscape No data rendered (completely empty) page in Microsoft Internet Explorer 可能原因 使用一个Action的派生类而没有实现perform()方法或execute()方法。在Struts1.0中实现的是perform()方法，在Struts1.1中实现的是execute()方法，但Struts1.1向后兼容perform()方法。但你使用Struts1.1创建一个Action的派生类，并且实现了execute()方法，而你在Struts1.0中运行的话，就会得到”Document contained nodata” error message in Netscape or a completely empty (no HTML whatsoever) page rendered in Microsoft Internet Explorer.”的错误信息。 ————————————————————————————————————————— 异常 ServletException: BeanUtils.populate 解决方案 在用Struts上传文件时,遇到了javax.servlet.ServletException: BeanUtils.populate异常。 我的ActionServlet并没有用到BeanUtils这些工具类。后来仔细检查代码发现是在jsp文件里的form忘了加enctype=&quot;multipart/form-data&quot; 了。所以写程序遇到错误或异常应该从多方面考虑问题存在的可能性，想到系统提示信息以外的东西。 —————————————————————————————————————————- 1. 定义Action后, 如果指定了name, 那么必须要定义一个与它同名的FormBean才能进行form映射.2. 如果定义Action后, 提交页面时出现 “No input attribute for mapping path…” 错误, 则需要在其input属性中定义转向的页面.3. 如果插入新的数据时出现 “Batch update row count wrong:…” 错误, 则说明XXX.hbm.xml中指定的key的类型为原始类型(int, long),因为这种类型会自动分配值, 而这个值往往会让系统认为已经存在该记录, 正确的方法是使用java.lang.Integer或java.lang.Long对象.4. 如果插入数据时出现 “argument type mismatch” 错误, 可能是你使用了Date等特殊对象, 因为struts不能自动从String型转换成Date型,所以, 你需要在Action中手动把String型转换成Date型.5. Hibernate中, Query的iterator()比list()方法快很多.6. 如果出现 “equal symbol expected” 错误, 说明你的strtus标签中包含另一个标签或者变量, 例如: &lt;html:select property=”test” onchange=”&lt;%=test%&gt;”/&gt; 或者 &lt;html:hidden property=”test” value=”&lt;bean:write name=”t” property=”p”/&gt;”/&gt; 这样的情况… ————————————————————————————————————————— 错误：Exception in thread “main” org.hibernate.exception.SQLGrammarException: Could not execute JDBC batch update原因与解决： 因为Hibernate Tools（或者Eclipse本身的Database Explorer）生成.hbn.xml工具中包含有catalog=”**“（表示数据库名称）这样的属性,将该属性删除就可以了 ————————————————————————————————————————— 错误：org.hibernate.ObjectDeletedException: deleted object would be re-saved by cascade (remove deleted object from associations) 原因与解决： 方法1 删除Set方的cascade 方法2 解决关联关系后，再删除 方法3 在many-to-one方增加cascade 但值不能是none 最后一招： 检查一下hashCode equals是否使用了id作为唯一标示的选项了；我用uuid.hex时是没有问题的；但是用了native，就不行了，怎么办？删除啊！ —————————————————————————————————————————- 问题：今天用Tomcat 5.5.12，发现原来很好用的系统不能用了，反复测试发现页面中不能包含 taglib，否则会出现以下提示：HTTP Status 500 -type Exception reportMessage description The server encountered an internal error () that prevented it from fulfilling this request.exceptionorg.apache.jasper.JasperException: /index.jsp(1,1) Unable to read TLD “META-INF/tlds/struts-bean.tld” from JAR file”file:**/WEB-INF/lib/struts.jar”:原因：更新了工程用的lib文件夹下的jar，发布时也发布了servlet.jar和jsp-api.jar。解决：把jsp-api.jar删除就解决这个问题了。—————————————————————————————————————————– 错误： java.lang.NullPointerException 原因： 发现 dao 实例、 manage 实例等需要注入的东西没有被注入（俗称空指针异常）解决：这个时候，你应该查看日志文件；默认是应用服务器的 log 文件，比如 Tomcat 就是 [Tomcat 安装目录 ]/logs ；你会发现提示你：可能是：org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sf’ defined in ServletContextresource [/WEB-INF/applicationContext.xml]: Initialization of bean failed; nested exception isorg.hibernate.HibernateException: could not configure from URL: file:src/hibernate.cfg.xmlorg.hibernate.HibernateException: could not configure from URL: file:src/hibernate.cfg.xml……………………….Caused by: java.io.FileNotFoundException: src\\hibernate.cfg.xml可能是：org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘sessionFactory’ defined inServletContext resource [/WEB-INF/applicationContext.xml]: Initialization of bean failed; nested exception isorg.hibernate.MappingException: Resource: com/mcc/coupon/model/UserRole.hbm.xml not foundorg.hibernate.MappingException: Resource: com/mcc/coupon/model/UserRole.hbm.xml not found然后你就知道原因是因为配置文件的解析出了错误，这个通过 Web 页面是看不出来的。更多的是持久化影射文件出的错误；导致了没有被解析；当然你需要的功能就无法使用了。 —————————————————————————————————————————- 错误：StandardWrapperValve[action]: Servlet.service() for servlet action threw exception javax.servlet.jsp.JspException: Cannot retrieve mapping for action /settlementTypeManage 或者： type Status report message Servlet action is not available description The requested resource (Servlet action is not available) is not available. 原因： 同 上 —————————————————————————————————————————- 错误StandardWrapperValve[jsp]: Servlet.service() for servlet jsp threw exceptionjava.lang.ClassNotFoundException: org.apache.struts.taglib.bean.CookieTei界面错误具体描述： org.apache.jasper.JasperException: Failed to load or instantiate TagExtraInfo class: org.apache.struts.taglib.bean.CookieTei 原因与解决： &lt;方案一&gt;你的“html:”开头的标签没有放在一个html:form中 &lt;方案二&gt;重新启动你的应用服务器，自动就没有这个问题 转自 http://blog.chinaunix.net/uid-10178376-id-100986.html","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Java正则表达式","slug":"java-regex","date":"2013-03-02T12:10:54.000Z","updated":"2018-10-03T15:02:32.188Z","comments":true,"path":"2013/03/02/java-regex/","link":"","permalink":"http://yoursite.com/2013/03/02/java-regex/","excerpt":"","text":"正则表达式，常用的一些转义字符啥的，拿过来，记下来，用时备查 1、特殊字符^ 一行的开头$ 一行的结束() 表达式[] 表达式{} 表达式出现的频率 {1}出现1次，{1-3}出现1-3次* 任意次+ 一次或多次? 0次或1次. 除了换行符之外的任意字符\\ 转义后面的字符| 多种匹配的或 2、预定义的字符 \\d digital 数字\\D NOT DIGITAL 非数字\\s space 空白字符 包括 空格|制表符|回车符|换页符|换行符 等等\\S NOT SPACE 非空白字符\\w word单词字符 包括 0-9|A-Z|a-z|_\\W NOT WORD 非单词字符 3、方括号的用法 (1)枚举 [abc]表示a、b、c中的任意一个字符(2)表示范围（-） [a-z]表示从字符a-字符z(3)表示求否（^） [^a-z]表示除了a-z之外的其他字符(4)表示运算与（&amp;&amp;） [a-z&amp;&amp;[def]]表示d、e或者f(5)表示运算并 [a-d[m-p]]表示a-dm-p 4、边界控制 \\b 单词边界\\B 非单词边界\\A 输入的开头\\G 前一个匹配的结尾\\Z 输入的结尾，仅仅用于最后的结束符\\z 输入的结尾 5、正则表达式工作模式：Greedy（贪婪模式）-&gt;默认、Reluctant（勉强模式）-?、Possessive（占有模式、仅Java，少用）-+ Greedy：尽可能多的匹配 Reluctant：尽可能烧得匹配 常用正则表达式： 匹配中文字符的正则表达式： [/u4e00-/u9fa5]匹配双字节字符(包括汉字在内)：[^/x00-/xff]应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）String.prototype.len=function(){return this.replace([^/x00-/xff]/g,”aa”).length;}匹配空行的正则表达式：/n[/s| ]/r匹配HTML标记的正则表达式：/&lt;(.)&gt;.|&lt;(.) //&gt;/匹配首尾空格的正则表达式：(^/s)|(/s$) Java的使用import java.util.regex.Matcher;import java.util.regex.Pattern; public class TestRegex { public static void main(String[] args) { String data=”This is your phone number: 123-456-789”; Pattern p=Pattern.compile(“\\\\d+-\\\\d+-\\\\d+”); Matcher m=p.matcher(data); if(m.matches()) System.out.println(“matches():”+m.group()); else System.out.println(“matches not found!”); if(m.lookingAt()) System.out.println(“lookingAt():”+m.group()); else System.out.println(“lookingAt not found”); if(m.find()) System.out.println(“find():”+m.group()); else System.out.println(“find() not found”); Pattern p_tmp=Pattern.compile(&quot;\\\\\\s&quot;); String\\[\\] str=p_tmp.split(data); for(String tmp:str) { System.out.println(tmp); } } } 其运行结果为 matches not found!lookingAt not foundfind():123-456-789Thisisyourphonenumber:123-456-789 在运行的时候，出现过 Invalid escape sequence (valid ones are \\b \\t \\n \\f \\r \\“ \\‘ \\\\ )的错误，其错误原因为 Pattern p=Pattern.compile(“\\\\d+-\\\\d+-\\\\d+”); 之前写成了 Pattern p=Pattern.compile(“\\\\d+-\\\\d+-\\\\d+”); 而在Java中，\\是保留字符，因此必须使用\\\\将其转义 在上述文中中在匹配之后调用过3种方法 matches()、lookingAt()、find()其主要的区别如下： matches()是对整个字符串进行匹配，只有整个字符串都匹配成功了，才会返回true lookingAt()是对前面的字符进行匹配，只有匹配的字符位于整个字符串的最前面，才会返回true find()则是只要在整个字符串中匹配到相应的字符，无论在什么位置，都返回true 如果查找到字符串，则调用 m.group()，可以返回子字符串，另外还有 m.start() m.end()返回开始及结束的位置 在Java中还有spilit函数用于将字符串分离，如上面中使用\\s来使用空格分离单词 reset()函数，用来在寻找完成下一个字符串之后，继续用来在下一个字符串中寻找。 在Java的正则表达式中，分组也是很好用的一个功能，如下：import java.util.regex.;import java.util.; public class ThreatAnalyzer { static String threatData = “58.27.82.161@02/10/2005\\n” + “204.45.234.40@02/11/2005\\n” + “58.27.82.161@02/11/2005\\n” + “58.27.82.161@02/12/2005\\n” + “58.27.82.161@02/12/2005\\n” + “[Next log section with different data format]“; public static void main(String[] args) { Scanner scanner = new Scanner(threatData); String pattern = “(\\\\d+[.]\\\\d+[.]\\\\d+[.]\\\\d+)@” + “(\\\\d{2}/\\\\d{2}/\\\\d{4})”; while(scanner.hasNext(pattern)) { scanner.next(pattern); MatchResult match = scanner.match(); String ip = match.group(1); String date = match.group(2); System.out.format(“Threat on %s from %s\\n”, date,ip); } }} 其中正则表达式如下： String pattern = “(\\\\d+[.]\\\\d+[.]\\\\d+[.]\\\\d+)@” + “(\\\\d{2}/\\\\d{2}/\\\\d{4})”; 在每次输入中获取需要的IP地址和日期，同时使用()将正则表达式分组，那么最终的结果中，IP地址保存在group(1)中，而date则保存在group(2)中。同时将字符“@”滤除。需要好好学习。其运行的结果如下： Threat on 02/10/2005 from 58.27.82.161Threat on 02/11/2005 from 204.45.234.40Threat on 02/11/2005 from 58.27.82.161Threat on 02/12/2005 from 58.27.82.161Threat on 02/12/2005 from 58.27.82.161","categories":[{"name":"Java 编程思想","slug":"Java-编程思想","permalink":"http://yoursite.com/categories/Java-编程思想/"},{"name":"Java编程","slug":"Java-编程思想/Java编程","permalink":"http://yoursite.com/categories/Java-编程思想/Java编程/"}],"tags":[]},{"title":"Java杂项","slug":"java-scanner-and-bufferedreader","date":"2013-03-02T11:09:44.000Z","updated":"2018-10-03T14:43:55.324Z","comments":true,"path":"2013/03/02/java-scanner-and-bufferedreader/","link":"","permalink":"http://yoursite.com/2013/03/02/java-scanner-and-bufferedreader/","excerpt":"","text":"1、Java获取键盘输入： (1)、Scanner import java.util.Scanner;public class TestKeyBoardInput { public static void main(String[] args) { Scanner sc=new Scanner(System.in); while(sc.hasNext()) { System.out.println(“输入的是：”+sc.next()); } }} 2、BufferedReader BufferedReader是Java IO中的一个字符、包装流，必须建立在另外一个字符流基础之上。需要注意的是，System.in是字节流，使用InputStreamReader将System.in包装为字符流。 import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader; public class TestKeyBoardInput { public static void main(String[] args) throws IOException { BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); String buffer=null; while((buffer=br.readLine())!=null) { System.out.println(“输入的是:”+buffer); } }}","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"《疯狂Java讲义》-泛型(Generic)","slug":"java-carzy-java-generic","date":"2013-02-26T12:06:09.000Z","updated":"2018-10-03T14:59:49.380Z","comments":true,"path":"2013/02/26/java-carzy-java-generic/","link":"","permalink":"http://yoursite.com/2013/02/26/java-carzy-java-generic/","excerpt":"","text":"Java的泛型-Java的参数化类型 1、构造器： 当创建带有泛型声明打自定义类的时候，构造器名还是原来的类名，不要增加泛型声明，而再使用的时候，可以增加泛型声明来调用。比如说，Apple类，其构造器名仍然为Apple，而不是Apple,但在调用的时候，可以使用Apple的形式来调用。 2、从泛型类派生子类 创建了带泛型声明的接口、父类之后，可以继承接口或父类，但要注意的是，在使用的时候不能再包含类型形参，比如下面的是错误的： public class A extends Apply{} 此处正确的写法应该为 public class A extends Apple或者 public class A extends Apple 需要注意的是，如果使用public class A extends Apple则其中所有的T类型形参都会被替换成String，则在子类实现的时候就需要我们特别注意类型的转换。(原来T的位置已经全部更换为String了) 3、泛型的类型擦除 import java.util.ArrayList; import java.util.List; public class TestGeneric { public static void main(String[] args) { List listInt=new ArrayList(); List listString=new ArrayList(); System.out.println(listInt.getClass()==listString.getClass()); System.out.println(listInt.getClass().gettitle()); System.out.println(listString.getClass().gettitle()); } } 运行结果为： true java.util.ArrayList java.util.ArrayList 可以看出，其实在本质上，其都是ArrayList类，JVM运行时，并不存在泛型。 4、Foo是Bar的子类，那G是G的子类？ 这个问题是在泛型里面需要特别注意的问题，Foo[]是Bar的子类型，但G并不是G的子类型。 在Java中，使用泛型的时候，只要在编译的时候没有出现警告，那在运行的时候，就不会出现 ClassCastException! 有这样的代码 List iList=new ArrayList();List nList=iList;nList.add(0.5); 在编译的时候会出现如下错误！ 错误: 不兼容的类型List nList=iList;需要: List找到: List1 个错误 4-1.类型通配符 ？ 将问号作为通配符传入函数或者类，那么就可以表示，该元素类型可以匹配任何类型，如以下的代码： import java.util.ArrayList;import java.util.List;public class TestGeneric { public static void main(String[] args) { List iList=new ArrayList(); iList.add(1); iList.add(2); iList.add(3); iList.add(4); test(iList); } public static void test(List&lt;?&gt; list) { for(int i = 0 ; i &lt; list.size() ; i++) { System.out.println(list.get(i)); } }} 运行结果为 1234 此处 public static void test(List&lt;?&gt; list); 该函数中list就使用了通配符？，用来代表任意类型，如果将此处的问号改为Number，虽然Number是Integer的父类，但仍然编译不成功。 我们需要注意的是，这种带通配符的List表示的是各种泛型List的父类，并不能将元素加入其中，比方说，下面的代码会出现错误。 List&lt;?&gt; c = new ArrayList();c.add(new Object()); 此处的问题也很明显，我们不知道List c中的元素的类型，因此我们无法向其中添加对象。同时分析源代码可以看到List中add方法的原型为 boolean add(E e); 因此我们可以注意到，添加的元素必须是E的类或者是其子类，此处使用通配符来替换，连类型都不清楚，当然无法添加。 4-2、设定类型通配符的上限 有如下代码： TestGeneric.java package testgeneric;import java.util.ArrayList;import java.util.List;public class TestGeneric { public static void main(String[] args) { List circleList = new ArrayList(); circleList.add(new Circle()); MyCanvas mycanvas=new MyCanvas(); mycanvas.drawAll(circleList); List shapeList = new ArrayList(); shapeList.add(new Circle()); shapeList.add(new Rectangle()); mycanvas.drawAll(shapeList); } } Shape.java package testgeneric;public abstract class Shape { public abstract void draw(MyCanvas c);} Circle.java package testgeneric;import java.awt.Canvas; public class Circle extends Shape { @Override public void draw(MyCanvas c) { // TODO Auto-generated method stub System.out.println(“在画布” + c + “画一个圆”); }} Rectangle.java package testgeneric;import java.awt.Canvas; public class Rectangle extends Shape{ @Override public void draw(MyCanvas c) { // TODO Auto-generated method stub System.out.println(“在画布”+c+”画一个矩形”); } } package testgeneric;import java.util.List; public class MyCanvas { public void drawAll(List&lt;? extends Shape&gt; shape) { for(Shape s:shape) { s.draw(this); } }} 以上是完整的代码，注意到再MyCanvas类中，有如下一行 List&lt;? extends Shape&gt;，这一行就是一个受限的通配符，其意思就代表该未知类型是Shape类或者Shape的一个子类，即此处是上限(upper bound) 4-3 设置类型形参的上限 有如下代码： package testgeneric; public class Apple { T tmp; public static void main(String[] args) { Apple ai = new Apple(); Apple ad = new Apple(); 下面这句将引起编译错误 Apple as = new Apple(); } } 如果需要多继承的话，可以这样写 public class Apple 此处需要注意的是，类必须放在第一位上。","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Java--Collection,ArrayList,HashMap,HashSet","slug":"java-collection","date":"2013-02-26T11:53:20.000Z","updated":"2018-10-03T16:12:52.604Z","comments":true,"path":"2013/02/26/java-collection/","link":"","permalink":"http://yoursite.com/2013/02/26/java-collection/","excerpt":"","text":"HashSet，ArrayList，HashMap等都是在Java中常用的数据结构，简单进行归纳分析。上图从网上搜索而来，简单来说，有如下拓扑结构 java.util.Collection [I] +–java.util.List [I] +–java.util.ArrayList [C] +–java.util.LinkedList [C] +–java.util.Vector [C] +–java.util.Stack [C] +–java.util.Set [I] +–java.util.HashSet [C] +–java.util.SortedSet [I] +–java.util.TreeSet [C] java.util.Map [I] +–java.util.SortedMap [I] +–java.util.TreeMap [C] +–java.util.Hashtable [C] +–java.util.HashMap [C] +–java.util.LinkedHashMap [C] +–java.util.WeakHashMap [C] [I]：接口 [C]：类 根据使用经验和网上搜索的信息总结： Collection接口查看其声明 public interface Collection extends Iterable 发现其中继承了Iterable类，继续跟踪，./Java/laung/Iterable.java public interface Iterable{/*** Returns an iterator over a set of elements of type T.** @return an Iterator.*/Iterator iterator();} 因此，我们可以发现，之所以Collection都可以实现一个Iterator类，是因为其都继承了接口Interalbe，于是，我们再使用的时候，可以使用 Collection c = new ArrayList();Iterator it=c.iterator();while(it.hasNext()){…} 当然，对于Collection我们其实还可以使用foreach来遍历其中的每一个元素 Collection c=new ArrayList();for(Object ob:c){…} List类查看定义可得 public interface List extends Collection List与Set的主要区别在于List中的元素可以重复，且List中的元素位置是确定的，可以类比与Java中打数组来理解，在List中提供了 boolean equals(Obect o) 来判断List中的两个元素是否相等。 此外在List中除了Iterator方法之外，还提供了一个ListIterator，在Iterator基础上增加了如下方法 boolean hasrevious();Object previous();void add(); 在使用List中需要使用迭代器Iterator的时候，使用Iterator更为方便。 ArrayList和Vector类ArrayList和Vector类是List类打两个典型的实现，而这两个类是使用Obect[]来实现的，capacity为其大小，无参实例化的时候，默认的ArrayList的大小为10;当向其中添加元素的时候，capacity为自动增加，因此，当我们明确元素数量会比较大的时候，我们可以使用new ArrayList(int capactiy)构造函数，使其初始化为比较大的空间。除此之外，ArrayList和Vector还提供了两个方法来操作capacity属性： void ensureCapacity(int minCapacity): Increase the capacityvoid trimTosize(); Trim to the min size 相对于ArrayList而言，Vector是一个相对比较老的类，同时，两者另外一个比较重要的区别在于，ArrayList的线程是不安全的，而Vector的线程是安全的，因此可以理解的是Vector的性能比ArrayList要低，但我们可以使用Collections的工具，将ArrayList变成线程安全。 Stack类Stack类是Vector的一个子类，可以实现堆栈这种数据结构，此处不再赘述。其中主要有3个方法 Object peek();Object pop();void push(Object item); 其中peek和pop是将元素弹出堆栈，其区别在于peek只弹出，不删除其中元素，而pop弹出后会删除元素。 固定长度List对于数组来说，有一个工具类：Arrays，该工具类提供了一个asList(Object… a)打方法，可以将一个数组或指定个数打对象转换成一个List集合，要注意的是，该List的集合既不是ArrayList实现类的实例，也不是Vector实现类的实例，而是Arrays打内部类ArrayList的实例。 Arrays.ArrayList是一个固定长度的List集合，程序只能遍历访问该集合中的元素，不可以增加、删除。 Queue接口该接口主要用于模拟队列数据结构，FIFO，主要有下面的方法 void add(Object e):加入元素Object element():获取队列头部元素，但不删除boolean offer(Object e):将指定元素加入队列，当队列容量有限打时候，该方法要优于addObject peek():获取头部元素，但不删除Object poll():获取头部元素，且删除Object remove();获取头部元素，并删除 对于该接口而言，主要有两个实现类LinkedList和PriorityQueue LinkedList类该类继承于List并实现了Queue接口， 与ArrayList、Vector区别： 实现原理不同，ArrayList和Vector都是使用数组实现，而LinkedList则是使用链表来实现(Linked)，因此可以这样理解，在效率上，当使用随机访问时：ArrayList和Vector要比LinkedList更好，而当数据插入删除比较频繁打时候，使用LinkedList的效率要远远高于ArrayList和Vector。同时要注意的问题是，Vector由于实现了线程保护，因此，其最终打效率仍然是比较低的。 PriorityQueue类该类是一个队列，但并不完全满足队列打要求，因为该类主要内部的排列顺序为按照大小来排序 MapMap保存的数据具有映射关系，在Map的集合中保存有两组值，Key+Value，其中Key和Value都可以为任意类型，但Key不可以重复，而Value可以重复。Key和Value之间存在有意义对应的关系。因此可以理解Key放在一起，组成了一个Set集合。 在类的名字上，我们可以发现 Set： ? ? ? ? ? ? ? HashSet、LinkedHashSet、SortedSet(Interface)、TreeSet、EnumSet HashMap： ? HashMap、LinkedHashMap、SortedMap(Interface)、Treemap、EnumMap 实际上，HashSet的实际实现方法就是依赖于HashMap来实现的。 在Java中有一个Hashtable类，HashMap与Hashtable类的关系与HashSet和Vector类似。 Properities类该类为Hashtable类的一个子类，该类可以利用Map的特点，将属性保存在配置文件中，有如下代码 import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.Properties; public class TestProperties { public static void main(String[] args) throws FileNotFoundException, IOException { Properties prop=new Properties(); prop.setProperty(“Name”, “This is name”); prop.setProperty(“Password”, “This is password”); prop.store(new FileOutputStream(“tmp”),”This is comments line”); Properties prop_1=new Properties(); prop_1.load(new FileInputStream(“tmp”)); System.out.println(prop_1); }} 该程序运行结果为： {Name=This is name, Password=This is password} 同时在工作目录下还生成文件tmp，内容为： #This is comments line #Tue Feb 26 19:32:48 CST 2013Name=This is namePassword=This is password 操作集合工具类：Collections该类提供了可以对Set、List、Map等方便操作的类：Collections，功能简介： 1、排序 static void reverse(List list);反转所有集合顺序static viod shuffle(List list):对List集合随机排序static void sort(List list):排序，升序static void sort(List list,Comparator c):根据Comparator顺序进行排序static void swap(List list,int i,int j):将List中i和j位置交换static void rotate(List list,int distance): 2、查找、替换 3、同步控制 Vector和Hashtable分别比HashSet和HashMap的优点就在于其线程是安全的，在Collection中提供了synchronizedXxx方法，用来解决多线程访问的时候的并发问题 代码为 Collection c = Collections.synchronizedCollection(new ArrayList());List list = Collections.synchronizedList(new ArrayList());Set s = Collections.synchronizedSet(new HashSet());Map m = Collections.synchronizedMap(new HashMap());","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Java类-枚举类(enum)","slug":"java-enum","date":"2013-01-26T06:54:09.000Z","updated":"2018-10-03T15:00:18.424Z","comments":true,"path":"2013/01/26/java-enum/","link":"","permalink":"http://yoursite.com/2013/01/26/java-enum/","excerpt":"","text":"枚举类是在很多时候对象都是固定的，实例有限，因而将其封装起来，有这样一段代码。 class Season{ public static final Season SPRING = new Season(“春天”,”这是春天”); public static final Season SUMMER = new Season(“夏天”,”这是夏天”); public static final Season AUTUMN = new Season(“秋天”,”这是秋天”); public static final Season WINTER = new Season(“冬天”,”这是冬天”); private String name; private String desc; private Season(String name,String desc) { this.name = name; this.desc = desc; } public static Season getSeason(int id) { switch(id) { case 1:return SPRING; case 2:return SUMMER; case 3:return AUTUMN; case 4:return WINTER; }; return null; } public String getName() { return this.name; } public String getDesc() { return this.desc; }}public class TestEnum{ public static void main(String[] args) { System.out.println(Season.getSeason(1).getName()); System.out.println(Season.SPRING.getName()); } } 其运行结果为 春天春天 一般常用main函数中的Season.SPRING.getName() 当然现在Java都提供了enum专门的枚举类，暂时用不到，用到再写。","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Java类-toString,equal,","slug":"java-tostring","date":"2013-01-24T12:23:44.000Z","updated":"2018-10-03T15:00:35.727Z","comments":true,"path":"2013/01/24/java-tostring/","link":"","permalink":"http://yoursite.com/2013/01/24/java-tostring/","excerpt":"","text":"Java类的一些笔记： 1、toString方法 Java中所有的类都是Object的子类，因此都拥有toString方法，如果不重写toString类的话，打印出来的是类名@hashCode，而在使用中如果有Person类 Person p = new Person();System.out.println(p);System.out.println(p.toString()); 的执行效果是一样的。实际上，这两个方法可以理解成“自我描述”的方法，因此我们可以重写这个这个类。 2、==和equals比较运算符 对于==运算符，对于基本类型变量和引用型的变量，其实际的效果是不一样的。 对于基本类型变量，其值相等，则==返回true。 对于引用类型变量，当两个变量指向同一个对象的时候，才会返回true。 对于引用类型的变量，我们想要判断其值是否相等的话，我们应该重写equals()方法，最常用的例子是String，下面写一个demo class Temp{ public boolean equals(Object obj) { if(((String)obj).equals(“Test”)) return true; else return false; }}public class TestEqual{ public static void main(String[] args) { Temp temp=new Temp(); System.out.println(temp.equals(“test”)?”True”:”False”); } } 3、单例类(Singleton)类 单例类其目的在于保证该类只有一个对象，比如只允许一个数据库引擎访问节点等等。 方法：将该类的构造器隐藏起来，同时提供一个使用static修饰的public方法，在该方法中检测是否已经有实例，如果有，则直接返回，如果没有，则创建新的实例。例子 class Singleton{ private static Singleton instance; private Singleton(){} public static Singleton getInstance() { if(instance==null) { instance=new Singleton(); } return instance; } } public class TestSingleton{ public static void main(String\\[\\] args) { Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); System.out.println(s1==s2); } } 运行结果为 true 这种思想要记住一下，会很有用。 3、闭包(Closure)和回调 书中举了这样一个例子，有一个Teachable接口和一个Programmer基类，都提供了一个work的方法，方法签名完全相同，但实现的功能不相同，此处有这样一个问题，如果一个人，既是程序员，又是教师，那么该怎么去调用？如果传统的使用方法 创建新类 class TeachableProgrammer extends Programmer implements Teachable的话，在该类中重写work方法，那么只会实现一种办法，为了解决这个问题，使用闭包和回调来完成。 abstract class Programmer{ public void work() { System.out.println(“I am a Programmer”); }}interface Teachable{ public void work();}class TeachableProgrammer extends Programmer{ String name; public TeachableProgrammer() { } public TeachableProgrammer(String name) { this.name=name; } public void teach() { System.out.println(“I am a teacher”); } private class Closure implements Teachable{ public void work() { teach(); } } public Teachable getCallbackReference() { return new Closure(); } } public class TestClosure{ public static void main(String[] args) { TeachableProgrammer tp = new TeachableProgrammer(“Name”); tp.work(); tp.getCallbackReference().work(); }} 运行结果为 I am a ProgrammerI am a teacher 其本质就在于在类TeachableProgrammer中新建了一个内部类，该内部类继承了Teachable接口，然后在内部类中重写重复的方法，在这个方法调用TeachableProgramer中的方法，解决方法名、实现完全一样的情况。","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Java类-修饰符，封装，继承，多态","slug":"java-descriptor","date":"2013-01-22T06:14:54.000Z","updated":"2018-10-03T14:47:38.917Z","comments":true,"path":"2013/01/22/java-descriptor/","link":"","permalink":"http://yoursite.com/2013/01/22/java-descriptor/","excerpt":"","text":"理顺一下Java类的相关知识：1、封装 (1)private,default,protected,public修饰符权限大小123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869|描述符|private|default|protected|public|:--|:--|:--|:--|:--||同一个类内|✓|✓|✓|✓||同一个包内|x|✓|✓|✓||子类中|x|✓|✓|✓||全局| | | |✓|顶级类也可以添加修饰符，但只能添加public或者默认的修饰符。使用public修饰符，则可以全局都可以访问，如果使用default访问，那么只能在包内访问。 访问控制符的使用原则： &lt;1&gt;类的绝大部分属性都应该使用private修饰，除了一些static修饰的、类死于全局变量的属性才考虑使用public修饰。除此之外，有些方法只是用于辅助实现该类的其他方法，这写方法被称为工具方法，工具方法也应该使用private修饰。 &lt;2&gt;如果某个类主要用作其他类的符类，该类中包含的大部分方法可能仅仅希望被其子类重写，而不想被外界直接调用，应该使用protected修饰符来修饰。 &lt;3&gt;希望暴露给其他类自由调用的方法应该使用public来修饰，因此类的构造器通常使用public修饰符，大部分顶级类都应该用public修饰。 (2)、package和import 一般根据功能划分，将相近的功能放在一个包内，一般包的名字可以表示包的继承关系，比如me.happyhls 和 me.happyhls.A import 则是为了简化使用，将package封装好的包直接引用进来，方便调用。 2、类的继承 (1)、每创建一个子类对象，就会相应的创建一个父类的对象。使用sper关键字的时候，总会指向this对应子类所对应的父类对象。 (2)、Java的类可以分为 类class、抽象类abstract class、接口interface 其中类class可以 extends 类、抽象类、也可以implements 接口 抽象类可以extends类、抽象类、也可以implements接口 接口只能extends接口 比较容易记住的是一个 类class如果继承了接口，那么必须实现接口中的全部方法，如果一个抽象类abstract class继承了接口，可以实现，也可以不实现接口中的类。 3、类的多态 (1)、类的多态就是 Base b = new Derived(); (2)、我写了这样一个例子```javainterface Fruit&#123; public String getName(); public void eatFruit();&#125;class Apple implements Fruit&#123; String name=&quot;Apple&quot;; public String getName() &#123; return this.name; &#125; public void eatFruit() &#123; System.out.println(&quot;I eat an/a &quot;+this.getName()); &#125;&#125;class Orange implements Fruit&#123; String name=&quot;Orange&quot;; public String getName() &#123; return this.name; &#125; public void eatFruit() &#123; System.out.println(&quot;I eat an/a &quot;+this.getName()); &#125;&#125;class Banana implements Fruit&#123; String name=&quot;Banana&quot;; public String getName() &#123; return this.name; &#125; public void eatFruit() &#123; System.out.println(&quot;I eat an/a &quot;+this.getName()); &#125;&#125;class EatFruit&#123; public static void eatFruit(Fruit fruit) &#123; fruit.eatFruit(); &#125;&#125;public class Polymorphism&#123; public static void main(String\\[\\] args) &#123; EatFruit.eatFruit(new Apple()); EatFruit.eatFruit(new Orange()); EatFruit.eatFruit(new Banana()); &#125;&#125; 运行结果为123I eat an/a AppleI eat an/a OrangeI eat an/a Banana 我的理解是多态目的在于调用同样一个函数，但实现的功能各有区别，一般有3个条件 继承父类的类，如上面的Fruit接口 重写父类的方法，如上面的Apple,Orange,Banana类 调用的时候调用父类的方法，如上面中1public static void eatFruit(Fruit fruit) 通俗的理解就是，你养了小猫、小狗，你喊一句吃饭啦，都去吃饭，但小猫吃的是猫粮，小狗吃的狗粮。就这样。","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Chapter2、对象与内存控制(3)final关键字的使用","slug":"java-chapter-2-keywords-final","date":"2013-01-21T14:07:45.000Z","updated":"2018-10-03T14:39:45.477Z","comments":true,"path":"2013/01/21/java-chapter-2-keywords-final/","link":"","permalink":"http://yoursite.com/2013/01/21/java-chapter-2-keywords-final/","excerpt":"","text":"在书中，对final关键字的使用做了非常详细的分析,基本上可以认为有以下几个模块： 1、修饰实例变量,此时可以在3个位置进行初始化： (1)、定义的时候 (2)、非静态初始化的时候 (3)、构造方法中 2、修饰类变量,此时可以在2个位置进行初始化： (1)、定义的时候 (2)、非静态初始化的时候 3、相当于“宏替换”的变量： 不管用final关键字来修饰的 类变量、实例变量、还是局部变量，只要使用了final关键字，那么该值就可以在编译的时候确定下来，因此之后调用的时候相当于直接量。类似于C语言中的宏变量。 4、修饰方法： 使用final修饰的方法不能被重写。 5、在匿名类中使用局部变量： 必须加上final关键字","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Chapter2、对象与内存控制(3)继承方法和继承成员变量区别","slug":"java-chapter-3-extends-method-variable","date":"2013-01-21T12:19:41.000Z","updated":"2018-10-03T14:38:56.423Z","comments":true,"path":"2013/01/21/java-chapter-3-extends-method-variable/","link":"","permalink":"http://yoursite.com/2013/01/21/java-chapter-3-extends-method-variable/","excerpt":"","text":"对于类，很重要的特点就是方法和类的继承， 那方法的继承，类的继承，其区别是什么？书中写了这样一段代码 class Base{ int count = 2; public void display() { System.out.println(this.count); }}class Derived extends Base{ int count=20; @Override public void display() { System.out.println(this.count); }}public class P37{ public static void main(String[] args) { Base b = new Base(); System.out.println(b.count); b.display(); Derived d = new Derived(); System.out.println(d.count); d.display(); Base bd =new Derived(); System.out.println(bd.count); bd.display(); Base d2b = d; System.out.println(d2b.count); } } 上面程序的结果为 2220202202 上面4个数字毫无疑问，关键是后面三个 Base bd =new Derived();System.out.println(bd.count);bd.display(); 这三行代码中，System.out.println(bd.count);调用的是继承的变量，但声明的类型为Base型，因此调用的就是Base中的变量。 而bd.display()为继承的方法，而且被覆写，调用的就是子类的方法。 作者是怎么总结的：不管声明时用的什么类型，当通过这写变量调用方法的时候，方法的行为总是表现出他们实际类型的行为;但如果通过这些变量来访问他们所指的对象的实例变量，这写实例变量的值总是表现出声明这些变量所用类型的行为。 因此，就是说，bd方法，用的是Derived中的方法，而变量用的是Base中的变量。 this,super关键字 super关键字没有任何引用对象，不能当成一个真正的引用变量来使用。 书中对父、子对象的存储做了如下的描述： 1、当程序创建一个子类对象的时候，系统不仅为该类中定义的实例变量分配内存，也会为其父类定义的所有的实例变量来分配内存（即使子类中定义了与父类同名的实例变量） 2、如果子类中定义了与父类同名的变量，那么子类中定义的变量会隐藏父类的定义的变量，但其实父类的变量依然存在，并且分坏空间且初始化。 3、为了在子类中访问父类中定义的、被隐藏的实例变量，或者在子类中调用父类定义的或者覆写的方法，可以使用super关键字。 4、如上例子中可以使用(Base)d来访问Base中被隐藏的count变量。","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Chapter2、对象与内存控制(2)构造器显式调用、方法覆写、父类访问子类方法","slug":"java-chapter-2-object-and-memory-constructor-override-parent","date":"2013-01-21T08:53:17.000Z","updated":"2018-10-03T14:38:25.822Z","comments":true,"path":"2013/01/21/java-chapter-2-object-and-memory-constructor-override-parent/","link":"","permalink":"http://yoursite.com/2013/01/21/java-chapter-2-object-and-memory-constructor-override-parent/","excerpt":"","text":"1、一般的类的继承结构为 Object&lt;–Parent&lt;–Mid&lt;–Sub 因此我们在new一个Sub类的时候，会先调用Mid的构造函数，而在Mid的构造函数中，会先调用Parent的构造函数，同样的，在Parent的构造函数中，会先调用Object的构造函数。 这些调用，可能是显式的调用，也可能是隐式的调用，这个都可以。 2、父类访问字类对象的实例变量 这一个问题，是我在看这本书的时候纠结了一会的问题，子类调用父类的时候，用起来都没有问题，那父类调用子类？是怎么个情况。书中有一个程序，我将其加了几行，更便于理解。 class Base{ int i = 2; { System.out.println(“In static initialize Base”); i=1111; } public Base() { System.out.println(“In Construction function Base”); this.display(); System.out.println(this.getClass()); } public void display() { System.out.println(“i in Base “+i); }}class Derived extends Base{ int i=22; { System.out.println(“In static initialize derived”); i=3333; } public Derived() { System.out.println(“In Construction function Derived”); i = 2; } public void display() { System.out.println(“i in Derived “+i); }}public class P32{ public static void main(String[] args) { new Derived(); }} 到底应该输出什么？不好回答，看看结果，分析分析。 In static initialize BaseIn Construction function Basei in Derived 0class DerivedIn static initialize derivedIn Construction function Derived 其实答案很明了的，正如前面所说，子类在初始化执行其构造函数的时候，会首先调用其父类的构造函数，因此就对于本例子来讲，Derived是Base的子类，main函数中，执行new Derived();调用了Derived的无参构造方法，此时会隐式调用父类的无参构造方法，即Base()，父类完成其初始化，因此此时，父类的i会初始化，调用非静态初始化方法、构造方法来初始化，而构造方法中调用了this.display(); 那按理说应该打印的是这里面的1111呀？为什么不是？关键是此时的this指的是什么？我们用getClass()来看一下，一看，明白了，原来这里的this是子类，调用的方法也是子类的方法。而在子类中，此时的i并没有初始化，当然默认值就是0 有个疑问，这里是否可以理解成子类的display方法Override了父类的方法？这个需要再思考思考。 而此时，如果将 System.out.println(“In Construction function Base”); 改为 System.out.println(“In Construction function Base”+iiii); 则会打印 In Construction function Base1111 与刚刚想的相同，如果将子类中的display方法注释掉，则运行结果如下 In static initialize BaseIn Construction function Base1111i in Base 1111class DerivedIn static initialize derivedIn Construction function Derived 即Base类的构造方法中调用的display函数为Base的函数，这边的关键在于，如果子类中也包含display方法的时候，而此时的this是子类，因此此时调用的子类的方法，当子类中不存在该方法时，直接调用父类的方法。","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Chapter2、对象与内存控制(1)初始化、成员变量、类变量的初始化时机","slug":"java-chapter-2-object-and-memory-constructor-initialization","date":"2013-01-21T07:44:42.000Z","updated":"2018-10-03T14:37:56.507Z","comments":true,"path":"2013/01/21/java-chapter-2-object-and-memory-constructor-initialization/","link":"","permalink":"http://yoursite.com/2013/01/21/java-chapter-2-object-and-memory-constructor-initialization/","excerpt":"","text":"1、实例变量&amp;类变量 Java的变量大体分为成员变量and局部变量。 其中局部变量可以分为 形参、方法内局部变量、代码块中的局部变量。 局部变量作用时间短暂，因此大多数的局部变量都保存在栈的内存中。 类体内定义的变量被称为成员变量(Field)。没有staitc修饰，则成为非静态变量\\实例变量;如果有static修饰，则称为静态变量\\类变量。换言说，static作用在于将实例成员变为类成员。加了static，成员变为类本身，不加，则是类的实例。 可以这样理解，类变量，在JVM中，每一个类变量都只需要对应一个内存空间与之相对应，而对于实例变量，则是每一个实例变量都要有内存空间与每一个相对应，因此，在实际使用中，实例变量的内存消耗要远远大于类变量的。 有这样一个语法 public class RightDef{ int num1=num2+2; static int num2=20;} 注意，这个代码是正确的，因为num2是类变量，而num1为实例变量，在Java中，类变量的初始化是优先于成员变量的。 2、实例变量的初始化时机 书中有这样的代码： class Cat{String name;int age;public Cat(String name,int age){System.out.println(“执行构造器初始化”);this.name=name;this.age=age;}{weight=2.0;System.out.println(“执行非静态初始化”);}double weight=2.3;public String toString(){return(“Cat Name:”+this.name+”,Age=”+this.age+”,Weight=”+this.weight);}}class Cat2{String name;int age;public Cat2(String name,int age){System.out.println(“执行构造器初始化”);this.name=name;this.age=age;}double weight=2.3;{weight=2.0;System.out.println(“执行非静态初始化”);}public String toString(){return(“Cat Name:”+this.name+”,Age=”+this.age+”,Weight=”+this.weight);}}public class P24{public static void main(String[] args){Cat cat=new Cat(“Kitty”,1);System.out.println(cat.toString());Cat2 cat2=new Cat2(“Tom”,2);System.out.println(cat2.toString());}} 执行结果为： 执行非静态初始化执行构造器初始化Cat Name:Kitty,Age=1,Weight=2.3执行非静态初始化执行构造器初始化Cat Name:Tom,Age=2,Weight=2.0 根据书和这个例子，我们可以得到以下的结论： 1、实例变量在定义变量、构造器函数、非静态初始化中都可以进行，可以根据实际的需要来选择。 2、非静态的初始化区域和定义变量初始化的时候，其作用是等价的，即其效果是完全一样的，而这两部分执行的顺序，则完全依照其在代码中位置的先后顺序决定。 3、非静态的初始化区域\\定义变量 其执行会比构造器中对变量的改变要早。 3、类变量的初始化时机 与成员变量类似，可以在定义的时候进行初始化，也可以在静态初始化块中进行初始化，而如果两部分都存在初始化，则器最终的效果也同成员变量初始化类似，都是根据在代码中的位置的先后顺序来决定的。","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Java运行 Unsupported major.minor version 51.0 错误","slug":"java-notes-major-minor-error","date":"2013-01-21T03:00:06.000Z","updated":"2018-10-03T15:01:38.795Z","comments":true,"path":"2013/01/21/java-notes-major-minor-error/","link":"","permalink":"http://yoursite.com/2013/01/21/java-notes-major-minor-error/","excerpt":"","text":"今天写了简单的Java程序，运行的时候不知道为啥出现这个问题 happy@happy-HP-Compaq-dx7518-MT:~/Study/CrazyJava$ java FieldTest Exception in thread “main” java.lang.UnsupportedClassVersionError: FieldTest : Unsupported major.minor version 51.0 at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:634) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) at java.net.URLClassLoader.defineClass(URLClassLoader.java:277) at java.net.URLClassLoader.access$000(URLClassLoader.java:73) at java.net.URLClassLoader$1.run(URLClassLoader.java:212) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:205) at java.lang.ClassLoader.loadClass(ClassLoader.java:321) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:294) at java.lang.ClassLoader.loadClass(ClassLoader.java:266) Could not find the main class: FieldTest. Program will exit. 仔细检查后发现是因为Java的编译器和运行的版本不一样的问题造成的 java -version “1.6.0_24” javac -version javac 1.7.0_09 典型的高版本编译，低版本运行。找到问题就简单了，可以配置路径搞定。我的是用apt-get安装的，源比较快，直接remove掉之前所有的版本 sudo apt-get remove openjdk* 然后重新安装 sudo apt-get install openjdk-7-jdk 问题搞定","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Chapter 1 : 数组与内存控制","slug":"java-chapter-1-array-and-memory","date":"2013-01-21T02:29:14.000Z","updated":"2018-10-03T14:37:00.788Z","comments":true,"path":"2013/01/21/java-chapter-1-array-and-memory/","link":"","permalink":"http://yoursite.com/2013/01/21/java-chapter-1-array-and-memory/","excerpt":"","text":"前段时间去图书馆借了本书《疯狂Java》，觉得写的特别好，把需要注意的地方记一下。 第一章 讲的是数组 1、数组的初始化 数组的初始化主要有两种方式{静态初始化，动态初始化} 其中，静态的初始化长的这个样子 String[] data={“1111”,”2222”,”3333”} 而动态初始化则是 String[] star=new String[5]; 这个是都知道，不过之前没有那么细细的去考虑过，Java的静态初始化的数组是没有办法去改变其长度的，比如上面 data数组，其长度固定为3,不会变化。 同时，在使用的时候，也要注意到，对于Java中的数组，不能同时使用静态初始化和动态初始化，也就是说，不能说用 String[] tmp=new String[5]{“111”,”222”} 这样使用是不允许的， 2、数组为什么要初始化？ 这一个小节，作者讲了这样一个问题，数组初始化的原因？到底做了什么事情？ 我想这样来理解，Java的数组是引用型的变量，所谓引用型的变量，我们用 String[] data={“1111”,”2222”,”3333”} 来举例，其中的data变量是一个引用型的变量，其存储区域为 程序的堆栈中，如果没有初始化，那么对于整个数组而言，就只有data一个引用变量，没有指向有效的数据地址，当然没办法使用这个数组。因此从这个角度来理解，其初始化就相当于我们在C/C++的指针中，给指针变量指向有效地址的过程，而上面语句中静态初始化的{“1111”,”2222”,”3333”}则是直接在堆内存中分配相应的内存单元，并且将数据保存进去，并且将data指向该内存单元。 3、数组初始化原理的分析： 正如第一小部分所说，数组初始化分为静态和动态两种。书中举了这样一个例子。 int[] iArr;iArr=new int[]{1,2,3,4,5} 第一行中的int[] iArr是定义了一个iArr的数组变量，该变量为引用类型，没有指定有效的内存，因此暂时是无法使用的。 而第二行则静态初始化，在堆内存中分配相应的存储单元，并存入输入，然后将iArr指向该堆内存地址。 作者有这样一个总结： 所有的局部变量都是放在栈内存中保存的，不管是基本类型的变量，还是引用类型的变量。 而引用类型变量所引用的对象，是一直在堆内存中的。 对Java来将，堆内存中的地址不能直接访问，因而必须通过引用对象来访问。 4、关于Java的多维数组 在实际中，Java的多维数组实现的机制就是Java数组。 如int[][] A;其就是元素为int[]的数组。","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"Ubuntu Apache+php+MySQL 搭建记录","slug":"ubuntu-apache-php-mysql-install","date":"2013-01-18T07:57:08.000Z","updated":"2018-10-03T15:11:27.763Z","comments":true,"path":"2013/01/18/ubuntu-apache-php-mysql-install/","link":"","permalink":"http://yoursite.com/2013/01/18/ubuntu-apache-php-mysql-install/","excerpt":"","text":"最近需要搭建一个Apache+php+MySQL的服务器，遇到了一些的问题，记录下来，供朋友们参考。 Ubuntu下的apt源真是好东西，基本上不用自己动手，搭建的过程是参考Ubuntu WiKi来的（http://wiki.ubuntu.org.cn/Apache#.E5.AE.89.E8.A3.85LAMP），用的是其中第一个方法： sudo apt-get install apache2 php5-mysql libapache2-mod-php5 mysql-server，很稳，一次搞定。 http服务的端口从80改到8080,网上大多数流传的还是之前版本的更改方法，新版的配置文件做了很大的改动，摸索了一下，能干活，具体修改的位置是： 1. sites-enable目录下的000-default文件，将其中的改为 2. 将ports.conf文件中的 NameVirtualHost :80 和 Listen 80 改为 NameVirtualHost :8080和Listen 8080 改完之后，执行sudo /etc/init.d/apache2 restart 重启服务，再访问 127.0.0.1:8080 即可 关于Apache的另外一个问题就是，启动服务之后，只有本机可以访问，局域网无法访问，一直以为是Apache配置的问题，后来发现其原因在于Ubuntu自身的的ufw的问题(UFW WiKi http://wiki.ubuntu.org.cn/UFW%E9%98%B2%E7%81%AB%E5%A2%99%E7%AE%80%E5%8D%95%E8%AE%BE%E7%BD%AE)，解决方法如下 1.sudo ufw status 察看ufw是否已经启动 2.sudo ufw allow 8080 允许外部访问8080端口 以上两步，就可以搞定局域网访问的问题。 最近Ubuntu上的Android虚拟机无法上网了，得捣鼓一下。","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"好久没写博客了。。。。","slug":"blog-long-time-abandon","date":"2013-01-18T07:31:32.000Z","updated":"2018-10-03T14:56:50.917Z","comments":true,"path":"2013/01/18/blog-long-time-abandon/","link":"","permalink":"http://yoursite.com/2013/01/18/blog-long-time-abandon/","excerpt":"","text":"好久没有写过博客了，后来觉得还是写一些比较好，可以记录自己平时的一点经验，记录自己的一点感想吧，所以，这个博客，又拾起来了，不过话说，又到了该要续费的时候了。。。。","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"一个小小的网站登录工具","slug":"windows-a-simple-website-login-tool","date":"2010-08-30T15:33:15.000Z","updated":"2018-10-03T15:17:21.774Z","comments":true,"path":"2010/08/30/windows-a-simple-website-login-tool/","link":"","permalink":"http://yoursite.com/2010/08/30/windows-a-simple-website-login-tool/","excerpt":"","text":"还记得自己上高中的时候用过Delphi7，那是对于写个代码相当迷糊，记得自己做的好滑稽的一件事情就是写的那个把html网页格式的小说提取出来转换为txt格式的小软件，当时起的名字叫html2txt，现在感觉也是比较时尚简约的，当时自己刚刚把PASCAL折腾的了解了，对Delphi是丈二的和尚，什么都不懂，只是知道这个可以用PASCAL来做可视化编程，当时，迷迷糊糊的把程序的小框框给画出来了，可里面的程序不会写了，用PASCAL那个DOS下的编译器通过了，复制过来怎么修改都不行，后来要上交作品了，竟然想出调用DOS命令加dos下执行PASCAL编译过的exe文件这样的奇思妙想，想想也挺好玩的，记得当时好多的处理步骤都是批处理完成的，还是小鱼同学帮忙写的，结果每个文件转换的太慢，循环的又太快，每次转换都要落下很多，呵呵，为此又加了若干空循环来延时，后来我的机器没问题了，跑到别人机器又有文件没有了，其实想想也是，每个机子的速度不一样，怎么能保证不落下文件。仍然记得当时不管用谁的机器调试，必然保证CPU 100%的壮举。(^__^) 嘻嘻…… 后来就是高考，失败，伤心，大学，无聊，上了大一就开了C语言的课程，后来又学了C++，折腾回来折腾过去什么也不知道了，暑假又看了点Java，结果现在只会用javac调试，java运行。。。。。前两天闲的没事，突然发现自己还有一本Delphi的书，就想找个Delphi看看，结果发现Delphi竟然出新版了，很是激动，查了查资料，Delphi2010已经是Delphi新出的第二版了，感觉真不错， 马上下载，从安装，到更新，折腾了有半天，就 写了题目里面的一个小程序，为了自己查成绩方便，本来想直接从服务器上抓取暑假在软件里面显示，后来想想也够折腾的，对jsp也什么不懂，干脆直接做个登陆器就可以了，于是就有了这个软件。 很久不用Delphi，也不了解jsp，Pascal也忘得差不多了，写这个东西好多都来自于网络和自己的理解，现在整理出来，如果有需要程序源码的朋友，欢迎E-mail我，我会尽快给你发过去。 第一个部分是 本地保存用户信息的加密 因为有个记住密码功能，肯定要在用户电脑上保存上一次的登陆信息，信息不可能直接摆在那个地方，因此就用到了加密，本来想选个算法写个加密程序，可必然得是可逆加密，后来想到了BASE64加密，这个加密方式在网络上用到的比较多，想Flashget，迅雷，QQ旋风的专用链用的都是BASE64加密，而这个加密对于本地保存来说也足够用了，本来打算根据算法写，后来查了查，DELPHI里有现成的函数 USES EncdDecd function EncodeString(const Input: string): string; // 编码 function DecodeString(const Input: string): string; // 解码 直接使用就可以，不用多说。 第二个部分就是关于程序打开指定网页的部分 用户输入信息，将信息作为参数打开网页，就可以实现登陆，这一部分就不多说，这里用的到的也是Delphi的现成函数。 USES ShellAPI; 用默认浏览器打开 ShellExecute(Handle, ‘open’, ‘Explorer.exe’, ‘www.happyhls.org&#39;, nil, SW_SHOWNORMAL); 指定浏览器打开： 用IE打开 ShellExecute(Handle, ‘open’, ‘IExplore.EXE’, ‘www.happyhls.org&#39;, nil, SW_SHOWNORMAL); 用火狐打开 ShellExecute(Handle, ‘open’, ‘firefox.exe’, ‘www.happyhls.org&#39;, nil, SW_SHOWNORMAL); 程序没什么技术含量，写了仅仅是为了方便自己，仅供参考。代码显示的不好，见谅。 exe下载 http://www.happyhls.org/blog/wp-content/uploads/2010/08/教务登陆.zip 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251// A small program designed by happyhls// welcome visit my siteunit Unit1;interfaceusesWindows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,Dialogs, StdCtrls, Shellapi, ShlObj,EncdDecd;typeTForm1 = class(TForm)Button1: TButton;Button2: TButton;Label1: TLabel;Label2: TLabel;Label3: TLabel;Edit1: TEdit;Edit2: TEdit;CheckBox1: TCheckBox;RadioButton1: TRadioButton;RadioButton2: TRadioButton;Label4: TLabel;Label5: TLabel;procedure Button1Click(Sender: TObject);procedure Button2Click(Sender: TObject);procedure FormCreate(Sender: TObject);procedure Label4Click(Sender: TObject);varprivate&#123; Private declarations &#125;public&#123; Public declarations &#125;end;varForm1: TForm1;f: textfile;num, ReadKey: string;implementation&#123;$R *.dfm&#125;procedure TForm1.FormCreate(Sender: TObject);varflag: integer;address,Key: String;pidl: pItemIDList;buffer: array \\[0 .. 255\\] of char;//strlen: integer;i: integer;begin&#123; 我的文档位置 &#125;SHGetSpecialFolderLocation(application.Handle, 5, pidl);SHGetPathFromIDList(pidl, buffer); // 转换成文件系统的路径address := strpas(buffer);address := address + '\\\\qdujw.ini'; //保存路径assignfile(f, address);if FileExists(address) thenbeginreset(f);&#123;以上部分关联文件&#125;readln(f, flag);readln(f, num);Edit1.Text := num;readln(f, ReadKey);if flag = 1 thenbegin&#123;base64 解密函数&#125;Key:=DecodeString(ReadKey);CheckBox1.Checked := true;Edit2.Text := Key;endelseCheckBox1.Checked := false;closefile(f);end;end;procedure TForm1.Label4Click(Sender: TObject);beginShellExecute(0,'open','www.happyhls.org',nil,nil,SW_SHOWNORMAL);end;procedure TForm1.Button1Click(Sender: TObject);varurl,Key,address: string;i: integer;pidl: pItemIDList;buffer: array \\[0 .. 255\\] of char;begin&#123; 我的文档位置 &#125;SHGetSpecialFolderLocation(application.Handle, 5, pidl);SHGetPathFromIDList(pidl, buffer); // 转换成文件系统的路径address := strpas(buffer);address := address + '\\\\qdujw.ini';assignfile(f,address);rewrite(f);num := Edit1.Text;ReadKey := Edit2.Text;&#123; 加密 &#125;Key:=EncodeString(ReadKey);&#123; 是否输出密码到文件冲 &#125;if (CheckBox1.Checked = true) thenbeginwriteln(f,1); &#123; f=1 代表 保存密码 &#125;writeln(f,num);writeln(f,Key);endelsebeginwriteln(f,0);writeln(f,num);writeln(f,'No passwordsaved');end;closefile(f);url := '';if RadioButton1.Checked thenbeginurl :=URL表达式，带参数。endelsebeginurl :=URL表达式，带参数。end;ShellExecute(Handle, 'open', Pwidechar(url), nil, nil, SW_SHOWNORMAL);close;end;&#123; 退出按钮 &#125;procedure TForm1.Button2Click(Sender: TObject);beginclose;end;end.","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"建个博客的那些事儿","slug":"blog-how-to-build","date":"2010-04-22T14:39:30.000Z","updated":"2018-10-03T14:56:56.224Z","comments":true,"path":"2010/04/22/blog-how-to-build/","link":"","permalink":"http://yoursite.com/2010/04/22/blog-how-to-build/","excerpt":"","text":"很多朋友都问我博客是怎么建起来的，可能大家都以为建个自己的博客是个很难的事，写这篇文章，就是想告诉大家，一个博客的搭建就那么回事，域名+空间+WordPress（程序） 首先是域名域名是什么？这个我想我不用解释，我们总不能指望别人记住你网站的IP吧（当然，记住域名别人也不见得会访问我们的博客，呵呵 :idea: ），简单的理解，域名就像大家的名字一样，有个域名，就可以方便的访问我们的网站。 域名有很多，最常见的不过是 com,org,net…….，当然这些都是收费的，大约一年也就60,70左右吧，还有些大家可能见过的比较少，想name,cc,biz,等等，当然，这些可以解释为什么有时候我们老是感觉这些域名怪怪的，呵呵，域名比较新，用的少，当然感觉怪怪的了，当然这些新奇的域名并不见得便宜，一般都要比com那类贵一些。。。当然也有便宜的，像.info域名,第一年收费才不到10块钱，当然是人民币，便宜吧，几只冰糕就省下这个钱了，当然info域名也有个缺点，就是网站的权证可能比前面介绍的要小一些，还有就是以后的话就会正常收费了。、。。。 到现在，我们就该有个大体的域名的概念了吧，那么到哪里去买呢？国内比较好的是万网，新网，当然，这个网站比较好，也比较贵，呵呵，大家也可以到这些网站的二级服务商上去注册，我的域名就是在新网的二级服务商华夏上注册的，感觉还不错，服务也挺好，当然如果大家E文挺好的话可以去美国的godaddy，这个网站极力推荐~（自己当时注册的时候没注意到这个网站，后悔中。。。。）大家注册的时候一定选好服务商，虽然可以 域名转出 ，但是挺麻烦的，不推荐，大家还是一步就位，选好了。。。 当然也有免费的顶级域名，比如说 .tk 其中TK域名注册方便，推荐使用。 .org.ru ……这些用着也比较不错，org.ru 大家可以访问 happyhls.org.ru tk大家可以访问 happyhls.tk 看看效果，呵呵（其中一个为转发，一个为附加域） 其次是空间这个更好理解，我们总不能想着整天开着自己的电脑做服务器吧，我们一般购买的空间都是虚拟主机，就是很多人共用一台服务器，共用一个IP，这个，大家可以去淘宝上自己淘就可以，如果你想一步到位，买个稳定的话也可以购买域名商的空间，因为绝大多数的域名商都在卖空间，一般这些空间比较稳定些，当然价格也会比较贵一些，当然，空间有国内的，也有国外的，一般来讲，国内的空间速度会快一些，但国内的空间都需要备案，比较麻烦一些，国外的就简单些，不需要这些手续。这里还有一点，一般虚拟主机要选择稳定一些的，如果和你公用一个IP的网站是些垃圾内容或者不够和谐的内容的话，你的网站访问也可能受到影响哦~~ 最后就是WordPress大家建博客的话，推荐WordPress，这个是现在最流行的博客程序，有中文版，有大量的主题，大量的插件。。。对于以后的维护，更新，都很方便。本博客使用的就是该程序。。。推荐使用。而且安装过程也极其简单，可以说，你只要会安装软件，就会使用WordPress。。。 好了，说了这么多，希望对那些想要建立博客却感觉无处下手的朋友能有所帮助。。。详细的内容可以问我或者谷歌之。。。。呵呵","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"},{"name":"WordPress","slug":"Java编程/WordPress","permalink":"http://yoursite.com/categories/Java编程/WordPress/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://yoursite.com/tags/WordPress/"}]},{"title":"Windows 7下使用H3C inode软件802.1x认证上网方法","slug":"windows-h3c-802-1x","date":"2010-03-07T13:11:08.000Z","updated":"2018-10-03T15:17:04.146Z","comments":true,"path":"2010/03/07/windows-h3c-802-1x/","link":"","permalink":"http://yoursite.com/2010/03/07/windows-h3c-802-1x/","excerpt":"","text":"宿舍一直是有两种上网方式，一种就是ADSL，就和大家用的一样，另一种就是学校的网络，是H3C的802.1x认证的校园网，放假之前开始免费使用，感觉还不错，下载速度挺快。今天，回学校，宿舍ADSL还没有冲费，只能用校园网了，本来以为很简单的一个事，装上那个拨号程序H3C inode就行了，可忘了自己以前用的系统是WinXP，现在用的系统是WIN7了，设置起来就麻烦些~ 一开始，我是一路下一步，直接安装了拨号程序，重启后发现个问题，拨号程序里老是有“网卡设备已被禁用”的提示，一直拨不上号，想起前两天一次网线掉了，结果网络出错导致网卡被停用的错误，难道又是这么回事？打开“设备管理器”发现这个设备运行正常，可能是其他的原因~ 想来想去，当时Windows Seven RTM刚推出的时候，win7的兼容性是有个很大的问题的，难道又是这回事？试一试就知道，先使用兼容性模式试试。 在桌面的快捷方式上点击右键（当然也可以找到该程序），选择 属性，切换到兼容性选项卡。如图所示~ 选择其中的 改所有用户的设置 ，进入下面的界面， 在 以兼容模式运行这个程序 的选项上打上勾，选择其中的“Windows Vista（Service Pack 2）”，然后勾选下面的“以管理员身份运行此程序”，确定即可。 本来以为这样一番设置就可以解决问题，可没有想到的是在拨号还是和一开始那样子提示，实在无奈，该怎么弄呢？ :???: 继续用同学机器上网查找答案，想想win7出来也一段时间了，官方网站上应该有解法吧，发现官网论坛上有同学也在讨论，而且有了解决方法。 原来，需要设置兼容性的不只只是这一个程序，我们打开安装目录（在快捷方式上单击右键，选择 查找文件夹就行，默认在C:\\Program Files\\H3C\\iNode Client），然后找到AuthenMngService、eSafe_monitor、iNode Client、iNodeMon 、REVerify这几个可执行程序，如果文件不存在就不需设置，和上面同样的步骤设置兼容性，设置以管理员身份运行，设置完成后，再拨号就OK了。:grin: 后记，在尝试解决问题的时候，发现安装之后依然没法访问，后来发现原来设置兼容性的时候程序没有退出，于是重启系统，再拨号，问题解决~","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[]},{"title":"PPPoe ADSL更改DNS的方法","slug":"windows-dns-pppoe-adsl","date":"2010-03-04T04:30:51.000Z","updated":"2018-10-03T15:18:04.868Z","comments":true,"path":"2010/03/04/windows-dns-pppoe-adsl/","link":"","permalink":"http://yoursite.com/2010/03/04/windows-dns-pppoe-adsl/","excerpt":"","text":"在上一篇的文章中说了说怎么在局域网上网中设置DNS的方法，可以让我们自己去寻找最快速的DNS服务器，可以避免电信、联通的满页面的广告。可这个方法一般适用于共享上网，或者是在学校、写字楼，或者是在家中使用路由器上网的方法，可很多朋友还是PPPOE拨号上网的方法来上网，这该怎么弄呢？上篇文章的方法已经不起作用，下面介绍我们如何设置来使用PPPOE拨号时也能够自己设置DNS. ADSL上网一般有两种设备，一种是以太网接口的设备，是我们今天所要说的，另一种则是USB接口的设备，我这里没有设备，没法测试，感兴趣的朋友可以测试一下。 其实和上篇中的方法基本一致，都是更改IPV4协议中的DNS设置，无图无真相，上图给大家详细介绍。 这个是windows系统，以win7为例： 我们打开“网络连接”窗口， 在 拨号连接 处点击右键，选择属性，切换到 网络 选项，出现如下窗口 选中IPV4,点击 属性，进入下一步： 选中“使用下面的DNS服务器地址”，然后在下面输入DNS服务器的地址，比如8.8.8.8，就是谷歌的DNS服务器，单击确定即可。 好了，设置我们已经完成了，那到底有没有用呢？我们来看一看，在命令提示符中使用ipconfig命令得到如下窗口 好了，发现了吧，得到的结果看到DNS的服务器已经更改成我们所设置的了~ 同样，在Ubuntu下设置也不麻烦。当然也是真的以太网的ADSL MODEM，USB的暂时没有找到方法。打开连接属性，选则DSL，新建连接。 然后选中自动PPPoe，仅地址，在DNS中输入8.8.8.8，确定即可。 好了，经过我们的一番设置，PPPoe拨号的朋友也可以使用自己喜欢的DNS了~ :shock:","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"},{"name":"Linux编程","slug":"Java编程/Linux编程","permalink":"http://yoursite.com/categories/Java编程/Linux编程/"}],"tags":[{"name":"Linux编程","slug":"Linux编程","permalink":"http://yoursite.com/tags/Linux编程/"}]},{"title":"更改DNS服务器，访问更快，广告更少~","slug":"linux-change-dns-server","date":"2010-03-03T05:23:47.000Z","updated":"2018-10-03T14:57:32.268Z","comments":true,"path":"2010/03/03/linux-change-dns-server/","link":"","permalink":"http://yoursite.com/2010/03/03/linux-change-dns-server/","excerpt":"","text":"在接下来的内容之前，我们先来了解一下DNS,什么叫DNS,DNS是干嘛用的？ DNS 是域名系统 (Domain Name System) 的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务。在Internet上域名与IP地址之间是一对一（或者多对一）的，域名虽然便于人们记忆，但机器之间只能互相认识IP地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，DNS就是进行域名解析的服务器。 DNS 命名用于 Internet 等 TCP/IP 网络中，通过用户友好的名称查找计算机和服务。当用户在应用程序中输入 DNS 名称时，DNS 服务可以将此名称解析为与之相关的其他信息，如 IP 地址。因为，你在上网时输入的网址，是通过域名解析系统解析找到了相对应的IP地址，这样才能上网。其实，域名的最终指向是IP。 （http://baike.baidu.com/view/22276.htm?fr=ala0_1_1） 上面是在百度百科中对DNS的解释，简单的理解，DNS就是把便于记忆的域名转换为不便于记忆的IP地址的过程。于是，我们访问互联网的过程就可以这样理解： 首先我们在地址栏中输入要访问的地址，然后操作系统访问本地的设置或者通过DHCP得到的DNS服务器，请求解析，DNS服务器收到请求后将域名解析为IP地址，传送给我们的电脑，然后我们的浏览器再去根据IP地址去访问相应的文件，下载后通过浏览器展示给大家，于是乎，就得到了我们看到的页面。 好了，过程既然明白了，我们来看，既然我们在访问网页的时候会请求DNS服务器，那么DNS的响应速度，以及和你的电脑的连接速度必然会影响到上网速度，说白了，如果DNS服务器访问速度慢的话，你的感觉就是网速太慢！于是，找个速度好的DNS服务器是一个非常重要的问题。 当然，有的地方我们上网时在访问网页时会出现一个广告页面，当我们输入网址错误时，返回的是一个拥有巨多广告内容的出错页面，这些都是DNS服务器的问题，这些都可以通过修改DNS服务器来解决。当然，怎么解决呢？follow me~ 怎么更改DNS呢？这个有很多种方法， 在UBUNTU系统下，这样操作就可： 首先桌面右上角的连接处点击右键，选择“编辑连接”，打开如下窗口 选中该连接，点击编辑，在窗口中选择 IPV4 选项卡，选择DHCP仅地址，在DNS中填入想要修改的DNS,如下图 点击应用，就可以了～怎么样，简单吧。 下面是windows下到方法～一样很简单。 修改计算机本地连接属性 方法如下： 打开 本地连接》》属性 ，得到如下窗口 选中其中的IPv4协议，即上图中选中的选项，点击“属性”按钮，如下图 看到其中到DNS服务器选项了吧，选中“使用下面的DNS服务器地址”，然后就可以输入你所选的DNS服务器了，点击确定就可以生效了～ 下面列一列比较著名到DNS服务器吧 GOOGLE DNS: 8.8.8.8 8.8.4.4 看这个IP就知道google有多么强大了，估计，如果这个IP地址到了我国的话，IP的拥有者就会放弃域名地址，来推广自己的IP了，呵呵 :evil: 还有就是OPEN DNS OPEN DNS: 208.67.222.222 208.67.220.220 这个是大名鼎鼎到OPEN DNS 的服务器地址，是比较有名的免费DNS服务器。 当然，使用其他的DNS服务器也非没有缺点，这些服务器都在国外，相应速度肯定一般而言要比ISP提供到要慢一些，但是，当我们访问国外的网站时，这些DNS就要好的多，当然，比较重要的是，这些服务器不会出现想电信，联通那么多到广告。 当然如果你不在乎这些广告，可以使用联通，电信的DNS服务器，这个各地都有，而且速度不一样，可以自己选择，有时候本地的DNS服务器还没有外地的快哦，可以PING一下得到速度。 这是联通的DNS服务器， 202.102.134.68 218.56.57.58 221.205.128.150 202.102.152.3 202.102.154.3 下面是用我联通的网络ping各服务器的结果，系统为UBUNTU PING 202.102.134.68 (202.102.134.68) 56(84) bytes of data. 64 bytes from 202.102.134.68: icmp_seq=1 ttl=251 time=6.68 ms 64 bytes from 202.102.134.68: icmp_seq=2 ttl=251 time=6.69 ms 64 bytes from 202.102.134.68: icmp_seq=3 ttl=251 time=6.72 ms 64 bytes from 202.102.134.68: icmp_seq=4 ttl=251 time=8.85 ms 64 bytes from 202.102.134.68: icmp_seq=5 ttl=251 time=7.02 ms 这个是ping第一个联通DNS服务器的结果，现在没有电信，移动的网络，没法测试，大家可以在自己的网络试试，找个速度最快的，不要因为DNS浪费了自己的上网时间。 :razz: 好了，经过设置，就可以选择比较适合自己的DNS了～","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"},{"name":"Linux编程","slug":"Java编程/Linux编程","permalink":"http://yoursite.com/categories/Java编程/Linux编程/"}],"tags":[{"name":"Linux编程","slug":"Linux编程","permalink":"http://yoursite.com/tags/Linux编程/"}]},{"title":"ubuntu下使用usb modem ADSL上网的方法","slug":"ubuntu-usb-model-adsl","date":"2010-02-28T02:48:14.000Z","updated":"2018-10-03T15:11:49.527Z","comments":true,"path":"2010/02/28/ubuntu-usb-model-adsl/","link":"","permalink":"http://yoursite.com/2010/02/28/ubuntu-usb-model-adsl/","excerpt":"","text":"在Ubuntu下使用ADSL上网，如果是以太网的MODEM来上网的话，并不麻烦，可实际上，电信网通给我们配的很多都是USB网卡的MODEM，我这里的就是星网锐捷的UB5800型USB MODEM,在windows有相应的驱动，当然没有问题，可在UBUNTU下就困难的多，难道我们非要换个MODEM吗？当然不用，下面将我使用的方法分享给大家，感谢Ubuntu社区~感谢小鱼童鞋~ 步骤如下 :mad: 1、我们要确认下Connexant芯片: 在终端执行 lsusb 看是否有“Connexant”字样，有的话则芯片合适，可以参照本文的方法。 2、安装br2684ctl_20040226-1_i386.deb软件包： 在终端执行 sudo apt-get install br2684ctl 附该文件下载（当然可以下载后直接安装） br2684ctl.zip 3、配置上网参数： 在终端执行 sudo br2684ctl -b -c 0 -a 0.33 其中最后的“0.33”两个数字，是vpi和vci值，这个和当地的isp的设置有关，一般来说各个地区可能不大一样，如果不清楚，可以打电话问问当地的ISP。 到这一步的时候，我们把桥搭好了，执行ifconfig 命令，你会发现新多出来的一个nas0的虚拟网卡。 然后启动网卡： 在终端执行 sudo ifconfig nas0 up nas0虚拟网卡已经就绪。 4、配置拨号信息： 现在我们开始可以用这个网卡拨号了，用ubuntu自带的pppoeconf配置。 终端执行 sudo pppoeconf 会自动检测你的nas0，eth0……检测到nas0后就会要你输入各种信息，ADSL账号和密码，然后按照说明操作即可，一般情况下一律选择yes，除了询问是否开机自动连接的那一项。 配置完之后就自动连接。 5、拨号上网： 以后我们每次开机上网都要执行三条命令： （1）首先准备虚拟网卡，命令： sudo br2684ctl -b -c 0 -a 0.33 sudo ifconfig nas0 up （2）进行PPPoE拨号： sudo pon dsl-provider 6、断开连接： 在终端执行 sudo poff dsl-provider 好了，现在就可以通过你的USB MODEM来上网了，enjoy~ 后记 可以将 sudo br2684ctl -b -c 0 -a 0.33 sudo ifconfig nas0 up 这两条命令写到/etc/rc.d/rc.local文件中exit 0 之前，（去掉sudo），就可以实现开机自动执行～","categories":[{"name":"Linux编程","slug":"Linux编程","permalink":"http://yoursite.com/categories/Linux编程/"}],"tags":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/tags/Java编程/"},{"name":"Linux编程","slug":"Linux编程","permalink":"http://yoursite.com/tags/Linux编程/"}]},{"title":"体验IPV6","slug":"windows-ipv6-experience","date":"2010-02-24T13:01:27.000Z","updated":"2018-10-03T15:17:44.799Z","comments":true,"path":"2010/02/24/windows-ipv6-experience/","link":"","permalink":"http://yoursite.com/2010/02/24/windows-ipv6-experience/","excerpt":"","text":"从IPv4到IPv6的发展是历史所趋，记得前段时间用移动的G3上网卡上网的时候，竟然发现每次的IP地址都是同样的那个，真是不知道是移动的IP太少了，让我们用了个大局域网还是IP地址太多了，让我们一人一个IP，不过尝试迅雷下载的时候发现识别为内网，估计是个大局域网，呵呵。IPv6的好处当然不用说，但想让我们从V4时代一下子跨越到IPV6时代，估计是个不可能的事情，现在的设备，除了电脑，绝大多数仅仅支持IPV4,想让大家一下子放弃这些设备，估计有些困难，IPV6的普及必然还需要时间，当然，这不能阻挡我们对新技术的热情，现在已经有很多方法可以让我们在现在的IPv4网络上获得IPv6网络上面的资源. Teredo （又成为面向 IPv6 的 IPv4 NAT [网络地址转换]穿越，是一项 IPv6 / IPv4 过渡技术，在 IPv6 / IPv4 主机位于一个或多个 IPv4 NAT 之后时，用来为单播 IPv6 连接提供地址分配和主机间自动隧道。为了能够通过 IPv4 NAT， IPv6 数据包作为基于 IPv4 的用户数据包协议(UDP) 消息发送出去。本文向读者提供了有关 Teredo 的概述（包括 Teredo 地址以及数据包结构），并且详细解释了 Teredo 客户端的发起通信的方式、特定于 Teredo 主机的中继、仅支持 IPv6 主机使用 IPv4 Internet 的方法、 IPv6 Internet、 Teredo 服务器以及 Teredo 中继。 关于TEREDO的更多知识请参考http://www.microsoft.com/china/technet/prodtechnol/winxppro/maintain/teredo.mspx let‘s go，这里以windows系统为例。 1、安装ipv6协议，对于XP系统来说，IPv6协议默认是没有安装的，我们打开“命令提示符”窗口，运行命令 ipv6 install （中间有个空格） ，稍等一会，出现“successed”提示，则已经安装成功。对于VISTA,及win7系统，则已经默认将ipv6协议安装，跳过这步。 2、指定ISATAP服务路由器。 C:\\ &gt;netsh netsh&gt;int netsh interface&gt;ipv6 netsh interface&gt;ipv6&gt;install netsh interface ipv6&gt;isatap netsh interface ipv6 isatap&gt;set router IP(这里IP地址换成学校提供到isatap路由服务器地址） 完成设置后，通过 ipconfig可以看到一个 2001:da8:200:900e为前缀的v6地址，hostid为0:5efe:x.x.x.x， 其中x.x.x.x为您的真实的IPv4地址，而后即可访问IPv6资源。不过这个方法好像在一些高校管用，公网没有试验成功 :? 下面介绍UBUNTU的方法，这时候就可以看出linux的强大。 首先安装miredo： # sudo apt-get install miredo 然后执行： # ifconfig 显示： teredo Link encap:未指定 硬件地址 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00 inet6 地址: fe80::ffff:ffff:ffff/64 Scope:Link inet6 地址: 2001:0:53aa:64c:38e8:3c6c:8ac0:8962/32 Scope:Global UP POINTOPOINT RUNNING NOARP MTU:1280 跃点数:1 接收数据包:136 错误:0 丢弃:0 过载:0 帧数:0 发送数据包:175 错误:0 丢弃:0 过载:0 载波:0 碰撞:0 发送队列长度:500 接收字节:98118 (98.1 KB) 发送字节:25640 (25.6 KB) 看到 teredo 这个虚拟网卡就可以用它访问 ipv6 了。 赶快体验IPV6吧～～～～～～～～ 后记，虽然IPV6技术很吸引人，但我感觉对我来说，现在还用不大到，当然，我们可以先体验一番，IPV4的丰富资源已经够我们使用了，现在体验IPV6很适合喜欢系统的朋友~","categories":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/categories/Java编程/"}],"tags":[{"name":"Java编程","slug":"Java编程","permalink":"http://yoursite.com/tags/Java编程/"},{"name":"Linux编程","slug":"Linux编程","permalink":"http://yoursite.com/tags/Linux编程/"}]},{"title":"怎么在Wordpress标题栏添加链接 Page links to","slug":"blog-add-page-links-to-in-wordpress","date":"2010-02-20T14:38:10.000Z","updated":"2018-10-03T14:57:55.705Z","comments":true,"path":"2010/02/20/blog-add-page-links-to-in-wordpress/","link":"","permalink":"http://yoursite.com/2010/02/20/blog-add-page-links-to-in-wordpress/","excerpt":"","text":"这两天捣鼓导航，都快了累傻了，一开始安装了个格子导航，就是网上很流行的那种，毕竟discuz，WordPress，phpwind，都装着玩过了，本来以为装个导航也就是个很简单的问题，可没想到那个导航的作者已经将自己的信息深深的加到了各个角落，没办法，只能改代码了，无奈自己对网页代码不精，只能在探索中前进，本想修改好代码之后直接覆盖原文件即可解决问题，可没想到将文件修改好上传之后，发现还是原来那样，那个汗啊~ 去问问小鱼，发现他当时也是这样，没办法，只能删掉重装，无奈，辛辛苦苦弄好了，发现还没有改完全，无语 删掉再来，就这样，昨天折腾了十几次之后，终于搞定了。 今天让各位小盆友试用，发现速度不行，确实，这个导航个性倒是个性，可是基本上全是图片，信息量又少，思考良久，遂决定更换导航，以前用过YLMF出品的，感觉还不错，就下载下来，又是一顿忙活，终于搞定，发现这个就是不错，最起码加载速度，呵呵 这是前话，下面进入正题。http://site.happyhls.org 我的博客是主战，弄好之后我就琢磨着在博客上加一个链接到那个导航上去，想来想去，最好的地方还是那个标题栏上那个导航上是最好的位置，可是那个地方，显示的是页面Pages.如果加链接上是显示在侧边栏中，这个就不是我想要的效果了，如果是页面的话就只能像小鱼那样在页面中那个加载另外我的导航网站，感觉不爽，于是考虑其他方法。忽然想到WordPress的扩展十分丰富，有大量的插件，那是不是就可以用个插件实现呢？上GOOGLE上搜索，发现还真有，“Page Links To”，下载安装，还别说这个插件还真挺好用的，新建一个页面，内容留空，然后在编辑页面的下面中找个Page Links To的选项卡，在其中填入你要指向的地址，就OK了，很方便。 附上使用说明，下面是我的理解： == Installation == 1. Upload the `page-links-to` folder to your /wp-content/plugins/ directory 将‘Page-links-to’目录上传到WordPress的插件目录/wp-content/plugins/中 2. Activate the “Page Links To” plugin in your WordPress administration interface 在WordPress管理页面中激活该插件。 3. Create (or edit) a page or a post to have a title of your choosing (leave the content blank) 创建或编辑一个页面，题目自己起，内容空白即可。 4. Down below, in the advanced section, find the Page Links To widget and add a URL of your choosing 在下面的高级选项中，找到Page Links To 那个选项卡，填入你想要指向的链接 5. Optionally check the boxes to enable link opening in a new browser window, or `302 Moved Temporarily` redirects 这个是设置在新的窗口打开链接与否，勾选上即新窗口打开，后面的那个`302 Moved Temporarily`我也不是很懂。 6. Save the post or page 保存页面。 7. Done! Now that post or page will point to the URL that you chose 完成任务，呵呵~~","categories":[{"name":"WordPress","slug":"WordPress","permalink":"http://yoursite.com/categories/WordPress/"}],"tags":[{"name":"WordPress","slug":"WordPress","permalink":"http://yoursite.com/tags/WordPress/"}]}]}