<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.2">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.2" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Koa是最为常见和广泛使用的Node平台框架之一，阿里开源的Egg.js也是基于Koa扩展。那么Koa到底做了什么呢？洋葱头模型又是怎么一回事？Koa有哪些关键的组件？ 本文为你娓娓道来。">
<meta property="og:type" content="article">
<meta property="og:title" content="Koa源代码分析">
<meta property="og:url" content="https://happyhls.me/2018/10/16/egg-koa-source-code-analysis/index.html">
<meta property="og:site_name" content="happyhls">
<meta property="og:description" content="Koa是最为常见和广泛使用的Node平台框架之一，阿里开源的Egg.js也是基于Koa扩展。那么Koa到底做了什么呢？洋葱头模型又是怎么一回事？Koa有哪些关键的组件？ 本文为你娓娓道来。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://happyhls.me/2018/10/16/egg-koa-source-code-analysis/koa-middlewares-code.jpg">
<meta property="og:image" content="https://happyhls.me/2018/10/16/egg-koa-source-code-analysis/koa-middlewares-onion.jpg">
<meta property="og:image" content="https://happyhls.me/2018/10/16/egg-koa-source-code-analysis/koa-middlewares-sample.jpg">
<meta property="og:updated_time" content="2018-10-16T16:28:13.248Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Koa源代码分析">
<meta name="twitter:description" content="Koa是最为常见和广泛使用的Node平台框架之一，阿里开源的Egg.js也是基于Koa扩展。那么Koa到底做了什么呢？洋葱头模型又是怎么一回事？Koa有哪些关键的组件？ 本文为你娓娓道来。">
<meta name="twitter:image" content="https://happyhls.me/2018/10/16/egg-koa-source-code-analysis/koa-middlewares-code.jpg">






  <link rel="canonical" href="https://happyhls.me/2018/10/16/egg-koa-source-code-analysis/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Koa源代码分析 | happyhls</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">happyhls</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://happyhls.me/2018/10/16/egg-koa-source-code-analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="happyhls">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="happyhls">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Koa源代码分析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-10-16 23:59:22" itemprop="dateCreated datePublished" datetime="2018-10-16T23:59:22+08:00">2018-10-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-10-17 00:28:13" itemprop="dateModified" datetime="2018-10-17T00:28:13+08:00">2018-10-17</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Koa是最为常见和广泛使用的Node平台框架之一，阿里开源的Egg.js也是基于Koa扩展。那么Koa到底做了什么呢？洋葱头模型又是怎么一回事？Koa有哪些关键的组件？</p>
<p>本文为你娓娓道来。</p>
<a id="more"></a>
<p>Koa的代码，要从createServer说起</p>
<h2 id="刀工火种-VS-Koa"><a href="#刀工火种-VS-Koa" class="headerlink" title="刀工火种 VS Koa"></a>刀工火种 VS Koa</h2><h3 id="使用Node-js提供的http库创建WebServer"><a href="#使用Node-js提供的http库创建WebServer" class="headerlink" title="使用Node.js提供的http库创建WebServer"></a>使用Node.js提供的http库创建WebServer</h3><p>我们想实现一个简单的WebServer，要求实现以下功能:</p>
<ul>
<li>简单记录请求和返回结果</li>
<li>统计每次请求所需要花费的事件</li>
<li>执行一个时间1s的任务，并将结果返回</li>
<li>监听3000端口。</li>
</ul>
<p>不使用框架的条件下，我们的代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="keyword">async</span> (request, response) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Starting processing request: <span class="subst">$&#123;request&#125;</span> with url: <span class="subst">$&#123;request.url&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> header = request.headers || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> method = request.method;</span><br><span class="line">  <span class="keyword">const</span> contentType = header[<span class="string">'Content-Type'</span>];</span><br><span class="line">  <span class="keyword">const</span> length = header[<span class="string">'Content-Length'</span>] || <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> doTask();</span><br><span class="line">  <span class="keyword">const</span> time = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Task is finished within <span class="subst">$&#123;time&#125;</span>ms.`</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> body = <span class="string">`Hello World <span class="subst">$&#123;result&#125;</span>.`</span>;</span><br><span class="line">  response.end(body);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Finishing processing with response: <span class="subst">$&#123;response&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行之后，结果是这样的：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Terminal</span><br><span class="line">Starting processing request: [object Object]</span><br><span class="line">Task is finished within 1004ms.</span><br><span class="line">Finishing processing with response: [object Object]</span><br></pre></td></tr></table></figure>
<p>网页输出</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World 1.</span><br></pre></td></tr></table></figure>
<p>很简单吧，可是思考一下这样几个问题？</p>
<ul>
<li>记录请求和返回结果，占用了大量的磁盘空间，我想把这个功能下掉，该怎么办呢？</li>
<li>我需要启动多个Server，是不是每个Server实例都需要把上面代码Copy一份呢？</li>
</ul>
<p>Koa就是为了解决以上问题而设计的，如果我们使用Koa，该怎么写代码呢？</p>
<h3 id="使用Koa创建Server"><a href="#使用Koa创建Server" class="headerlink" title="使用Koa创建Server"></a>使用Koa创建Server</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> request = ctx.request;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Starting processing request: <span class="subst">$&#123;request&#125;</span> with url: <span class="subst">$&#123;request.url&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">const</span> response = ctx.response;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Finishing processing with response: <span class="subst">$&#123;response&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">const</span> time = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Task is finished within <span class="subst">$&#123;time&#125;</span>ms.`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> doTask();</span><br><span class="line">  ctx.body = <span class="string">`Hello World <span class="subst">$&#123;result&#125;</span>.`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回过来思考上述的代码，解答最初提到的两个问题：</p>
<ol>
<li>需要下掉日志记录的功能，怎么处理呢？<br>答：删掉以下代码</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">app.use(async (ctx, next) =&gt; &#123;</span></span><br><span class="line"><span class="comment">  const request = ctx.request;</span></span><br><span class="line"><span class="comment">  console.log(`Starting processing request: $&#123;request&#125; with url: $&#123;request.url&#125;`);</span></span><br><span class="line"><span class="comment">  await next();</span></span><br><span class="line"><span class="comment">  const response = ctx.response;</span></span><br><span class="line"><span class="comment">  console.log(`Finishing processing with response: $&#123;response&#125;`);</span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>启动多个Server，每个Server都需要具备以上基本功能<br>答: 只要启动一个Koa，并注册对应功能代码块（Middleware）即可</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app2 = <span class="keyword">new</span> Koa();</span><br><span class="line">app2.use(xxx);</span><br><span class="line">app2.listen(<span class="number">3001</span>);</span><br></pre></td></tr></table></figure>
<h3 id="为什么要使用Koa？"><a href="#为什么要使用Koa？" class="headerlink" title="为什么要使用Koa？"></a>为什么要使用Koa？</h3><p>我们来分析一下使用http库或者使用Koa分别实现一个简单的WebServer，其区别在哪里？</p>
<p>学习过Koa的同学都了解，Koa源代码主要有4个js文件</p>
<ul>
<li>application.js</li>
<li>context.js</li>
<li>request.js</li>
<li>response.js</li>
</ul>
<p>这4个文件，分别对应了Koa的四大组件: Application，Context，Request，Response，其中Request、Response是对应node中<strong>http.IncomingMessage</strong>和<strong>http.ServerResponse</strong> ；Context顾名思义，为上下文，通过Context将请求处理过程中需要用的各种资源汇总联系起来；Application则是Koa程序的主要入口。</p>
<p>需要注意的是，Koa通过 <strong>koa-compose</strong> 模块还实现了非常重要的中间件机制（即非常有明的洋葱头模型），后面会详细分析。</p>
<p>将Koa的各个模块映射到原生的http实现的WebServer上，整体上是以下的分布: </p>
<img src="/2018/10/16/egg-koa-source-code-analysis/koa-middlewares-code.jpg" title="Koa middlewares code">
<h2 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h2><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>Application是Koa中最为核心的模块，即整个程序的入口。前面的Demo中，涉及Application代码如下:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们实现了以下逻辑:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>); <span class="comment">// 导入koa模块，实际上导入了application.js</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa(); <span class="comment">// 创建了一个Koa实例</span></span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;&#125;); <span class="comment">// 添加了一个中间件，用于添加日志，统计时间，响应请求</span></span><br><span class="line">app.listen(<span class="number">3000</span>); <span class="comment">// 启动监听</span></span><br></pre></td></tr></table></figure>
<h4 id="1-创建实例"><a href="#1-创建实例" class="headerlink" title="1. 创建实例"></a>1. 创建实例</h4><p>通过<strong>new Koa()</strong>创建了一个Koa实例，框架中，构造函数中的逻辑并不多</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.proxy = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.middleware = [];</span><br><span class="line">    <span class="keyword">this</span>.subdomainOffset = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.env = process.env.NODE_ENV || <span class="string">'development'</span>;</span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">    <span class="keyword">if</span> (util.inspect.custom) &#123;</span><br><span class="line">      <span class="keyword">this</span>[util.inspect.custom] = <span class="keyword">this</span>.inspect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>首先需要明确的是，Application继承了Emitter，也就是可以通过Application的实例监听各种事件，Koa用的多了，我们经常看见各种<strong>app.on(event, () =&gt; {})</strong>等事件监听处理，其出处就在这里。</li>
<li>创建了一个middleware的数组，这里保存了我们注册的各种中间件</li>
<li>创建属性env，来表示当前的运行环境，默认是 development</li>
<li>创建了几个实例，context, request, response</li>
</ol>
<h4 id="2-app-use-middleware"><a href="#2-app-use-middleware" class="headerlink" title="2. app.use(middleware)"></a>2. app.use(middleware)</h4><p>通过<strong>app.use(middleware)</strong>可以实现Koa中间件的注册，其代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use(fn) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'middleware must be a function!'</span>);</span><br><span class="line">  <span class="keyword">if</span> (isGeneratorFunction(fn)) &#123;</span><br><span class="line">    deprecate(<span class="string">'Support for generators will be removed in v3. '</span> +</span><br><span class="line">              <span class="string">'See the documentation for examples of how to convert old middleware '</span> +</span><br><span class="line">              <span class="string">'https://github.com/koajs/koa/blob/master/docs/migration.md'</span>);</span><br><span class="line">    fn = convert(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  debug(<span class="string">'use %s'</span>, fn._name || fn.name || <span class="string">'-'</span>);</span><br><span class="line">  <span class="keyword">this</span>.middleware.push(fn);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中可以发现，这一块逻辑特别简单，一句话说 <strong>将中间件函数放入middleware中</strong></p>
<ol>
<li>判断fn的属性，保证其为函数</li>
<li>如果是GeneratorFunction，那么保留对其兼容，并通过 <strong>koa-convert</strong> 包，依赖 <strong>co</strong> 将函数包装为返回Promise的普通函数</li>
<li>至此，fn应该为普通的函数，或者是async异步函数，均压栈保存即可。</li>
</ol>
<h4 id="3-app-listen-3000"><a href="#3-app-listen-3000" class="headerlink" title="3. app.listen(3000)"></a>3. app.listen(3000)</h4><p>通过listen()方法的调用，就真正的把WebServer启动起来，其中的逻辑具体来看</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listen(...args) &#123;</span><br><span class="line">  debug(<span class="string">'listen'</span>);</span><br><span class="line">  <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback());</span><br><span class="line">  <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍一看，特别简单，通过 <strong>http.createServer</strong>启动了一个WebServer，将 <strong>this.callback()</strong>作为入参传入Server，监听各个请求并处理。<br>所以，所有的业务逻辑，都在 <strong>callback</strong> 中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">callback() &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware); <span class="comment">// 将middleware组装为一个function</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.listenerCount(<span class="string">'error'</span>)) <span class="keyword">this</span>.on(<span class="string">'error'</span>, <span class="keyword">this</span>.onerror); <span class="comment">// 如果当前app没有绑定error事件，则绑定默认的监听</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">  &#125;; <span class="comment">// 构造请求处理Handler</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> handleRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>callback</strong>中有四处玄机</p>
<ul>
<li>将middleware中间件通过compose组装为一个function</li>
<li>如果app没有配置error监听，那么第一次会手动绑定一个error事件</li>
<li>收到请求的时候，创建新的ctx实例</li>
<li>将请求交给this.handleRequest处理，并将生成的中间件function和上下文context传入</li>
</ul>
<h4 id="koa-compose-洋葱头模型"><a href="#koa-compose-洋葱头模型" class="headerlink" title="koa-compose 洋葱头模型"></a>koa-compose 洋葱头模型</h4><p>compose的代码比较清晰，简要做了注释，代码放在这里:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = compose</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 首先是两个断言，保证传入的middleware参数是一个只保存了function的数组</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(middleware)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware stack must be an array!'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware must be composed of functions!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span></span><br><span class="line">    <span class="comment">// 返回的function为dispatch(0)，即指向第一个压栈的中间件</span></span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 保护，避免重复调用导致堆栈溢出</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>))</span><br><span class="line">      <span class="comment">// 更新索引，指向当前调用的中间件</span></span><br><span class="line">      index = i</span><br><span class="line">      <span class="comment">// 取出当前要调用的中间件</span></span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="comment">// 如果middleware数组遍历完了，那么就指向外部传入的next方法</span></span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next</span><br><span class="line">      <span class="comment">// 如果fn不存在，也就是所有的中间件、包括传入的next方法都执行完成，Promise.resolve返回成功</span></span><br><span class="line">      <span class="comment">// 前面的中间件，await next()方法就已经执行完成，可以继续处理后面的业务逻辑，也就是洋葱头的后面部分。</span></span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当前的中间件可以处理，同时将指向下个中间件的dispatch函数作为next参数传入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 如果出错了，则抛出异常</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码大体的脉络如下：</p>
<ul>
<li>compose函数为入口，首先做了两个假设：<ul>
<li>假设传入的middleware参数是个数组</li>
<li>假设传入的middleware中的每个元素都是function</li>
</ul>
</li>
<li>递归实现: 中间件的依次调用+洋葱头模型<ul>
<li>从第一个中间件开始调用dispatch(0), index指向当前调用的第index个中间件</li>
<li>如果index已经越界，说明前面的中间件已经处理完成，待处理function指向传入的next方法</li>
<li>如果已经没有待处理的方法了，直接<strong>Promise.resolve()</strong>确认结果</li>
<li>如果待处理function存在，则调用，并将disptch(index + 1)指向下一个中间件的处理函数作为next参数传入</li>
<li>Koa中间件要求显示调用await方法，因此对于每个中间件逻辑都是如下：<ul>
<li>处理当前中间件的一部分逻辑，即『前置逻辑』</li>
<li>调用<strong>await next()</strong>执行下一个中间件</li>
<li>下一个中间件处理完成之后，继续处理当前中间件剩下的部分，即『后置逻辑』。</li>
<li>如此递归处理，实现洋葱头模型。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>官方洋葱头模型介绍</strong></p>
<img src="/2018/10/16/egg-koa-source-code-analysis/koa-middlewares-onion.jpg" title="Koa middlewares onion">
<p><strong>官方中间件调用顺序介绍</strong></p>
<img src="/2018/10/16/egg-koa-source-code-analysis/koa-middlewares-sample.jpg" title="Koa middlewares sample">
<p>洋葱头的中间件模型，是Koa最引以为豪的一个设计，基于大量的中间件实现，可以实现丰富的功能。在前面的代码分析中，我们已经详尽的了解了<strong>koa-compose</strong>的逻辑，如果你还不理解，还有个思路：<br>大家知道，对于Java同学来说，Spring的AOP模型是再也熟悉不过的了，而这里的中间件设计，和切面再相似不过，其中有一种切面是 <strong>Around advice</strong>，典型的代码是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AroundExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Around</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.businessService()"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">doBasicProfiling</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// start stopwatch</span></span><br><span class="line">    Object retVal = pjp.proceed();</span><br><span class="line">    <span class="comment">// stop stopwatch</span></span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是基本上一样？当然实际上AOP的功能要强大的多</p>
<p><strong>总结</strong></p>
<ul>
<li>返回一个function，指向第一个中间件</li>
<li>通过递归调用和中间件的 <strong>await next()</strong>实现洋葱头模型</li>
</ul>
<h4 id="创建Context-this-createContext"><a href="#创建Context-this-createContext" class="headerlink" title="创建Context, this.createContext"></a>创建Context, this.createContext</h4><p>createContext()，顾名思义，其作用就是为这次建立的请求创建上下文，那么上下文Context是什么呢？</p>
<blockquote>
<p>A Koa Context encapsulates node’s request and response objects into a single object which provides many helpful methods for writing web applications and APIs. These operations are used so frequently in HTTP server development that they are added at this level instead of a higher level framework, which would force middleware to re-implement this common functionality.</p>
</blockquote>
<ul>
<li>Context是用来把请求Request和响应Response封装在一起的一个对象</li>
<li>Context提供了大量常见、通用、频繁调用的基础功能，无需再次开发</li>
<li>Context是中间件的第一个参数，观察请求的整个链路。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">createContext(req, res) &#123;</span><br><span class="line">  <span class="comment">// 基于Koa内置模板，生成context，request, response对象</span></span><br><span class="line">  <span class="comment">// 需要注意的是，每个请求，都有一个新的context对象</span></span><br><span class="line">  <span class="keyword">const</span> context = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.context);</span><br><span class="line">  <span class="keyword">const</span> request = context.request = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.request);</span><br><span class="line">  <span class="keyword">const</span> response = context.response = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.response);</span><br><span class="line">  <span class="comment">// 将app, ctx, request, response对象相互绑定在一起</span></span><br><span class="line">  context.app = request.app = response.app = <span class="keyword">this</span>;</span><br><span class="line">  context.req = request.req = response.req = req;</span><br><span class="line">  context.res = request.res = response.res = res;</span><br><span class="line">  request.ctx = response.ctx = context;</span><br><span class="line">  request.response = response;</span><br><span class="line">  response.request = request;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将请求的url配置为属性originaUrl，并挂载在context和request中</span></span><br><span class="line">  context.originalUrl = request.originalUrl = req.url;</span><br><span class="line">  <span class="comment">// 生成cookie对象</span></span><br><span class="line">  context.cookies = <span class="keyword">new</span> Cookies(req, res, &#123;</span><br><span class="line">    keys: <span class="keyword">this</span>.keys,</span><br><span class="line">    secure: request.secure</span><br><span class="line">  &#125;);</span><br><span class="line">  request.ip = request.ips[<span class="number">0</span>] || req.socket.remoteAddress || <span class="string">''</span>;</span><br><span class="line">  context.state = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码，我们进一步了解到了:</p>
<ul>
<li>每一次请求，都会创建新的context、request、response对象</li>
<li>context、request、response之间相互持有引用，可以互相访问得到</li>
<li>context中保存了一些常见的方法和请求参数可以使用</li>
</ul>
<h4 id="处理请求-this-handleRequest"><a href="#处理请求-this-handleRequest" class="headerlink" title="处理请求 this.handleRequest"></a>处理请求 this.handleRequest</h4><p><strong>handleRequest</strong>方法是真正处理请求的函数，其具体的业务逻辑如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">  res.statusCode = <span class="number">404</span>;</span><br><span class="line">  <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">  <span class="comment">// 请求最终会转发至respond方法</span></span><br><span class="line">  <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</span><br><span class="line">  <span class="comment">// 这是一个开源库，会自动添加一个请求完成或者失败的listener</span></span><br><span class="line">  onFinished(res, onerror);</span><br><span class="line">  <span class="comment">// 先调用中间件，然后请求交给handleResponse, 如果出错则通知onerror处理</span></span><br><span class="line">  <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键的就这一句<strong>fnMiddleware(ctx).then(handleResponse).catch(onerror)</strong>，其中<strong>fnMiddleware</strong>为前面通过<strong>koa-compose</strong>组合的中间件。也就是说，所有的请求，都会一一流经所有的中间件，然后交给<strong>handleResponse</strong>做收尾处理，那么<strong>handleResponse</strong>即<strong>respond(ctx)</strong>做了什么操作呢？老规矩，代码粘过来，简单分析下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">respond</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 校验下链路是否已经断开，是否不需要处理</span></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果请求为空，那么清空数据，并返回</span></span><br><span class="line">  <span class="keyword">if</span> (statuses.empty[code]) &#123;</span><br><span class="line">    <span class="comment">// strip headers</span></span><br><span class="line">    ctx.body = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果请求的方法为HEAD，那么将长度修正为内容真正的长度</span></span><br><span class="line">  <span class="comment">// 同时HEAD请求不会把真正的请求数据返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'HEAD'</span> == ctx.method) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span><br><span class="line">      ctx.length = Buffer.byteLength(<span class="built_in">JSON</span>.stringify(body));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.end();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// status body 如果body为空，那么就把状态码作为body返回</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">null</span> == body) &#123;</span><br><span class="line">    body = ctx.message || <span class="built_in">String</span>(code);</span><br><span class="line">    <span class="keyword">if</span> (!res.headersSent) &#123;</span><br><span class="line">      ctx.type = <span class="string">'text'</span>;</span><br><span class="line">      ctx.length = Buffer.byteLength(body);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.end(body);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// responses 填充响应结果</span></span><br><span class="line">  <span class="comment">// 如果是二进制流或者是字符串，那么直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (Buffer.isBuffer(body)) <span class="keyword">return</span> res.end(body);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'string'</span> == <span class="keyword">typeof</span> body) <span class="keyword">return</span> res.end(body);</span><br><span class="line">  <span class="comment">// 如果响应是Stream流，那么直接Pipe到res</span></span><br><span class="line">  <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Stream) <span class="keyword">return</span> body.pipe(res);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// body: json 默认情况下，则认为是JSON，直接按照JSON格式输出</span></span><br><span class="line">  body = <span class="built_in">JSON</span>.stringify(body);</span><br><span class="line">  <span class="keyword">if</span> (!res.headersSent) &#123;</span><br><span class="line">    ctx.length = Buffer.byteLength(body);</span><br><span class="line">  &#125;</span><br><span class="line">  res.end(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码主要做了以下几件事情：</p>
<ul>
<li>响应之前，保证链路是通的，链路没有问题</li>
<li>根据响应状态码，如果状态码为204，修正body，body无数据</li>
<li>根据请求Method，如果是HEAD请求，那么只返回内容长度，body不返回</li>
<li>根据body的格式，响应结果<ul>
<li>body为空，那么就把状态码同步到body中</li>
<li>body为二进制，直接返回</li>
<li>body为字符串，直接返回</li>
<li>body为Stream流，pipe</li>
<li>body为JSON(默认)，将结果封装为JSON格式</li>
</ul>
</li>
</ul>
<p>至此，Application的关键业务逻辑已经梳理完成了，我们总结一下：</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Application主要做了以下事情：</p>
<ul>
<li>创建Application实例，保存了应用的基本信息，包括中间件的配置</li>
<li>创建了一个Http WebServer，监听请求并响应<ul>
<li>请求建立的时候，首先将用户配置的中间件compose为一个新的方法，实现洋葱头的中间件模型，使用中间件处理请求</li>
<li>根据处理的结果，请求的参数和方法，响应的数据格式，包装为用户需要的类型 </li>
</ul>
</li>
</ul>
<h4 id="题外话1"><a href="#题外话1" class="headerlink" title="题外话1"></a>题外话1</h4><p>Koa在处理每一个请求，都会处理对应的ctx, req, res。如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.context);</span><br><span class="line"><span class="keyword">const</span> request = context.request = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.request);</span><br><span class="line"><span class="keyword">const</span> response = context.response = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.response);</span><br></pre></td></tr></table></figure>
<p>有意思的一个地方时， 新对象实例的创建，是基于Koa在启动默认创建的已有对象，而不是内置的Context.prototype，这样做什么深意呢？<br>实际上，无论是下面两种写法，都可以实现创建一个context实例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = <span class="built_in">Object</span>.create(Context.prototype); <span class="comment">// 方法A</span></span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.context); <span class="comment">// 方法B</span></span><br></pre></td></tr></table></figure>
<p>方法B的好处在哪里？</p>
<ul>
<li>Koa的使用者可以根据需要动态的在this.context添加属性和方法，而每次请求创建的context实例会自动继承这些属性和方法</li>
<li>如果直接基于Context.prototype创建实例</li>
</ul>
<p>app.context是所有请求的context的prototype，也就是说，所有请求的上下文，都基于app.context实现。其好处就是，可以灵活方便的动态在app.context上下文中添加属性，所有请求均可使用</p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>顾名思义，Request即请求类，Koa会将所有的请求都给包装成Request，那么有疑问了，Koa的<strong>Request</strong>和<strong>http.IncomingMessage</strong>有什么区别呢？</p>
<blockquote>
<p>A Koa Request object is an abstraction on top of node’s vanilla request object, providing additional functionality that is useful for every day HTTP server development.</p>
</blockquote>
<p>Koa的<strong>Request</strong>其是就是<strong>http.IncomingMessage</strong>的一个包装类，主要有以下两个特点：</p>
<ul>
<li><strong>http.IncomingMessage</strong>中常用的属性和方法直接代理</li>
<li>提供了许多额外的便利方法</li>
</ul>
<p>Request中常用的方法属性列一下：</p>
<ul>
<li>header/headers: 代理 req.headers</li>
<li>url: 代理 req.url</li>
<li>origin: <strong>${this.protocol}://${this.host}</strong></li>
<li>href: 请求的完整路径，如 <strong><a href="http://example.com/foo" target="_blank" rel="noopener">http://example.com/foo</a></strong></li>
<li>method: 代理 req.method</li>
<li>path: 根据路径返回path，比如<strong><a href="http://example.com/foo" target="_blank" rel="noopener">http://example.com/foo</a></strong>的path为 <strong>foo</strong></li>
<li>query: 查询字符串 query-string</li>
<li>search: 问号+query-string ==&gt; <strong>?${query-string}</strong></li>
<li>host: 不是很理解，先放在这里，代码上其实解析的是header中的Host字段，没有用过，后面查下资料。 Parse the “Host” header field host and support X-Forwarded-Host when a proxy is enabled.</li>
<li>hostname: 基本上同上</li>
<li>URL: 获取WHATWG规范的URL，参考: <a href="https://url.spec.whatwg.org/#example-url-parsing" target="_blank" rel="noopener">https://url.spec.whatwg.org/#example-url-parsing</a></li>
<li>fresh: 判断用户端Cache是否有效</li>
<li>stale: <strong>!fresh</strong></li>
<li>idempotent: 判断支持幂等的请求，也就是说，请求可以多次发生而数据保持一致，Koa中主要根据Method即请求的方法来判断: <a href="http://restcookbook.com/HTTP%20Methods/idempotency/" target="_blank" rel="noopener">http://restcookbook.com/HTTP%20Methods/idempotency/</a></li>
<li>socket: 原始的socket</li>
<li>charset: Header中Content-Type指定的charset</li>
<li>length: Header中Content-Length指定的</li>
<li>protocol: 请求为https还是http</li>
<li>secure: 是否为http</li>
<li>accept: 工具类，判断指定的type是否接收</li>
<li>get: <strong>重要</strong>此方法为特别常用的方法，可以直接用来获取req.header中指定字段内容</li>
</ul>
<p>总体来说，Request主要封装了响应相关的常见方法，最典型的是请求参数的处理和Header的处理，方法很多，但方法都很简单，大概看下即可。</p>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>与Request类似，Response也是Koa的封装类，包装了<strong>http.ServerResponse</strong>, 具体来看看有用的方法:</p>
<ul>
<li>socket: 指向这次请求的socket</li>
<li>header: 指向res.header，这里针对node老版本做了兼容</li>
<li>get/set: 针对header提供的遍历操作方法，Response.get/set直接操作对应的header<ul>
<li>get: 直接读取res.header中对应字段的内容</li>
<li>set: 直接将&lt;Key, Value&gt;字段写入header中</li>
</ul>
</li>
<li>status: get/set，如果get方法，那么读取res当前的status值，set方法则是变更当前res的status</li>
<li>message: 同status</li>
<li>body: get方法直接读取，没什么好说的，set方法有很多逻辑，需要说明一下：  <ul>
<li>如果body设置为空，那么则清空header中对应的 <strong>Content-Type</strong> <strong>Content-Length</strong> <strong>Transfer-Encoding</strong>字段</li>
<li>如果body不为空，则没有stausCode的情况下，修正为默认的200</li>
<li>如果body的value为字符串<ul>
<li>字符串为 &lt;/ 开头，则认为是Html语言，设置<strong>type=html</strong></li>
<li>反之，认为是text，设置<strong>type=text</strong></li>
</ul>
</li>
<li>如果body为二进制，设置<strong>type=bin</strong></li>
<li>如果body为流，且存在pipe方法，那么<strong>type=bin</strong>，同时去除<strong>Content-Length</strong><ul>
<li>同时配置ErrorHandler和FinishHandler，用于异常处理</li>
</ul>
</li>
<li>默认情况下，body为JSON格式（此时this.body = {} 对象），<strong>type=json</strong></li>
</ul>
</li>
<li>length: 即长度，同样根据type返回不同的值</li>
<li>headerSent: <strong>res.headersSent</strong></li>
<li>redirect(url, alt): 重定向逻辑<ul>
<li>如果指定url为<strong>back</strong>,那么则读取Header中’Referrer’的值，或者使用alt</li>
<li>配置statusCode = 302</li>
<li>将重定向文本写入body</li>
</ul>
</li>
<li>attachment: 为响应添加附件</li>
<li>type: 读取或者设置返回的数据类型，比如 json、bin、html等</li>
<li>get/set: 同Request，其实指向了res.header，并提供直接的get和set</li>
<li>append: 这个比较有意思，Header中某些字段其实本质上数组，或者类似与数组的概念，有多个数据，append则是不改变之前数据的基础之上，将新的数据追加上去 <strong>this.append(‘Set-Cookie’, ‘foo=bar; Path=/; HttpOnly’);</strong></li>
<li>remove: 移出某个Header </li>
<li>writable: 数据是否仍然可以写入<ul>
<li>res.finished: 请求已经处理完成了，则无法再写入</li>
<li>socket.writeable</li>
</ul>
</li>
<li>flushHeaders: 完成header处理，res.flushHeaders</li>
</ul>
<p>总体来说，Response主要封装了响应相关的常见方法，最典型的是body的处理和Header的处理，方法很多，但方法都很简单，大概看下即可。</p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>在前面，我们学习了Koa的三个核心概念，<strong>Application</strong>、<strong>Request</strong>、<strong>Response</strong>，现在来谈谈<strong>Context</strong><br>Context即上下文，一般用来贯穿整个请求。实际上在Koa中，Context也是这样使用的。</p>
<blockquote>
<p>A Koa Context encapsulates node’s request and response objects into a single object which provides many helpful methods for writing web applications and APIs. These operations are used so frequently in HTTP server development that they are added at this level instead of a higher level framework, which would force middleware to re-implement this common functionality.</p>
</blockquote>
<p>如官网所说，Context一共做了以下的几件事情：</p>
<ul>
<li>将request和response对象集合在一起</li>
<li>其中提供了很多处理网络请求方便的方法</li>
</ul>
<p><strong>将Request和Response对象集合在一起</strong><br>这一个特点，是通过以下两个方面来实现的：</p>
<ol>
<li><strong>Application#createContext(req, res)</strong><br>在Application的代码中，每次请求建立的时候，会自动调用<strong>createContext</strong>来创建上下文，如前面分析，Koa会在这个地方将req、res、ctx相互绑定在一起，再回顾下关键代码</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.context);</span><br><span class="line"><span class="keyword">const</span> request = context.request = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.request);</span><br><span class="line"><span class="keyword">const</span> response = context.response = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.response);</span><br><span class="line">context.app = request.app = response.app = <span class="keyword">this</span>;</span><br><span class="line">context.req = request.req = response.req = req;</span><br><span class="line">context.res = request.res = response.res = res;</span><br><span class="line">request.ctx = response.ctx = context;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Context中大量的方法代理至对应的req和res中</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">delegate(proto, <span class="string">'response'</span>)</span><br><span class="line">  .method(<span class="string">'attachment'</span>)</span><br><span class="line">  .method(<span class="string">'redirect'</span>)</span><br><span class="line">  .method(<span class="string">'remove'</span>)</span><br><span class="line">  .method(<span class="string">'vary'</span>)</span><br><span class="line">  .method(<span class="string">'set'</span>)</span><br><span class="line">  .method(<span class="string">'append'</span>)</span><br><span class="line">  .method(<span class="string">'flushHeaders'</span>)</span><br><span class="line">  .access(<span class="string">'status'</span>)</span><br><span class="line">  .access(<span class="string">'message'</span>)</span><br><span class="line">  .access(<span class="string">'body'</span>)</span><br><span class="line">  .access(<span class="string">'length'</span>)</span><br><span class="line">  .access(<span class="string">'type'</span>)</span><br><span class="line">  .access(<span class="string">'lastModified'</span>)</span><br><span class="line">  .access(<span class="string">'etag'</span>)</span><br><span class="line">  .getter(<span class="string">'headerSent'</span>)</span><br><span class="line">  .getter(<span class="string">'writable'</span>);</span><br><span class="line"></span><br><span class="line">delegate(proto, <span class="string">'request'</span>)</span><br><span class="line">  .method(<span class="string">'acceptsLanguages'</span>)</span><br><span class="line">  .method(<span class="string">'acceptsEncodings'</span>)</span><br><span class="line">  .method(<span class="string">'acceptsCharsets'</span>)</span><br><span class="line">  .method(<span class="string">'accepts'</span>)</span><br><span class="line">  .method(<span class="string">'get'</span>)</span><br><span class="line">  .method(<span class="string">'is'</span>)</span><br><span class="line">  .access(<span class="string">'querystring'</span>)</span><br><span class="line">  .access(<span class="string">'idempotent'</span>)</span><br><span class="line">  .access(<span class="string">'socket'</span>)</span><br><span class="line">  .access(<span class="string">'search'</span>)</span><br><span class="line">  .access(<span class="string">'method'</span>)</span><br><span class="line">  .access(<span class="string">'query'</span>)</span><br><span class="line">  .access(<span class="string">'path'</span>)</span><br><span class="line">  .access(<span class="string">'url'</span>)</span><br><span class="line">  .access(<span class="string">'accept'</span>)</span><br><span class="line">  .getter(<span class="string">'origin'</span>)</span><br><span class="line">  .getter(<span class="string">'href'</span>)</span><br><span class="line">  .getter(<span class="string">'subdomains'</span>)</span><br><span class="line">  .getter(<span class="string">'protocol'</span>)</span><br><span class="line">  .getter(<span class="string">'host'</span>)</span><br><span class="line">  .getter(<span class="string">'hostname'</span>)</span><br><span class="line">  .getter(<span class="string">'URL'</span>)</span><br><span class="line">  .getter(<span class="string">'header'</span>)</span><br><span class="line">  .getter(<span class="string">'headers'</span>)</span><br><span class="line">  .getter(<span class="string">'secure'</span>)</span><br><span class="line">  .getter(<span class="string">'stale'</span>)</span><br><span class="line">  .getter(<span class="string">'fresh'</span>)</span><br><span class="line">  .getter(<span class="string">'ips'</span>)</span><br><span class="line">  .getter(<span class="string">'ip'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>提供了很多处理网络请求方便的方法</strong><br>Context中提供了大量的方便方法，可以在处理请求的时候</p>
<ul>
<li>assert: httpAssert</li>
<li>throw: 抛出异常，实际上调用<strong>http-errors</strong>的createError，会返回对应的错误码给客户端</li>
<li>onerror: 默认的error监听</li>
</ul>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/12/27/android-fresco-source-code-2-simpledraweeview/" rel="next" title="Fresco源代码分析之二：SimpleDraweeView如何拉取图片并绘制在屏幕上？">
                <i class="fa fa-chevron-left"></i> Fresco源代码分析之二：SimpleDraweeView如何拉取图片并绘制在屏幕上？
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">happyhls</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">85</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">31</span>
                    <span class="site-state-item-name">categories</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">39</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#刀工火种-VS-Koa"><span class="nav-number">1.</span> <span class="nav-text">刀工火种 VS Koa</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Node-js提供的http库创建WebServer"><span class="nav-number">1.1.</span> <span class="nav-text">使用Node.js提供的http库创建WebServer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Koa创建Server"><span class="nav-number">1.2.</span> <span class="nav-text">使用Koa创建Server</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要使用Koa？"><span class="nav-number">1.3.</span> <span class="nav-text">为什么要使用Koa？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四大组件"><span class="nav-number">2.</span> <span class="nav-text">四大组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Application"><span class="nav-number">2.1.</span> <span class="nav-text">Application</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-创建实例"><span class="nav-number">2.1.1.</span> <span class="nav-text">1. 创建实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-app-use-middleware"><span class="nav-number">2.1.2.</span> <span class="nav-text">2. app.use(middleware)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-app-listen-3000"><span class="nav-number">2.1.3.</span> <span class="nav-text">3. app.listen(3000)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#koa-compose-洋葱头模型"><span class="nav-number">2.1.4.</span> <span class="nav-text">koa-compose 洋葱头模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建Context-this-createContext"><span class="nav-number">2.1.5.</span> <span class="nav-text">创建Context, this.createContext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理请求-this-handleRequest"><span class="nav-number">2.1.6.</span> <span class="nav-text">处理请求 this.handleRequest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">2.1.7.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#题外话1"><span class="nav-number">2.1.8.</span> <span class="nav-text">题外话1</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Request"><span class="nav-number">2.2.</span> <span class="nav-text">Request</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Response"><span class="nav-number">2.3.</span> <span class="nav-text">Response</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Context"><span class="nav-number">2.4.</span> <span class="nav-text">Context</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">happyhls</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.4.2</div>




        








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1253608767&web_id=1253608767" language="JavaScript"></script>
  </div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
